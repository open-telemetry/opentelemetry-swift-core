/*
 * Copyright The OpenTelemetry Authors
 * SPDX-License-Identifier: Apache-2.0
 */
// DO **NOT** EDIT. This file is automatically generated.import Foundation

public enum SemanticAttributes: String {
  
    
    /**
    /// Unique identifier for a particular build or compilation of the application..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case appBuildId = "app.build_id"
    /**
    /// A unique identifier representing the installation of an application on a specific device.

    ~~~
    // Examples

    ~~~

    - Note: /// Its value SHOULD persist across launches of the same application installation, including through application upgrades.
      /// It SHOULD change if the application is uninstalled or if all applications of the vendor are uninstalled.
      /// Additionally, users might be able to reset this value (e.g. by clearing application data).
      /// If an app is installed multiple times on the same device (e.g. in different accounts on Android), each `app.installation.id` SHOULD have a different value.
      /// If multiple OpenTelemetry SDKs are used within the same application, they SHOULD use the same value for `app.installation.id`.
      /// Hardware IDs (e.g. serial number, IMEI, MAC address) MUST NOT be used as the `app.installation.id`.
      ///
      /// For iOS, this value SHOULD be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/identifierforvendor).
      ///
      /// For Android, examples of `app.installation.id` implementations include:
      ///
      /// - [Firebase Installation ID](https://firebase.google.com/docs/projects/manage-installations).
      /// - A globally unique UUID which is persisted across sessions in your application.
      /// - [App set ID](https://developer.android.com/identity/app-set-id).
      /// - [`Settings.getString(Settings.Secure.ANDROID_ID)`](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).
      ///
      /// More information about Android identifier best practices can be found in the [Android user data IDs guide](https://developer.android.com/training/articles/user-data-ids)..
    - Requires: Value type should be ``
    */
    case appInstallationId = "app.installation.id"
    /**
    /// A number of frame renders that experienced jank..

    ~~~
    // Examples

    ~~~

    - Note: /// Depending on platform limitations, the value provided MAY be approximation..
    - Requires: Value type should be ``
    */
    case appJankFrameCount = "app.jank.frame_count"
    /**
    /// The time period, in seconds, for which this jank is being reported..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case appJankPeriod = "app.jank.period"
    /**
    /// The minimum rendering threshold for this jank, in seconds..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case appJankThreshold = "app.jank.threshold"
    /**
    /// The x (horizontal) coordinate of a screen coordinate, in screen pixels..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case appScreenCoordinateX = "app.screen.coordinate.x"
    /**
    /// The y (vertical) component of a screen coordinate, in screen pixels..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case appScreenCoordinateY = "app.screen.coordinate.y"
    /**
    /// An identifier that uniquely differentiates this widget from other widgets in the same application..

    ~~~
    // Examples

    ~~~

    - Note: /// A widget is an application component, typically an on-screen visual GUI element..
    - Requires: Value type should be ``
    */
    case appWidgetId = "app.widget.id"
    /**
    /// The name of an application widget..

    ~~~
    // Examples

    ~~~

    - Note: /// A widget is an application component, typically an on-screen visual GUI element..
    - Requires: Value type should be ``
    */
    case appWidgetName = "app.widget.name"
    /**
    /// The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html)..
    - Requires: Value type should be ``
    */
    case cassandraConsistencyLevel = "cassandra.consistency.level"
    /**
    /// The data center of the coordinating node for a query..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cassandraCoordinatorDc = "cassandra.coordinator.dc"
    /**
    /// The ID of the coordinating node for a query..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cassandraCoordinatorId = "cassandra.coordinator.id"
    /**
    /// The fetch size used for paging, i.e. how many rows will be returned at once..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cassandraPageSize = "cassandra.page.size"
    /**
    /// Whether or not the query is idempotent..
    - Requires: Value type should be ``
    */
    case cassandraQueryIdempotent = "cassandra.query.idempotent"
    /**
    /// The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cassandraSpeculativeExecutionCount = "cassandra.speculative_execution.count"
    /**
    /// Client address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..

    ~~~
    // Examples

    ~~~

    - Note: /// When observed from the server side, and when communicating through an intermediary, `client.address` SHOULD represent the client address behind any intermediaries,  for example proxies, if it's available..
    - Requires: Value type should be ``
    */
    case clientAddress = "client.address"
    /**
    /// Client port number..

    ~~~
    // Examples

    ~~~

    - Note: /// When observed from the server side, and when communicating through an intermediary, `client.port` SHOULD represent the client port behind any intermediaries,  for example proxies, if it's available..
    - Requires: Value type should be ``
    */
    case clientPort = "client.port"
    /**
    /// The column number in `code.file.path` best representing the operation. It SHOULD point within the code unit named in `code.function.name`. This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Line'. This constraint is imposed to prevent redundancy and maintain data integrity..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case codeColumnNumber = "code.column.number"
    /**
    /// The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path). This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Function'. This constraint is imposed to prevent redundancy and maintain data integrity..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case codeFilePath = "code.file.path"
    /**
    /// The method or function fully-qualified name without arguments. The value should fit the natural representation of the language runtime, which is also likely the same used within `code.stacktrace` attribute value. This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Function'. This constraint is imposed to prevent redundancy and maintain data integrity..

    ~~~
    // Examples

    ~~~

    - Note: /// Values and format depends on each language runtime, thus it is impossible to provide an exhaustive list of examples.
      /// The values are usually the same (or prefixes of) the ones found in native stack trace representation stored in
      /// `code.stacktrace` without information on arguments.
      ///
      /// Examples:
      ///
      /// - Java method: `com.example.MyHttpService.serveRequest`
      /// - Java anonymous class method: `com.mycompany.Main$1.myMethod`
      /// - Java lambda method: `com.mycompany.Main$$Lambda/0x0000748ae4149c00.myMethod`
      /// - PHP function: `GuzzleHttp\Client::transfer`
      /// - Go function: `github.com/my/repo/pkg.foo.func5`
      /// - Elixir: `OpenTelemetry.Ctx.new`
      /// - Erlang: `opentelemetry_ctx:new`
      /// - Rust: `playground::my_module::my_cool_func`
      /// - C function: `fopen`.
    - Requires: Value type should be ``
    */
    case codeFunctionName = "code.function.name"
    /**
    /// The line number in `code.file.path` best representing the operation. It SHOULD point within the code unit named in `code.function.name`. This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Line'. This constraint is imposed to prevent redundancy and maintain data integrity..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case codeLineNumber = "code.line.number"
    /**
    /// A stacktrace as a string in the natural representation for the language runtime. The representation is identical to [`exception.stacktrace`](/docs/exceptions/exceptions-spans.md#stacktrace-representation). This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Location'. This constraint is imposed to prevent redundancy and maintain data integrity..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case codeStacktrace = "code.stacktrace"
    /**
    /// The logical CPU number [0..n-1].

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cpuLogicalNumber = "cpu.logical_number"
    /**
    /// The mode of the CPU.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cpuMode = "cpu.mode"
    /**
    /// Value of the garbage collector collection generation..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case cpythonGcGeneration = "cpython.gc.generation"
    /**
    /// The name of the connection pool; unique within the instrumented application. In case the connection pool implementation doesn't provide a name, instrumentation SHOULD use a combination of parameters that would make the name unique, for example, combining attributes `server.address`, `server.port`, and `db.namespace`, formatted as `server.address:server.port/db.namespace`. Instrumentations that generate connection pool name following different patterns SHOULD document it..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case dbClientConnectionPoolName = "db.client.connection.pool.name"
    /**
    /// The state of a connection in the pool.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case dbClientConnectionState = "db.client.connection.state"
    /**
    /// The name of a collection (table, container) within the database..

    ~~~
    // Examples

    ~~~

    - Note: /// It is RECOMMENDED to capture the value as provided by the application
      /// without attempting to do any case normalization.
      ///
      /// The collection name SHOULD NOT be extracted from `db.query.text`,
      /// when the database system supports query text with multiple collections
      /// in non-batch operations.
      ///
      /// For batch operations, if the individual operations are known to have the same
      /// collection name then that collection name SHOULD be used..
    - Requires: Value type should be ``
    */
    case dbCollectionName = "db.collection.name"
    /**
    /// The name of the database, fully qualified within the server address and port..

    ~~~
    // Examples

    ~~~

    - Note: /// If a database system has multiple namespace components, they SHOULD be concatenated from the most general to the most specific namespace component, using `|` as a separator between the components. Any missing components (and their associated separators) SHOULD be omitted.
      /// Semantic conventions for individual database systems SHOULD document what `db.namespace` means in the context of that system.
      /// It is RECOMMENDED to capture the value as provided by the application without attempting to do any case normalization..
    - Requires: Value type should be ``
    */
    case dbNamespace = "db.namespace"
    /**
    /// The number of queries included in a batch operation..

    ~~~
    // Examples

    ~~~

    - Note: /// Operations are only considered batches when they contain two or more operations, and so `db.operation.batch.size` SHOULD never be `1`..
    - Requires: Value type should be ``
    */
    case dbOperationBatchSize = "db.operation.batch.size"
    /**
    /// The name of the operation or command being executed..

    ~~~
    // Examples

    ~~~

    - Note: /// It is RECOMMENDED to capture the value as provided by the application
      /// without attempting to do any case normalization.
      ///
      /// The operation name SHOULD NOT be extracted from `db.query.text`,
      /// when the database system supports query text with multiple operations
      /// in non-batch operations.
      ///
      /// If spaces can occur in the operation name, multiple consecutive spaces
      /// SHOULD be normalized to a single space.
      ///
      /// For batch operations, if the individual operations are known to have the same operation name
      /// then that operation name SHOULD be used prepended by `BATCH `,
      /// otherwise `db.operation.name` SHOULD be `BATCH` or some other database
      /// system specific term if more applicable..
    - Requires: Value type should be ``
    */
    case dbOperationName = "db.operation.name"
    /**
    /// A database operation parameter, with `<key>` being the parameter name, and the attribute value being a string representation of the parameter value..

    ~~~
    // Examples

    ~~~

    - Note: /// For example, a client-side maximum number of rows to read from the database
      /// MAY be recorded as the `db.operation.parameter.max_rows` attribute.
      ///
      /// `db.query.text` parameters SHOULD be captured using `db.query.parameter.<key>`
      /// instead of `db.operation.parameter.<key>`..
    - Requires: Value type should be ``
    */
    case dbOperationParameter = "db.operation.parameter"
    /**
    /// A database query parameter, with `<key>` being the parameter name, and the attribute value being a string representation of the parameter value..

    ~~~
    // Examples

    ~~~

    - Note: /// If a query parameter has no name and instead is referenced only by index,
      /// then `<key>` SHOULD be the 0-based index.
      ///
      /// `db.query.parameter.<key>` SHOULD match
      /// up with the parameterized placeholders present in `db.query.text`.
      ///
      /// `db.query.parameter.<key>` SHOULD NOT be captured on batch operations.
      ///
      /// Examples:
      ///
      /// - For a query `SELECT * FROM users where username =  %s` with the parameter `"jdoe"`,
      ///   the attribute `db.query.parameter.0` SHOULD be set to `"jdoe"`.
      /// - For a query `"SELECT * FROM users WHERE username = %(username)s;` with parameter
      ///   `username = "jdoe"`, the attribute `db.query.parameter.username` SHOULD be set to `"jdoe"`..
    - Requires: Value type should be ``
    */
    case dbQueryParameter = "db.query.parameter"
    /**
    /// Low cardinality summary of a database query..

    ~~~
    // Examples

    ~~~

    - Note: /// The query summary describes a class of database queries and is useful
      /// as a grouping key, especially when analyzing telemetry for database
      /// calls involving complex queries.
      ///
      /// Summary may be available to the instrumentation through
      /// instrumentation hooks or other means. If it is not available, instrumentations
      /// that support query parsing SHOULD generate a summary following
      /// [Generating query summary](/docs/database/database-spans.md#generating-a-summary-of-the-query)
      /// section..
    - Requires: Value type should be ``
    */
    case dbQuerySummary = "db.query.summary"
    /**
    /// The database query being executed..

    ~~~
    // Examples

    ~~~

    - Note: /// For sanitization see [Sanitization of `db.query.text`](/docs/database/database-spans.md#sanitization-of-dbquerytext).
      /// For batch operations, if the individual operations are known to have the same query text then that query text SHOULD be used, otherwise all of the individual query texts SHOULD be concatenated with separator `; ` or some other database system specific separator if more applicable.
      /// Parameterized query text SHOULD NOT be sanitized. Even though parameterized query text can potentially have sensitive data, by using a parameterized query the user is giving a strong signal that any sensitive data will be passed as parameter values, and the benefit to observability of capturing the static part of the query text by default outweighs the risk..
    - Requires: Value type should be ``
    */
    case dbQueryText = "db.query.text"
    /**
    /// Number of rows returned by the operation..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case dbResponseReturnedRows = "db.response.returned_rows"
    /**
    /// Database response status code..

    ~~~
    // Examples

    ~~~

    - Note: /// The status code returned by the database. Usually it represents an error code, but may also represent partial success, warning, or differentiate between various types of successful outcomes.
      /// Semantic conventions for individual database systems SHOULD document what `db.response.status_code` means in the context of that system..
    - Requires: Value type should be ``
    */
    case dbResponseStatusCode = "db.response.status_code"
    /**
    /// The name of a stored procedure within the database..

    ~~~
    // Examples

    ~~~

    - Note: /// It is RECOMMENDED to capture the value as provided by the application
      /// without attempting to do any case normalization.
      ///
      /// For batch operations, if the individual operations are known to have the same
      /// stored procedure name then that stored procedure name SHOULD be used..
    - Requires: Value type should be ``
    */
    case dbStoredProcedureName = "db.stored_procedure.name"
    /**
    /// The database management system (DBMS) product as identified by the client instrumentation..

    - Note: /// The actual DBMS may differ from the one identified by the client. For example, when using PostgreSQL client libraries to connect to a CockroachDB, the `db.system.name` is set to `postgresql` based on the instrumentation's best knowledge..
    - Requires: Value type should be ``
    */
    case dbSystemName = "db.system.name"
    /**
    /// Destination address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..

    ~~~
    // Examples

    ~~~

    - Note: /// When observed from the source side, and when communicating through an intermediary, `destination.address` SHOULD represent the destination address behind any intermediaries, for example proxies, if it's available..
    - Requires: Value type should be ``
    */
    case destinationAddress = "destination.address"
    /**
    /// Destination port number.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case destinationPort = "destination.port"
    /**
    /// A unique identifier representing the device.

    ~~~
    // Examples

    ~~~

    - Note: /// Its value SHOULD be identical for all apps on a device and it SHOULD NOT change if an app is uninstalled and re-installed.
      /// However, it might be resettable by the user for all apps on a device.
      /// Hardware IDs (e.g. vendor-specific serial number, IMEI or MAC address) MAY be used as values.
      ///
      /// More information about Android identifier best practices can be found in the [Android user data IDs guide](https://developer.android.com/training/articles/user-data-ids).
      ///
      /// > [!WARNING]> This attribute may contain sensitive (PII) information. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply,
      /// > ensure you do your own due diligence.> Due to these reasons, this identifier is not recommended for consumer applications and will likely result in rejection from both Google Play and App Store.
      /// > However, it may be appropriate for specific enterprise scenarios, such as kiosk devices or enterprise-managed devices, with appropriate compliance clearance.
      /// > Any instrumentation providing this identifier MUST implement it as an opt-in feature.> See [`app.installation.id`](/docs/registry/attributes/app.md#app-installation-id)>  for a more privacy-preserving alternative..
    - Requires: Value type should be ``
    */
    case deviceId = "device.id"
    /**
    /// The name of the device manufacturer.

    ~~~
    // Examples

    ~~~

    - Note: /// The Android OS provides this field via [Build](https://developer.android.com/reference/android/os/Build#MANUFACTURER). iOS apps SHOULD hardcode the value `Apple`..
    - Requires: Value type should be ``
    */
    case deviceManufacturer = "device.manufacturer"
    /**
    /// The model identifier for the device.

    ~~~
    // Examples

    ~~~

    - Note: /// It's recommended this value represents a machine-readable version of the model identifier rather than the market or consumer-friendly name of the device..
    - Requires: Value type should be ``
    */
    case deviceModelIdentifier = "device.model.identifier"
    /**
    /// The marketing name for the device model.

    ~~~
    // Examples

    ~~~

    - Note: /// It's recommended this value represents a human-readable version of the device model rather than a machine-readable alternative..
    - Requires: Value type should be ``
    */
    case deviceModelName = "device.model.name"
    /**
    /// The disk IO operation direction..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case diskIoDirection = "disk.io.direction"
    /**
    /// The list of IPv4 or IPv6 addresses resolved during DNS lookup..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case dnsAnswers = "dns.answers"
    /**
    /// The name being queried..

    ~~~
    // Examples

    ~~~

    - Note: /// If the name field contains non-printable characters (below 32 or above 126), those characters should be represented as escaped base 10 integers (\DDD). Back slashes and quotes should be escaped. Tabs, carriage returns, and line feeds should be converted to \t, \r, and \n respectively..
    - Requires: Value type should be ``
    */
    case dnsQuestionName = "dns.question.name"
    /**
    /// Represents the human-readable identifier of the node/instance to which a request was routed..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case elasticsearchNodeName = "elasticsearch.node.name"
    /**
    /// Unique identifier of an end user in the system. It maybe a username, email address, or other identifier..

    ~~~
    // Examples

    ~~~

    - Note: /// Unique identifier of an end user in the system.
      ///
      /// > [!Warning]
      /// > This field contains sensitive (PII) information..
    - Requires: Value type should be ``
    */
    case enduserId = "enduser.id"
    /**
    /// Pseudonymous identifier of an end user. This identifier should be a random value that is not directly linked or associated with the end user's actual identity..

    ~~~
    // Examples

    ~~~

    - Note: /// Pseudonymous identifier of an end user.
      ///
      /// > [!Warning]
      /// > This field contains sensitive (linkable PII) information..
    - Requires: Value type should be ``
    */
    case enduserPseudoId = "enduser.pseudo.id"
    /**
    /// A message providing more detail about an error in human-readable form..

    ~~~
    // Examples

    ~~~

    - Note: /// `error.message` should provide additional context and detail about an error.
      /// It is NOT RECOMMENDED to duplicate the value of `error.type` in `error.message`.
      /// It is also NOT RECOMMENDED to duplicate the value of `exception.message` in `error.message`.
      ///
      /// `error.message` is NOT RECOMMENDED for metrics or spans due to its unbounded cardinality and overlap with span status..
    - Requires: Value type should be ``
    */
    case errorMessage = "error.message"
    /**
    /// Describes a class of error the operation ended with..

    ~~~
    // Examples

    ~~~

    - Note: /// The `error.type` SHOULD be predictable, and SHOULD have low cardinality.
      ///
      /// When `error.type` is set to a type (e.g., an exception type), its
      /// canonical class name identifying the type within the artifact SHOULD be used.
      ///
      /// Instrumentations SHOULD document the list of errors they report.
      ///
      /// The cardinality of `error.type` within one instrumentation library SHOULD be low.
      /// Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
      /// should be prepared for `error.type` to have high cardinality at query time when no
      /// additional filters are applied.
      ///
      /// If the operation has completed successfully, instrumentations SHOULD NOT set `error.type`.
      ///
      /// If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
      /// it's RECOMMENDED to:
      ///
      /// - Use a domain-specific attribute
      /// - Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not..
    - Requires: Value type should be ``
    */
    case errorType = "error.type"
    /**
    /// The exception message..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case exceptionMessage = "exception.message"
    /**
    /// A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case exceptionStacktrace = "exception.stacktrace"
    /**
    /// The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case exceptionType = "exception.type"
    /**
    /// Time when the file was last accessed, in ISO 8601 format..

    ~~~
    // Examples

    ~~~

    - Note: /// This attribute might not be supported by some file systems — NFS, FAT32, in embedded OS, etc..
    - Requires: Value type should be ``
    */
    case fileAccessed = "file.accessed"
    /**
    /// Array of file attributes..

    ~~~
    // Examples

    ~~~

    - Note: /// Attributes names depend on the OS or file system. Here’s a non-exhaustive list of values expected for this attribute: `archive`, `compressed`, `directory`, `encrypted`, `execute`, `hidden`, `immutable`, `journaled`, `read`, `readonly`, `symbolic link`, `system`, `temporary`, `write`..
    - Requires: Value type should be ``
    */
    case fileAttributes = "file.attributes"
    /**
    /// Time when the file attributes or metadata was last changed, in ISO 8601 format..

    ~~~
    // Examples

    ~~~

    - Note: /// `file.changed` captures the time when any of the file's properties or attributes (including the content) are changed, while `file.modified` captures the timestamp when the file content is modified..
    - Requires: Value type should be ``
    */
    case fileChanged = "file.changed"
    /**
    /// Time when the file was created, in ISO 8601 format..

    ~~~
    // Examples

    ~~~

    - Note: /// This attribute might not be supported by some file systems — NFS, FAT32, in embedded OS, etc..
    - Requires: Value type should be ``
    */
    case fileCreated = "file.created"
    /**
    /// Directory where the file is located. It should include the drive letter, when appropriate..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileDirectory = "file.directory"
    /**
    /// File extension, excluding the leading dot..

    ~~~
    // Examples

    ~~~

    - Note: /// When the file name has multiple extensions (example.tar.gz), only the last one should be captured ("gz", not "tar.gz")..
    - Requires: Value type should be ``
    */
    case fileExtension = "file.extension"
    /**
    /// Name of the fork. A fork is additional data associated with a filesystem object..

    ~~~
    // Examples

    ~~~

    - Note: /// On Linux, a resource fork is used to store additional data with a filesystem object. A file always has at least one fork for the data portion, and additional forks may exist.
      /// On NTFS, this is analogous to an Alternate Data Stream (ADS), and the default data stream for a file is just called $DATA. Zone.Identifier is commonly used by Windows to track contents downloaded from the Internet. An ADS is typically of the form: C:\path\to\filename.extension:some_fork_name, and some_fork_name is the value that should populate `fork_name`. `filename.extension` should populate `file.name`, and `extension` should populate `file.extension`. The full path, `file.path`, will include the fork name..
    - Requires: Value type should be ``
    */
    case fileForkName = "file.fork_name"
    /**
    /// Primary Group ID (GID) of the file..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileGroupId = "file.group.id"
    /**
    /// Primary group name of the file..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileGroupName = "file.group.name"
    /**
    /// Inode representing the file in the filesystem..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileInode = "file.inode"
    /**
    /// Mode of the file in octal representation..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileMode = "file.mode"
    /**
    /// Time when the file content was last modified, in ISO 8601 format..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileModified = "file.modified"
    /**
    /// Name of the file including the extension, without the directory..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileName = "file.name"
    /**
    /// The user ID (UID) or security identifier (SID) of the file owner..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileOwnerId = "file.owner.id"
    /**
    /// Username of the file owner..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case fileOwnerName = "file.owner.name"
    /**
    /// Full path to the file, including the file name. It should include the drive letter, when appropriate..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case filePath = "file.path"
    /**
    /// File size in bytes..
    - Requires: Value type should be ``
    */
    case fileSize = "file.size"
    /**
    /// Path to the target of a symbolic link..

    ~~~
    // Examples

    ~~~

    - Note: /// This attribute is only applicable to symbolic links..
    - Requires: Value type should be ``
    */
    case fileSymbolicLinkTargetPath = "file.symbolic_link.target_path"
    /**
    /// Two-letter code representing continent’s name..
    - Requires: Value type should be ``
    */
    case geoContinentCode = "geo.continent.code"
    /**
    /// Two-letter ISO Country Code ([ISO 3166-1 alpha2](https://wikipedia.org/wiki/ISO_3166-1#Codes))..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case geoCountryIsoCode = "geo.country.iso_code"
    /**
    /// Locality name. Represents the name of a city, town, village, or similar populated place..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case geoLocalityName = "geo.locality.name"
    /**
    /// Latitude of the geo location in [WGS84](https://wikipedia.org/wiki/World_Geodetic_System#WGS84)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case geoLocationLat = "geo.location.lat"
    /**
    /// Longitude of the geo location in [WGS84](https://wikipedia.org/wiki/World_Geodetic_System#WGS84)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case geoLocationLon = "geo.location.lon"
    /**
    /// Postal code associated with the location. Values appropriate for this field may also be known as a postcode or ZIP code and will vary widely from country to country..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case geoPostalCode = "geo.postal_code"
    /**
    /// Region ISO code ([ISO 3166-2](https://wikipedia.org/wiki/ISO_3166-2))..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case geoRegionIsoCode = "geo.region.iso_code"
    /**
    /// The type of memory..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case goMemoryType = "go.memory.type"
    /**
    /// The GraphQL document being executed..

    ~~~
    // Examples

    ~~~

    - Note: /// The value may be sanitized to exclude sensitive information..
    - Requires: Value type should be ``
    */
    case graphqlDocument = "graphql.document"
    /**
    /// The name of the operation being executed..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case graphqlOperationName = "graphql.operation.name"
    /**
    /// The type of the operation being executed..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case graphqlOperationType = "graphql.operation.type"
    /**
    /// Unique identifier for the application.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case herokuAppId = "heroku.app.id"
    /**
    /// Commit hash for the current release.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case herokuReleaseCommit = "heroku.release.commit"
    /**
    /// Time and date the release was created.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case herokuReleaseCreationTimestamp = "heroku.release.creation_timestamp"
    /**
    /// The CPU architecture the host system is running on..
    - Requires: Value type should be ``
    */
    case hostArch = "host.arch"
    /**
    /// The amount of level 2 memory cache available to the processor (in Bytes)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostCpuCacheL2Size = "host.cpu.cache.l2.size"
    /**
    /// Family or generation of the CPU..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostCpuFamily = "host.cpu.family"
    /**
    /// Model identifier. It provides more granular information about the CPU, distinguishing it from other CPUs within the same family..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostCpuModelId = "host.cpu.model.id"
    /**
    /// Model designation of the processor..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostCpuModelName = "host.cpu.model.name"
    /**
    /// Stepping or core revisions..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostCpuStepping = "host.cpu.stepping"
    /**
    /// Processor manufacturer identifier. A maximum 12-character string..

    ~~~
    // Examples

    ~~~

    - Note: /// [CPUID](https://wiki.osdev.org/CPUID) command returns the vendor ID string in EBX, EDX and ECX registers. Writing these to memory in this order results in a 12-character string..
    - Requires: Value type should be ``
    */
    case hostCpuVendorId = "host.cpu.vendor.id"
    /**
    /// Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider. For non-containerized systems, this should be the `machine-id`. See the table below for the sources to use to determine the `machine-id` based on operating system..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostId = "host.id"
    /**
    /// VM image ID or host OS image ID. For Cloud, this value is from the provider..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostImageId = "host.image.id"
    /**
    /// Name of the VM image or OS install the host was instantiated from..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostImageName = "host.image.name"
    /**
    /// The version string of the VM image or host OS as defined in [Version Attributes](/docs/resource/README.md#version-attributes)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostImageVersion = "host.image.version"
    /**
    /// Available IP addresses of the host, excluding loopback interfaces..

    ~~~
    // Examples

    ~~~

    - Note: /// IPv4 Addresses MUST be specified in dotted-quad notation. IPv6 addresses MUST be specified in the [RFC 5952](https://www.rfc-editor.org/rfc/rfc5952.html) format..
    - Requires: Value type should be ``
    */
    case hostIp = "host.ip"
    /**
    /// Available MAC addresses of the host, excluding loopback interfaces..

    ~~~
    // Examples

    ~~~

    - Note: /// MAC Addresses MUST be represented in [IEEE RA hexadecimal form](https://standards.ieee.org/wp-content/uploads/import/documents/tutorials/eui.pdf): as hyphen-separated octets in uppercase hexadecimal form from most to least significant..
    - Requires: Value type should be ``
    */
    case hostMac = "host.mac"
    /**
    /// Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostName = "host.name"
    /**
    /// Type of host. For Cloud, this must be the machine type..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hostType = "host.type"
    /**
    /// State of the HTTP connection in the HTTP connection pool..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpConnectionState = "http.connection.state"
    /**
    /// The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpRequestBodySize = "http.request.body.size"
    /**
    /// HTTP request headers, `<key>` being the normalized HTTP Header name (lowercase), the value being the header values..

    ~~~
    // Examples

    ~~~

    - Note: /// Instrumentations SHOULD require an explicit configuration of which headers are to be captured.
      /// Including all request headers can be a security risk - explicit configuration helps avoid leaking sensitive information.
      ///
      /// The `User-Agent` header is already captured in the `user_agent.original` attribute.
      /// Users MAY explicitly configure instrumentations to capture them even though it is not recommended.
      ///
      /// The attribute value MUST consist of either multiple header values as an array of strings
      /// or a single-item array containing a possibly comma-concatenated string, depending on the way
      /// the HTTP library provides access to headers.
      ///
      /// Examples:
      ///
      /// - A header `Content-Type: application/json` SHOULD be recorded as the `http.request.header.content-type`
      ///   attribute with value `["application/json"]`.
      /// - A header `X-Forwarded-For: 1.2.3.4, 1.2.3.5` SHOULD be recorded as the `http.request.header.x-forwarded-for`
      ///   attribute with value `["1.2.3.4", "1.2.3.5"]` or `["1.2.3.4, 1.2.3.5"]` depending on the HTTP library..
    - Requires: Value type should be ``
    */
    case httpRequestHeader = "http.request.header"
    /**
    /// HTTP request method..

    ~~~
    // Examples

    ~~~

    - Note: /// HTTP request method value SHOULD be "known" to the instrumentation.
      /// By default, this convention defines "known" methods as the ones listed in [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-methods)
      /// and the PATCH method defined in [RFC5789](https://www.rfc-editor.org/rfc/rfc5789.html).
      ///
      /// If the HTTP request method is not known to instrumentation, it MUST set the `http.request.method` attribute to `_OTHER`.
      ///
      /// If the HTTP instrumentation could end up converting valid HTTP request methods to `_OTHER`, then it MUST provide a way to override
      /// the list of known HTTP methods. If this override is done via environment variable, then the environment variable MUST be named
      /// OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS and support a comma-separated list of case-sensitive known HTTP methods
      /// (this list MUST be a full override of the default known method, it is not a list of known methods in addition to the defaults).
      ///
      /// HTTP method names are case-sensitive and `http.request.method` attribute value MUST match a known HTTP method name exactly.
      /// Instrumentations for specific web frameworks that consider HTTP methods to be case insensitive, SHOULD populate a canonical equivalent.
      /// Tracing instrumentations that do so, MUST also set `http.request.method_original` to the original value..
    - Requires: Value type should be ``
    */
    case httpRequestMethod = "http.request.method"
    /**
    /// Original HTTP method sent by the client in the request line..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpRequestMethodOriginal = "http.request.method_original"
    /**
    /// The ordinal number of request resending attempt (for any reason, including redirects)..

    ~~~
    // Examples

    ~~~

    - Note: /// The resend count SHOULD be updated each time an HTTP request gets resent by the client, regardless of what was the cause of the resending (e.g. redirection, authorization failure, 503 Server Unavailable, network issues, or any other)..
    - Requires: Value type should be ``
    */
    case httpRequestResendCount = "http.request.resend_count"
    /**
    /// The total size of the request in bytes. This should be the total number of bytes sent over the wire, including the request line (HTTP/1.1), framing (HTTP/2 and HTTP/3), headers, and request body if any..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpRequestSize = "http.request.size"
    /**
    /// The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpResponseBodySize = "http.response.body.size"
    /**
    /// HTTP response headers, `<key>` being the normalized HTTP Header name (lowercase), the value being the header values..

    ~~~
    // Examples

    ~~~

    - Note: /// Instrumentations SHOULD require an explicit configuration of which headers are to be captured.
      /// Including all response headers can be a security risk - explicit configuration helps avoid leaking sensitive information.
      ///
      /// Users MAY explicitly configure instrumentations to capture them even though it is not recommended.
      ///
      /// The attribute value MUST consist of either multiple header values as an array of strings
      /// or a single-item array containing a possibly comma-concatenated string, depending on the way
      /// the HTTP library provides access to headers.
      ///
      /// Examples:
      ///
      /// - A header `Content-Type: application/json` header SHOULD be recorded as the `http.request.response.content-type`
      ///   attribute with value `["application/json"]`.
      /// - A header `My-custom-header: abc, def` header SHOULD be recorded as the `http.response.header.my-custom-header`
      ///   attribute with value `["abc", "def"]` or `["abc, def"]` depending on the HTTP library..
    - Requires: Value type should be ``
    */
    case httpResponseHeader = "http.response.header"
    /**
    /// The total size of the response in bytes. This should be the total number of bytes sent over the wire, including the status line (HTTP/1.1), framing (HTTP/2 and HTTP/3), headers, and response body and trailers if any..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpResponseSize = "http.response.size"
    /**
    /// [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case httpResponseStatusCode = "http.response.status_code"
    /**
    /// The matched route, that is, the path template in the format used by the respective server framework..

    ~~~
    // Examples

    ~~~

    - Note: /// MUST NOT be populated when this is not supported by the HTTP server framework as the route attribute should have low-cardinality and the URI path can NOT substitute it.
      /// SHOULD include the [application root](/docs/http/http-spans.md#http-server-definitions) if there is one..
    - Requires: Value type should be ``
    */
    case httpRoute = "http.route"
    /**
    /// Design capacity in Watts-hours or Amper-hours.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwBatteryCapacity = "hw.battery.capacity"
    /**
    /// Battery [chemistry](https://schemas.dmtf.org/wbem/cim-html/2.31.0/CIM_Battery.html), e.g. Lithium-Ion, Nickel-Cadmium, etc..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwBatteryChemistry = "hw.battery.chemistry"
    /**
    /// The current state of the battery.
    - Requires: Value type should be ``
    */
    case hwBatteryState = "hw.battery.state"
    /**
    /// BIOS version of the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwBiosVersion = "hw.bios_version"
    /**
    /// Driver version for the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwDriverVersion = "hw.driver_version"
    /**
    /// Type of the enclosure (useful for modular systems).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwEnclosureType = "hw.enclosure.type"
    /**
    /// Firmware version of the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwFirmwareVersion = "hw.firmware_version"
    /**
    /// Type of task the GPU is performing.
    - Requires: Value type should be ``
    */
    case hwGpuTask = "hw.gpu.task"
    /**
    /// An identifier for the hardware component, unique within the monitored host.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwId = "hw.id"
    /**
    /// Type of limit for hardware components.
    - Requires: Value type should be ``
    */
    case hwLimitType = "hw.limit_type"
    /**
    /// RAID Level of the logical disk.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwLogicalDiskRaidLevel = "hw.logical_disk.raid_level"
    /**
    /// State of the logical disk space usage.
    - Requires: Value type should be ``
    */
    case hwLogicalDiskState = "hw.logical_disk.state"
    /**
    /// Type of the memory module.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwMemoryType = "hw.memory.type"
    /**
    /// Descriptive model name of the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwModel = "hw.model"
    /**
    /// An easily-recognizable name for the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwName = "hw.name"
    /**
    /// Logical addresses of the adapter (e.g. IP address, or WWPN).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwNetworkLogicalAddresses = "hw.network.logical_addresses"
    /**
    /// Physical address of the adapter (e.g. MAC address, or WWNN).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwNetworkPhysicalAddress = "hw.network.physical_address"
    /**
    /// Unique identifier of the parent component (typically the `hw.id` attribute of the enclosure, or disk controller).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwParent = "hw.parent"
    /**
    /// [S.M.A.R.T.](https://wikipedia.org/wiki/S.M.A.R.T.) (Self-Monitoring, Analysis, and Reporting Technology) attribute of the physical disk.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwPhysicalDiskSmartAttribute = "hw.physical_disk.smart_attribute"
    /**
    /// State of the physical disk endurance utilization.
    - Requires: Value type should be ``
    */
    case hwPhysicalDiskState = "hw.physical_disk.state"
    /**
    /// Type of the physical disk.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwPhysicalDiskType = "hw.physical_disk.type"
    /**
    /// Location of the sensor.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwSensorLocation = "hw.sensor_location"
    /**
    /// Serial number of the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwSerialNumber = "hw.serial_number"
    /**
    /// The current state of the component.
    - Requires: Value type should be ``
    */
    case hwState = "hw.state"
    /**
    /// Type of tape drive operation.
    - Requires: Value type should be ``
    */
    case hwTapeDriveOperationType = "hw.tape_drive.operation_type"
    /**
    /// Type of the component.

    - Note: /// Describes the category of the hardware component for which `hw.state` is being reported. For example, `hw.type=temperature` along with `hw.state=degraded` would indicate that the temperature of the hardware component has been reported as `degraded`..
    - Requires: Value type should be ``
    */
    case hwType = "hw.type"
    /**
    /// Vendor name of the hardware component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case hwVendor = "hw.vendor"
    /**
    /// This attribute represents the state of the application..

    - Note: /// The iOS lifecycle states are defined in the [UIApplicationDelegate documentation](https://developer.apple.com/documentation/uikit/uiapplicationdelegate), and from which the `OS terminology` column values are derived..
    - Requires: Value type should be ``
    */
    case iosAppState = "ios.app.state"
    /**
    /// The name of the cluster..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sClusterName = "k8s.cluster.name"
    /**
    /// A pseudo-ID for the cluster, set to the UID of the `kube-system` namespace..

    ~~~
    // Examples

    ~~~

    - Note: /// K8s doesn't have support for obtaining a cluster ID. If this is ever
      /// added, we will recommend collecting the `k8s.cluster.uid` through the
      /// official APIs. In the meantime, we are able to use the `uid` of the
      /// `kube-system` namespace as a proxy for cluster ID. Read on for the
      /// rationale.
      ///
      /// Every object created in a K8s cluster is assigned a distinct UID. The
      /// `kube-system` namespace is used by Kubernetes itself and will exist
      /// for the lifetime of the cluster. Using the `uid` of the `kube-system`
      /// namespace is a reasonable proxy for the K8s ClusterID as it will only
      /// change if the cluster is rebuilt. Furthermore, Kubernetes UIDs are
      /// UUIDs as standardized by
      /// [ISO/IEC 9834-8 and ITU-T X.667](https://www.itu.int/ITU-T/studygroups/com17/oid.html).
      /// Which states:
      ///
      /// > If generated according to one of the mechanisms defined in Rec.
      /// > ITU-T X.667 | ISO/IEC 9834-8, a UUID is either guaranteed to be
      /// > different from all other UUIDs generated before 3603 A.D., or is
      /// > extremely likely to be different (depending on the mechanism chosen).
      ///
      /// Therefore, UIDs between clusters should be extremely unlikely to
      /// conflict..
    - Requires: Value type should be ``
    */
    case k8sClusterUid = "k8s.cluster.uid"
    /**
    /// The name of the Container from Pod specification, must be unique within a Pod. Container runtime usually uses different globally unique name (`container.name`)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sContainerName = "k8s.container.name"
    /**
    /// Number of times the container was restarted. This attribute can be used to identify a particular container (running or stopped) within a container spec..
    - Requires: Value type should be ``
    */
    case k8sContainerRestartCount = "k8s.container.restart_count"
    /**
    /// Last terminated reason of the Container..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sContainerStatusLastTerminatedReason = "k8s.container.status.last_terminated_reason"
    /**
    /// The reason for the container state. Corresponds to the `reason` field of the: [K8s ContainerStateWaiting](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#containerstatewaiting-v1-core) or [K8s ContainerStateTerminated](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#containerstateterminated-v1-core).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sContainerStatusReason = "k8s.container.status.reason"
    /**
    /// The state of the container. [K8s ContainerState](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#containerstate-v1-core).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sContainerStatusState = "k8s.container.status.state"
    /**
    /// The cronjob annotation placed on the CronJob, the `<key>` being the annotation name, the value being the annotation value..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - An annotation `retries` with value `4` SHOULD be recorded as the
      ///   `k8s.cronjob.annotation.retries` attribute with value `"4"`.
      /// - An annotation `data` with empty string value SHOULD be recorded as
      ///   the `k8s.cronjob.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sCronjobAnnotation = "k8s.cronjob.annotation"
    /**
    /// The label placed on the CronJob, the `<key>` being the label name, the value being the label value..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `type` with value `weekly` SHOULD be recorded as the
      ///   `k8s.cronjob.label.type` attribute with value `"weekly"`.
      /// - A label `automated` with empty string value SHOULD be recorded as
      ///   the `k8s.cronjob.label.automated` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sCronjobLabel = "k8s.cronjob.label"
    /**
    /// The name of the CronJob..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sCronjobName = "k8s.cronjob.name"
    /**
    /// The UID of the CronJob..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sCronjobUid = "k8s.cronjob.uid"
    /**
    /// The annotation placed on the DaemonSet, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `replicas` with value `1` SHOULD be recorded
      ///   as the `k8s.daemonset.annotation.replicas` attribute with value `"1"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.daemonset.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sDaemonsetAnnotation = "k8s.daemonset.annotation"
    /**
    /// The label placed on the DaemonSet, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `app` with value `guestbook` SHOULD be recorded
      ///   as the `k8s.daemonset.label.app` attribute with value `"guestbook"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.daemonset.label.injected` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sDaemonsetLabel = "k8s.daemonset.label"
    /**
    /// The name of the DaemonSet..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sDaemonsetName = "k8s.daemonset.name"
    /**
    /// The UID of the DaemonSet..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sDaemonsetUid = "k8s.daemonset.uid"
    /**
    /// The annotation placed on the Deployment, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `replicas` with value `1` SHOULD be recorded
      ///   as the `k8s.deployment.annotation.replicas` attribute with value `"1"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.deployment.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sDeploymentAnnotation = "k8s.deployment.annotation"
    /**
    /// The label placed on the Deployment, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `replicas` with value `0` SHOULD be recorded
      ///   as the `k8s.deployment.label.app` attribute with value `"guestbook"`.
      /// - A label `injected` with empty string value SHOULD be recorded as
      ///   the `k8s.deployment.label.injected` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sDeploymentLabel = "k8s.deployment.label"
    /**
    /// The name of the Deployment..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sDeploymentName = "k8s.deployment.name"
    /**
    /// The UID of the Deployment..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sDeploymentUid = "k8s.deployment.uid"
    /**
    /// The type of metric source for the horizontal pod autoscaler..

    ~~~
    // Examples

    ~~~

    - Note: /// This attribute reflects the `type` field of spec.metrics[] in the HPA..
    - Requires: Value type should be ``
    */
    case k8sHpaMetricType = "k8s.hpa.metric.type"
    /**
    /// The name of the horizontal pod autoscaler..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sHpaName = "k8s.hpa.name"
    /**
    /// The API version of the target resource to scale for the HorizontalPodAutoscaler..

    ~~~
    // Examples

    ~~~

    - Note: /// This maps to the `apiVersion` field in the `scaleTargetRef` of the HPA spec..
    - Requires: Value type should be ``
    */
    case k8sHpaScaletargetrefApiVersion = "k8s.hpa.scaletargetref.api_version"
    /**
    /// The kind of the target resource to scale for the HorizontalPodAutoscaler..

    ~~~
    // Examples

    ~~~

    - Note: /// This maps to the `kind` field in the `scaleTargetRef` of the HPA spec..
    - Requires: Value type should be ``
    */
    case k8sHpaScaletargetrefKind = "k8s.hpa.scaletargetref.kind"
    /**
    /// The name of the target resource to scale for the HorizontalPodAutoscaler..

    ~~~
    // Examples

    ~~~

    - Note: /// This maps to the `name` field in the `scaleTargetRef` of the HPA spec..
    - Requires: Value type should be ``
    */
    case k8sHpaScaletargetrefName = "k8s.hpa.scaletargetref.name"
    /**
    /// The UID of the horizontal pod autoscaler..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sHpaUid = "k8s.hpa.uid"
    /**
    /// The size (identifier) of the K8s huge page..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sHugepageSize = "k8s.hugepage.size"
    /**
    /// The annotation placed on the Job, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `number` with value `1` SHOULD be recorded
      ///   as the `k8s.job.annotation.number` attribute with value `"1"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.job.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sJobAnnotation = "k8s.job.annotation"
    /**
    /// The label placed on the Job, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `jobtype` with value `ci` SHOULD be recorded
      ///   as the `k8s.job.label.jobtype` attribute with value `"ci"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.job.label.automated` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sJobLabel = "k8s.job.label"
    /**
    /// The name of the Job..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sJobName = "k8s.job.name"
    /**
    /// The UID of the Job..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sJobUid = "k8s.job.uid"
    /**
    /// The annotation placed on the Namespace, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `ttl` with value `0` SHOULD be recorded
      ///   as the `k8s.namespace.annotation.ttl` attribute with value `"0"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.namespace.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sNamespaceAnnotation = "k8s.namespace.annotation"
    /**
    /// The label placed on the Namespace, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `kubernetes.io/metadata.name` with value `default` SHOULD be recorded
      ///   as the `k8s.namespace.label.kubernetes.io/metadata.name` attribute with value `"default"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.namespace.label.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sNamespaceLabel = "k8s.namespace.label"
    /**
    /// The name of the namespace that the pod is running in..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sNamespaceName = "k8s.namespace.name"
    /**
    /// The phase of the K8s namespace..

    ~~~
    // Examples

    ~~~

    - Note: /// This attribute aligns with the `phase` field of the
      /// [K8s NamespaceStatus](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#namespacestatus-v1-core).
    - Requires: Value type should be ``
    */
    case k8sNamespacePhase = "k8s.namespace.phase"
    /**
    /// The annotation placed on the Node, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - An annotation `node.alpha.kubernetes.io/ttl` with value `0` SHOULD be recorded as
      ///   the `k8s.node.annotation.node.alpha.kubernetes.io/ttl` attribute with value `"0"`.
      /// - An annotation `data` with empty string value SHOULD be recorded as
      ///   the `k8s.node.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sNodeAnnotation = "k8s.node.annotation"
    /**
    /// The status of the condition, one of True, False, Unknown..

    ~~~
    // Examples

    ~~~

    - Note: /// This attribute aligns with the `status` field of the
      /// [NodeCondition](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#nodecondition-v1-core).
    - Requires: Value type should be ``
    */
    case k8sNodeConditionStatus = "k8s.node.condition.status"
    /**
    /// The condition type of a K8s Node..

    ~~~
    // Examples

    ~~~

    - Note: /// K8s Node conditions as described
      /// by [K8s documentation](https://v1-32.docs.kubernetes.io/docs/reference/node/node-status/#condition).
      ///
      /// This attribute aligns with the `type` field of the
      /// [NodeCondition](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#nodecondition-v1-core)
      ///
      /// The set of possible values is not limited to those listed here. Managed Kubernetes environments,
      /// or custom controllers MAY introduce additional node condition types.
      /// When this occurs, the exact value as reported by the Kubernetes API SHOULD be used..
    - Requires: Value type should be ``
    */
    case k8sNodeConditionType = "k8s.node.condition.type"
    /**
    /// The label placed on the Node, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `kubernetes.io/arch` with value `arm64` SHOULD be recorded
      ///   as the `k8s.node.label.kubernetes.io/arch` attribute with value `"arm64"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.node.label.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sNodeLabel = "k8s.node.label"
    /**
    /// The name of the Node..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sNodeName = "k8s.node.name"
    /**
    /// The UID of the Node..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sNodeUid = "k8s.node.uid"
    /**
    /// The annotation placed on the Pod, the `<key>` being the annotation name, the value being the annotation value..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - An annotation `kubernetes.io/enforce-mountable-secrets` with value `true` SHOULD be recorded as
      ///   the `k8s.pod.annotation.kubernetes.io/enforce-mountable-secrets` attribute with value `"true"`.
      /// - An annotation `mycompany.io/arch` with value `x64` SHOULD be recorded as
      ///   the `k8s.pod.annotation.mycompany.io/arch` attribute with value `"x64"`.
      /// - An annotation `data` with empty string value SHOULD be recorded as
      ///   the `k8s.pod.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sPodAnnotation = "k8s.pod.annotation"
    /**
    /// The label placed on the Pod, the `<key>` being the label name, the value being the label value..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `app` with value `my-app` SHOULD be recorded as
      ///   the `k8s.pod.label.app` attribute with value `"my-app"`.
      /// - A label `mycompany.io/arch` with value `x64` SHOULD be recorded as
      ///   the `k8s.pod.label.mycompany.io/arch` attribute with value `"x64"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.pod.label.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sPodLabel = "k8s.pod.label"
    /**
    /// The name of the Pod..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sPodName = "k8s.pod.name"
    /**
    /// The UID of the Pod..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sPodUid = "k8s.pod.uid"
    /**
    /// The annotation placed on the ReplicaSet, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `replicas` with value `0` SHOULD be recorded
      ///   as the `k8s.replicaset.annotation.replicas` attribute with value `"0"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.replicaset.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sReplicasetAnnotation = "k8s.replicaset.annotation"
    /**
    /// The label placed on the ReplicaSet, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `app` with value `guestbook` SHOULD be recorded
      ///   as the `k8s.replicaset.label.app` attribute with value `"guestbook"`.
      /// - A label `injected` with empty string value SHOULD be recorded as
      ///   the `k8s.replicaset.label.injected` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sReplicasetLabel = "k8s.replicaset.label"
    /**
    /// The name of the ReplicaSet..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sReplicasetName = "k8s.replicaset.name"
    /**
    /// The UID of the ReplicaSet..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sReplicasetUid = "k8s.replicaset.uid"
    /**
    /// The name of the replication controller..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sReplicationcontrollerName = "k8s.replicationcontroller.name"
    /**
    /// The UID of the replication controller..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sReplicationcontrollerUid = "k8s.replicationcontroller.uid"
    /**
    /// The name of the resource quota..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sResourcequotaName = "k8s.resourcequota.name"
    /**
    /// The name of the K8s resource a resource quota defines..

    ~~~
    // Examples

    ~~~

    - Note: /// The value for this attribute can be either the full `count/<resource>[.<group>]` string (e.g., count/deployments.apps, count/pods), or, for certain core Kubernetes resources, just the resource name (e.g., pods, services, configmaps). Both forms are supported by Kubernetes for object count quotas. See [Kubernetes Resource Quotas documentation](https://kubernetes.io/docs/concepts/policy/resource-quotas/#object-count-quota) for more details..
    - Requires: Value type should be ``
    */
    case k8sResourcequotaResourceName = "k8s.resourcequota.resource_name"
    /**
    /// The UID of the resource quota..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sResourcequotaUid = "k8s.resourcequota.uid"
    /**
    /// The annotation placed on the StatefulSet, the `<key>` being the annotation name, the value being the annotation value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `replicas` with value `1` SHOULD be recorded
      ///   as the `k8s.statefulset.annotation.replicas` attribute with value `"1"`.
      /// - A label `data` with empty string value SHOULD be recorded as
      ///   the `k8s.statefulset.annotation.data` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sStatefulsetAnnotation = "k8s.statefulset.annotation"
    /**
    /// The label placed on the StatefulSet, the `<key>` being the label name, the value being the label value, even if the value is empty..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - A label `replicas` with value `0` SHOULD be recorded
      ///   as the `k8s.statefulset.label.app` attribute with value `"guestbook"`.
      /// - A label `injected` with empty string value SHOULD be recorded as
      ///   the `k8s.statefulset.label.injected` attribute with value `""`..
    - Requires: Value type should be ``
    */
    case k8sStatefulsetLabel = "k8s.statefulset.label"
    /**
    /// The name of the StatefulSet..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sStatefulsetName = "k8s.statefulset.name"
    /**
    /// The UID of the StatefulSet..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sStatefulsetUid = "k8s.statefulset.uid"
    /**
    /// The name of K8s [StorageClass](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#storageclass-v1-storage-k8s-io) object..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sStorageclassName = "k8s.storageclass.name"
    /**
    /// The name of the K8s volume..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sVolumeName = "k8s.volume.name"
    /**
    /// The type of the K8s volume..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case k8sVolumeType = "k8s.volume.type"
    /**
    /// The Linux Slab memory state.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case linuxMemorySlabState = "linux.memory.slab.state"
    /**
    /// The basename of the file..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case logFileName = "log.file.name"
    /**
    /// The basename of the file, with symlinks resolved..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case logFileNameResolved = "log.file.name_resolved"
    /**
    /// The full path to the file..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case logFilePath = "log.file.path"
    /**
    /// The full path to the file, with symlinks resolved..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case logFilePathResolved = "log.file.path_resolved"
    /**
    /// The stream associated with the log. See below for a list of well-known values..
    - Requires: Value type should be ``
    */
    case logIostream = "log.iostream"
    /**
    /// The complete original Log Record..

    ~~~
    // Examples

    ~~~

    - Note: /// This value MAY be added when processing a Log Record which was originally transmitted as a string or equivalent data type AND the Body field of the Log Record does not contain the same value. (e.g. a syslog or a log record read from a file.).
    - Requires: Value type should be ``
    */
    case logRecordOriginal = "log.record.original"
    /**
    /// A unique identifier for the Log Record..

    ~~~
    // Examples

    ~~~

    - Note: /// If an id is provided, other log records with the same id will be considered duplicates and can be removed safely. This means, that two distinguishable log records MUST have different values.
      /// The id MAY be an [Universally Unique Lexicographically Sortable Identifier (ULID)](https://github.com/ulid/spec), but other identifiers (e.g. UUID) may be used as needed..
    - Requires: Value type should be ``
    */
    case logRecordUid = "log.record.uid"
    /**
    /// Name of the logical partition that hosts a systems with a mainframe operating system..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case mainframeLparName = "mainframe.lpar.name"
    /**
    /// The number of messages sent, received, or processed in the scope of the batching operation..

    ~~~
    // Examples

    ~~~

    - Note: /// Instrumentations SHOULD NOT set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations SHOULD use `messaging.batch.message_count` for batching APIs and SHOULD NOT use it for single-message APIs..
    - Requires: Value type should be ``
    */
    case messagingBatchMessageCount = "messaging.batch.message_count"
    /**
    /// A unique identifier for the client that consumes or produces a message..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingClientId = "messaging.client.id"
    /**
    /// The name of the consumer group with which a consumer is associated..

    ~~~
    // Examples

    ~~~

    - Note: /// Semantic conventions for individual messaging systems SHOULD document whether `messaging.consumer.group.name` is applicable and what it means in the context of that system..
    - Requires: Value type should be ``
    */
    case messagingConsumerGroupName = "messaging.consumer.group.name"
    /**
    /// A boolean that is true if the message destination is anonymous (could be unnamed or have auto-generated name)..
    - Requires: Value type should be ``
    */
    case messagingDestinationAnonymous = "messaging.destination.anonymous"
    /**
    /// The message destination name.

    ~~~
    // Examples

    ~~~

    - Note: /// Destination name SHOULD uniquely identify a specific queue, topic or other entity within the broker. If
      /// the broker doesn't have such notion, the destination name SHOULD uniquely identify the broker..
    - Requires: Value type should be ``
    */
    case messagingDestinationName = "messaging.destination.name"
    /**
    /// The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingDestinationPartitionId = "messaging.destination.partition.id"
    /**
    /// The name of the destination subscription from which a message is consumed..

    ~~~
    // Examples

    ~~~

    - Note: /// Semantic conventions for individual messaging systems SHOULD document whether `messaging.destination.subscription.name` is applicable and what it means in the context of that system..
    - Requires: Value type should be ``
    */
    case messagingDestinationSubscriptionName = "messaging.destination.subscription.name"
    /**
    /// Low cardinality representation of the messaging destination name.

    ~~~
    // Examples

    ~~~

    - Note: /// Destination names could be constructed from templates. An example would be a destination name involving a user name or product id. Although the destination name in this case is of high cardinality, the underlying template is of low cardinality and can be effectively used for grouping and aggregation..
    - Requires: Value type should be ``
    */
    case messagingDestinationTemplate = "messaging.destination.template"
    /**
    /// A boolean that is true if the message destination is temporary and might not exist anymore after messages are processed..
    - Requires: Value type should be ``
    */
    case messagingDestinationTemporary = "messaging.destination.temporary"
    /**
    /// The UTC epoch seconds at which the message has been accepted and stored in the entity..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingEventhubsMessageEnqueuedTime = "messaging.eventhubs.message.enqueued_time"
    /**
    /// The ack deadline in seconds set for the modify ack deadline request..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingGcpPubsubMessageAckDeadline = "messaging.gcp_pubsub.message.ack_deadline"
    /**
    /// The ack id for a given message..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingGcpPubsubMessageAckId = "messaging.gcp_pubsub.message.ack_id"
    /**
    /// The delivery attempt for a given message..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingGcpPubsubMessageDeliveryAttempt = "messaging.gcp_pubsub.message.delivery_attempt"
    /**
    /// The ordering key for a given message. If the attribute is not present, the message does not have an ordering key..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingGcpPubsubMessageOrderingKey = "messaging.gcp_pubsub.message.ordering_key"
    /**
    /// Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute MUST NOT be set..

    ~~~
    // Examples

    ~~~

    - Note: /// If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value..
    - Requires: Value type should be ``
    */
    case messagingKafkaMessageKey = "messaging.kafka.message.key"
    /**
    /// A boolean that is true if the message is a tombstone..
    - Requires: Value type should be ``
    */
    case messagingKafkaMessageTombstone = "messaging.kafka.message.tombstone"
    /**
    /// The offset of a record in the corresponding Kafka partition..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingKafkaOffset = "messaging.kafka.offset"
    /**
    /// The size of the message body in bytes..

    ~~~
    // Examples

    ~~~

    - Note: /// This can refer to both the compressed or uncompressed body size. If both sizes are known, the uncompressed
      /// body size should be used..
    - Requires: Value type should be ``
    */
    case messagingMessageBodySize = "messaging.message.body.size"
    /**
    /// The conversation ID identifying the conversation to which the message belongs, represented as a string. Sometimes called "Correlation ID"..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingMessageConversationId = "messaging.message.conversation_id"
    /**
    /// The size of the message body and metadata in bytes..

    ~~~
    // Examples

    ~~~

    - Note: /// This can refer to both the compressed or uncompressed size. If both sizes are known, the uncompressed
      /// size should be used..
    - Requires: Value type should be ``
    */
    case messagingMessageEnvelopeSize = "messaging.message.envelope.size"
    /**
    /// A value used by the messaging system as an identifier for the message, represented as a string..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingMessageId = "messaging.message.id"
    /**
    /// The system-specific name of the messaging operation..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingOperationName = "messaging.operation.name"
    /**
    /// A string identifying the type of the messaging operation..

    - Note: /// If a custom value is used, it MUST be of low cardinality..
    - Requires: Value type should be ``
    */
    case messagingOperationType = "messaging.operation.type"
    /**
    /// RabbitMQ message routing key..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRabbitmqDestinationRoutingKey = "messaging.rabbitmq.destination.routing_key"
    /**
    /// RabbitMQ message delivery tag.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRabbitmqMessageDeliveryTag = "messaging.rabbitmq.message.delivery_tag"
    /**
    /// Model of message consumption. This only applies to consumer spans..
    - Requires: Value type should be ``
    */
    case messagingRocketmqConsumptionModel = "messaging.rocketmq.consumption_model"
    /**
    /// The delay time level for delay message, which determines the message delay time..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRocketmqMessageDelayTimeLevel = "messaging.rocketmq.message.delay_time_level"
    /**
    /// The timestamp in milliseconds that the delay message is expected to be delivered to consumer..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRocketmqMessageDeliveryTimestamp = "messaging.rocketmq.message.delivery_timestamp"
    /**
    /// It is essential for FIFO message. Messages that belong to the same message group are always processed one by one within the same consumer group..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRocketmqMessageGroup = "messaging.rocketmq.message.group"
    /**
    /// Key(s) of message, another way to mark message besides message id..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRocketmqMessageKeys = "messaging.rocketmq.message.keys"
    /**
    /// The secondary classifier of message besides topic..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRocketmqMessageTag = "messaging.rocketmq.message.tag"
    /**
    /// Type of message..
    - Requires: Value type should be ``
    */
    case messagingRocketmqMessageType = "messaging.rocketmq.message.type"
    /**
    /// Namespace of RocketMQ resources, resources in different namespaces are individual..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingRocketmqNamespace = "messaging.rocketmq.namespace"
    /**
    /// Describes the [settlement type](https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock)..
    - Requires: Value type should be ``
    */
    case messagingServicebusDispositionStatus = "messaging.servicebus.disposition_status"
    /**
    /// Number of deliveries that have been attempted for this message..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingServicebusMessageDeliveryCount = "messaging.servicebus.message.delivery_count"
    /**
    /// The UTC epoch seconds at which the message has been accepted and stored in the entity..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case messagingServicebusMessageEnqueuedTime = "messaging.servicebus.message.enqueued_time"
    /**
    /// The messaging system as identified by the client instrumentation..

    - Note: /// The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge..
    - Requires: Value type should be ``
    */
    case messagingSystem = "messaging.system"
    /**
    /// The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkCarrierIcc = "network.carrier.icc"
    /**
    /// The mobile carrier country code..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkCarrierMcc = "network.carrier.mcc"
    /**
    /// The mobile carrier network code..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkCarrierMnc = "network.carrier.mnc"
    /**
    /// The name of the mobile carrier..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkCarrierName = "network.carrier.name"
    /**
    /// The state of network connection.

    ~~~
    // Examples

    ~~~

    - Note: /// Connection states are defined as part of the [rfc9293](https://datatracker.ietf.org/doc/html/rfc9293#section-3.3.2).
    - Requires: Value type should be ``
    */
    case networkConnectionState = "network.connection.state"
    /**
    /// This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkConnectionSubtype = "network.connection.subtype"
    /**
    /// The internet connection type..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkConnectionType = "network.connection.type"
    /**
    /// The network interface name..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkInterfaceName = "network.interface.name"
    /**
    /// The network IO operation direction..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkIoDirection = "network.io.direction"
    /**
    /// Local address of the network connection - IP address or Unix domain socket name..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkLocalAddress = "network.local.address"
    /**
    /// Local port number of the network connection..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkLocalPort = "network.local.port"
    /**
    /// Peer address of the network connection - IP address or Unix domain socket name..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkPeerAddress = "network.peer.address"
    /**
    /// Peer port number of the network connection..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case networkPeerPort = "network.peer.port"
    /**
    /// [OSI application layer](https://wikipedia.org/wiki/Application_layer) or non-OSI equivalent..

    ~~~
    // Examples

    ~~~

    - Note: /// The value SHOULD be normalized to lowercase..
    - Requires: Value type should be ``
    */
    case networkProtocolName = "network.protocol.name"
    /**
    /// The actual version of the protocol used for network communication..

    ~~~
    // Examples

    ~~~

    - Note: /// If protocol version is subject to negotiation (for example using [ALPN](https://www.rfc-editor.org/rfc/rfc7301.html)), this attribute SHOULD be set to the negotiated version. If the actual protocol version is not known, this attribute SHOULD NOT be set..
    - Requires: Value type should be ``
    */
    case networkProtocolVersion = "network.protocol.version"
    /**
    /// [OSI transport layer](https://wikipedia.org/wiki/Transport_layer) or [inter-process communication method](https://wikipedia.org/wiki/Inter-process_communication)..

    ~~~
    // Examples

    ~~~

    - Note: /// The value SHOULD be normalized to lowercase.
      ///
      /// Consider always setting the transport when setting a port number, since
      /// a port number is ambiguous without knowing the transport. For example
      /// different processes could be listening on TCP port 12345 and UDP port 12345..
    - Requires: Value type should be ``
    */
    case networkTransport = "network.transport"
    /**
    /// [OSI network layer](https://wikipedia.org/wiki/Network_layer) or non-OSI equivalent..

    ~~~
    // Examples

    ~~~

    - Note: /// The value SHOULD be normalized to lowercase..
    - Requires: Value type should be ``
    */
    case networkType = "network.type"
    /**
    /// The state of event loop time..
    - Requires: Value type should be ``
    */
    case nodejsEventloopState = "nodejs.eventloop.state"
    /**
    /// The digest of the OCI image manifest. For container images specifically is the digest by which the container image is known..

    ~~~
    // Examples

    ~~~

    - Note: /// Follows [OCI Image Manifest Specification](https://github.com/opencontainers/image-spec/blob/main/manifest.md), and specifically the [Digest property](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests).
      /// An example can be found in [Example Image Manifest](https://github.com/opencontainers/image-spec/blob/main/manifest.md#example-image-manifest)..
    - Requires: Value type should be ``
    */
    case ociManifestDigest = "oci.manifest.digest"
    /**
    /// The service tier requested. May be a specific tier, default, or auto..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case openaiRequestServiceTier = "openai.request.service_tier"
    /**
    /// The service tier used for the response..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case openaiResponseServiceTier = "openai.response.service_tier"
    /**
    /// A fingerprint to track any eventual change in the Generative AI environment..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case openaiResponseSystemFingerprint = "openai.response.system_fingerprint"
    /**
    /// Parent-child Reference type.

    - Note: /// The causal relationship between a child Span and a parent Span..
    - Requires: Value type should be ``
    */
    case opentracingRefType = "opentracing.ref_type"
    /**
    /// Unique identifier for a particular build or compilation of the operating system..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case osBuildId = "os.build_id"
    /**
    /// Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case osDescription = "os.description"
    /**
    /// Human readable operating system name..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case osName = "os.name"
    /**
    /// The operating system type..
    - Requires: Value type should be ``
    */
    case osType = "os.type"
    /**
    /// The version string of the operating system as defined in [Version Attributes](/docs/resource/README.md#version-attributes)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case osVersion = "os.version"
    /**
    /// A name uniquely identifying the instance of the OpenTelemetry component within its containing SDK instance..

    ~~~
    // Examples

    ~~~

    - Note: /// Implementations SHOULD ensure a low cardinality for this attribute, even across application or SDK restarts.
      /// E.g. implementations MUST NOT use UUIDs as values for this attribute.
      ///
      /// Implementations MAY achieve these goals by following a `<otel.component.type>/<instance-counter>` pattern, e.g. `batching_span_processor/0`.
      /// Hereby `otel.component.type` refers to the corresponding attribute value of the component.
      ///
      /// The value of `instance-counter` MAY be automatically assigned by the component and uniqueness within the enclosing SDK instance MUST be guaranteed.
      /// For example, `<instance-counter>` MAY be implemented by using a monotonically increasing counter (starting with `0`), which is incremented every time an
      /// instance of the given component type is started.
      ///
      /// With this implementation, for example the first Batching Span Processor would have `batching_span_processor/0`
      /// as `otel.component.name`, the second one `batching_span_processor/1` and so on.
      /// These values will therefore be reused in the case of an application restart..
    - Requires: Value type should be ``
    */
    case otelComponentName = "otel.component.name"
    /**
    /// A name identifying the type of the OpenTelemetry component..

    ~~~
    // Examples

    ~~~

    - Note: /// If none of the standardized values apply, implementations SHOULD use the language-defined name of the type.
      /// E.g. for Java the fully qualified classname SHOULD be used in this case..
    - Requires: Value type should be ``
    */
    case otelComponentType = "otel.component.type"
    /**
    /// The name of the instrumentation scope - (`InstrumentationScope.Name` in OTLP)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case otelScopeName = "otel.scope.name"
    /**
    /// The schema URL of the instrumentation scope..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case otelScopeSchemaUrl = "otel.scope.schema_url"
    /**
    /// The version of the instrumentation scope - (`InstrumentationScope.Version` in OTLP)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case otelScopeVersion = "otel.scope.version"
    /**
    /// Determines whether the span has a parent span, and if so, [whether it is a remote parent](https://opentelemetry.io/docs/specs/otel/trace/api/#isremote).
    - Requires: Value type should be ``
    */
    case otelSpanParentOrigin = "otel.span.parent.origin"
    /**
    /// The result value of the sampler for this span.
    - Requires: Value type should be ``
    */
    case otelSpanSamplingResult = "otel.span.sampling_result"
    /**
    /// Name of the code, either "OK" or "ERROR". MUST NOT be set if the status code is UNSET..
    - Requires: Value type should be ``
    */
    case otelStatusCode = "otel.status_code"
    /**
    /// Description of the Status if it has a value, otherwise not set..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case otelStatusDescription = "otel.status_description"
    /**
    /// The [`service.name`](/docs/resource/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case peerService = "peer.service"
    /**
    /// Length of the process.command_args array.

    ~~~
    // Examples

    ~~~

    - Note: /// This field can be useful for querying or performing bucket analysis on how many arguments were provided to start a process. More arguments may be an indication of suspicious activity..
    - Requires: Value type should be ``
    */
    case processArgsCount = "process.args_count"
    /**
    /// The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processCommand = "process.command"
    /**
    /// All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`. SHOULD NOT be collected by default unless there is sanitization that excludes sensitive data..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processCommandArgs = "process.command_args"
    /**
    /// The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead. SHOULD NOT be collected by default unless there is sanitization that excludes sensitive data..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processCommandLine = "process.command_line"
    /**
    /// Specifies whether the context switches for this data point were voluntary or involuntary..
    - Requires: Value type should be ``
    */
    case processContextSwitchType = "process.context_switch_type"
    /**
    /// The date and time the process was created, in ISO 8601 format..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processCreationTime = "process.creation.time"
    /**
    /// Process environment variables, `<key>` being the environment variable name, the value being the environment variable value..

    ~~~
    // Examples

    ~~~

    - Note: /// Examples:
      ///
      /// - an environment variable `USER` with value `"ubuntu"` SHOULD be recorded
      ///   as the `process.environment_variable.USER` attribute with value `"ubuntu"`.
      /// - an environment variable `PATH` with value `"/usr/local/bin:/usr/bin"`
      ///   SHOULD be recorded as the `process.environment_variable.PATH` attribute
      ///   with value `"/usr/local/bin:/usr/bin"`..
    - Requires: Value type should be ``
    */
    case processEnvironmentVariable = "process.environment_variable"
    /**
    /// The GNU build ID as found in the `.note.gnu.build-id` ELF section (hex string)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExecutableBuildIdGnu = "process.executable.build_id.gnu"
    /**
    /// The Go build ID as retrieved by `go tool buildid <go executable>`..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExecutableBuildIdGo = "process.executable.build_id.go"
    /**
    /// Profiling specific build ID for executables. See the OTel specification for Profiles for more information..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExecutableBuildIdHtlhash = "process.executable.build_id.htlhash"
    /**
    /// The name of the process executable. On Linux based systems, this SHOULD be set to the base name of the target of `/proc/[pid]/exe`. On Windows, this SHOULD be set to the base name of `GetProcessImageFileNameW`..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExecutableName = "process.executable.name"
    /**
    /// The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExecutablePath = "process.executable.path"
    /**
    /// The exit code of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExitCode = "process.exit.code"
    /**
    /// The date and time the process exited, in ISO 8601 format..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processExitTime = "process.exit.time"
    /**
    /// The PID of the process's group leader. This is also the process group ID (PGID) of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processGroupLeaderPid = "process.group_leader.pid"
    /**
    /// Whether the process is connected to an interactive shell..
    - Requires: Value type should be ``
    */
    case processInteractive = "process.interactive"
    /**
    /// The control group associated with the process..

    ~~~
    // Examples

    ~~~

    - Note: /// Control groups (cgroups) are a kernel feature used to organize and manage process resources. This attribute provides the path(s) to the cgroup(s) associated with the process, which should match the contents of the [/proc/[PID]/cgroup](https://man7.org/linux/man-pages/man7/cgroups.7.html) file..
    - Requires: Value type should be ``
    */
    case processLinuxCgroup = "process.linux.cgroup"
    /**
    /// The username of the user that owns the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processOwner = "process.owner"
    /**
    /// The type of page fault for this data point. Type `major` is for major/hard page faults, and `minor` is for minor/soft page faults..
    - Requires: Value type should be ``
    */
    case processPagingFaultType = "process.paging.fault_type"
    /**
    /// Parent Process identifier (PPID)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processParentPid = "process.parent_pid"
    /**
    /// Process identifier (PID)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processPid = "process.pid"
    /**
    /// The real user ID (RUID) of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processRealUserId = "process.real_user.id"
    /**
    /// The username of the real user of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processRealUserName = "process.real_user.name"
    /**
    /// An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processRuntimeDescription = "process.runtime.description"
    /**
    /// The name of the runtime of this process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processRuntimeName = "process.runtime.name"
    /**
    /// The version of the runtime of this process, as returned by the runtime without modification..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processRuntimeVersion = "process.runtime.version"
    /**
    /// The saved user ID (SUID) of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processSavedUserId = "process.saved_user.id"
    /**
    /// The username of the saved user..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processSavedUserName = "process.saved_user.name"
    /**
    /// The PID of the process's session leader. This is also the session ID (SID) of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processSessionLeaderPid = "process.session_leader.pid"
    /**
    /// Process title (proctitle).

    ~~~
    // Examples

    ~~~

    - Note: /// In many Unix-like systems, process title (proctitle), is the string that represents the name or command line of a running process, displayed by system monitoring tools like ps, top, and htop..
    - Requires: Value type should be ``
    */
    case processTitle = "process.title"
    /**
    /// The effective user ID (EUID) of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processUserId = "process.user.id"
    /**
    /// The username of the effective user of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processUserName = "process.user.name"
    /**
    /// Virtual process identifier..

    ~~~
    // Examples

    ~~~

    - Note: /// The process ID within a PID namespace. This is not necessarily unique across all processes on the host but it is unique within the process namespace that the process exists within..
    - Requires: Value type should be ``
    */
    case processVpid = "process.vpid"
    /**
    /// The working directory of the process..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case processWorkingDirectory = "process.working_directory"
    /**
    /// Describes the interpreter or compiler of a single frame..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case profileFrameType = "profile.frame.type"
    /**
    /// A categorization value keyword used by the entity using the rule for detection of this event.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleCategory = "security_rule.category"
    /**
    /// The description of the rule generating the event..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleDescription = "security_rule.description"
    /**
    /// Name of the license under which the rule used to generate this event is made available..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleLicense = "security_rule.license"
    /**
    /// The name of the rule or signature generating the event..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleName = "security_rule.name"
    /**
    /// Reference URL to additional information about the rule used to generate this event..

    ~~~
    // Examples

    ~~~

    - Note: /// The URL can point to the vendor’s documentation about the rule. If that’s not available, it can also be a link to a more general page describing this type of alert..
    - Requires: Value type should be ``
    */
    case securityRuleReference = "security_rule.reference"
    /**
    /// Name of the ruleset, policy, group, or parent category in which the rule used to generate this event is a member..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleRulesetName = "security_rule.ruleset.name"
    /**
    /// A rule ID that is unique within the scope of a set or group of agents, observers, or other entities using the rule for detection of this event..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleUuid = "security_rule.uuid"
    /**
    /// The version / revision of the rule being used for analysis..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case securityRuleVersion = "security_rule.version"
    /**
    /// Server domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..

    ~~~
    // Examples

    ~~~

    - Note: /// When observed from the client side, and when communicating through an intermediary, `server.address` SHOULD represent the server address behind any intermediaries, for example proxies, if it's available..
    - Requires: Value type should be ``
    */
    case serverAddress = "server.address"
    /**
    /// Server port number..

    ~~~
    // Examples

    ~~~

    - Note: /// When observed from the client side, and when communicating through an intermediary, `server.port` SHOULD represent the server port behind any intermediaries, for example proxies, if it's available..
    - Requires: Value type should be ``
    */
    case serverPort = "server.port"
    /**
    /// The string ID of the service instance..

    ~~~
    // Examples

    ~~~

    - Note: /// MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words
      /// `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to
      /// distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled
      /// service).
      ///
      /// Implementations, such as SDKs, are recommended to generate a random Version 1 or Version 4 [RFC
      /// 4122](https://www.ietf.org/rfc/rfc4122.txt) UUID, but are free to use an inherent unique ID as the source of
      /// this value if stability is desirable. In that case, the ID SHOULD be used as source of a UUID Version 5 and
      /// SHOULD use the following UUID as the namespace: `4d63009a-8d0f-11ee-aad7-4c796ed8e320`.
      ///
      /// UUIDs are typically recommended, as only an opaque value for the purposes of identifying a service instance is
      /// needed. Similar to what can be seen in the man page for the
      /// [`/etc/machine-id`](https://www.freedesktop.org/software/systemd/man/latest/machine-id.html) file, the underlying
      /// data, such as pod name and namespace should be treated as confidential, being the user's choice to expose it
      /// or not via another resource attribute.
      ///
      /// For applications running behind an application server (like unicorn), we do not recommend using one identifier
      /// for all processes participating in the application. Instead, it's recommended each division (e.g. a worker
      /// thread in unicorn) to have its own instance.id.
      ///
      /// It's not recommended for a Collector to set `service.instance.id` if it can't unambiguously determine the
      /// service instance that is generating that telemetry. For instance, creating an UUID based on `pod.name` will
      /// likely be wrong, as the Collector might not know from which container within that pod the telemetry originated.
      /// However, Collectors can set the `service.instance.id` if they can unambiguously determine the service instance
      /// for that telemetry. This is typically the case for scraping receivers, as they know the target address and
      /// port..
    - Requires: Value type should be ``
    */
    case serviceInstanceId = "service.instance.id"
    /**
    /// Logical name of the service..

    ~~~
    // Examples

    ~~~

    - Note: /// MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`..
    - Requires: Value type should be ``
    */
    case serviceName = "service.name"
    /**
    /// A namespace for `service.name`..

    ~~~
    // Examples

    ~~~

    - Note: /// A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace..
    - Requires: Value type should be ``
    */
    case serviceNamespace = "service.namespace"
    /**
    /// The version string of the service API or implementation. The format is not defined by these conventions..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case serviceVersion = "service.version"
    /**
    /// A unique id to identify a session..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case sessionId = "session.id"
    /**
    /// The previous `session.id` for this user, when known..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case sessionPreviousId = "session.previous_id"
    /**
    /// Source address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..

    ~~~
    // Examples

    ~~~

    - Note: /// When observed from the destination side, and when communicating through an intermediary, `source.address` SHOULD represent the source address behind any intermediaries, for example proxies, if it's available..
    - Requires: Value type should be ``
    */
    case sourceAddress = "source.address"
    /**
    /// Source port number.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case sourcePort = "source.port"
    /**
    /// Deprecated, use `cpu.logical_number` instead..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemCpuLogicalNumber = "system.cpu.logical_number"
    /**
    /// The device identifier.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemDevice = "system.device"
    /**
    /// The filesystem mode.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemFilesystemMode = "system.filesystem.mode"
    /**
    /// The filesystem mount path.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemFilesystemMountpoint = "system.filesystem.mountpoint"
    /**
    /// The filesystem state.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemFilesystemState = "system.filesystem.state"
    /**
    /// The filesystem type.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemFilesystemType = "system.filesystem.type"
    /**
    /// The memory state.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemMemoryState = "system.memory.state"
    /**
    /// The paging access direction.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemPagingDirection = "system.paging.direction"
    /**
    /// The memory paging state.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemPagingState = "system.paging.state"
    /**
    /// The memory paging type.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemPagingType = "system.paging.type"
    /**
    /// The process state, e.g., [Linux Process State Codes](https://man7.org/linux/man-pages/man1/ps.1.html#PROCESS_STATE_CODES).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case systemProcessStatus = "system.process.status"
    /**
    /// The name of the auto instrumentation agent or distribution, if used..

    ~~~
    // Examples

    ~~~

    - Note: /// Official auto instrumentation agents and distributions SHOULD set the `telemetry.distro.name` attribute to
      /// a string starting with `opentelemetry-`, e.g. `opentelemetry-java-instrumentation`..
    - Requires: Value type should be ``
    */
    case telemetryDistroName = "telemetry.distro.name"
    /**
    /// The version string of the auto instrumentation agent or distribution, if used..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case telemetryDistroVersion = "telemetry.distro.version"
    /**
    /// The language of the telemetry SDK..
    - Requires: Value type should be ``
    */
    case telemetrySdkLanguage = "telemetry.sdk.language"
    /**
    /// The name of the telemetry SDK as defined above..

    ~~~
    // Examples

    ~~~

    - Note: /// The OpenTelemetry SDK MUST set the `telemetry.sdk.name` attribute to `opentelemetry`.
      /// If another SDK, like a fork or a vendor-provided implementation, is used, this SDK MUST set the
      /// `telemetry.sdk.name` attribute to the fully-qualified class or module name of this SDK's main entry point
      /// or another suitable identifier depending on the language.
      /// The identifier `opentelemetry` is reserved and MUST NOT be used in this case.
      /// All custom identifiers SHOULD be stable across different versions of an implementation..
    - Requires: Value type should be ``
    */
    case telemetrySdkName = "telemetry.sdk.name"
    /**
    /// The version string of the telemetry SDK..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case telemetrySdkVersion = "telemetry.sdk.version"
    /**
    /// The fully qualified human readable name of the [test case](https://wikipedia.org/wiki/Test_case)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case testCaseName = "test.case.name"
    /**
    /// The status of the actual test case result from test execution..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case testCaseResultStatus = "test.case.result.status"
    /**
    /// The human readable name of a [test suite](https://wikipedia.org/wiki/Test_suite)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case testSuiteName = "test.suite.name"
    /**
    /// The status of the test suite run..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case testSuiteRunStatus = "test.suite.run.status"
    /**
    /// Current "managed" thread ID (as opposed to OS thread ID)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case threadId = "thread.id"
    /**
    /// Current thread name..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case threadName = "thread.name"
    /**
    /// String indicating the [cipher](https://datatracker.ietf.org/doc/html/rfc5246#appendix-A.5) used during the current connection..

    ~~~
    // Examples

    ~~~

    - Note: /// The values allowed for `tls.cipher` MUST be one of the `Descriptions` of the [registered TLS Cipher Suits](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#table-tls-parameters-4)..
    - Requires: Value type should be ``
    */
    case tlsCipher = "tls.cipher"
    /**
    /// PEM-encoded stand-alone certificate offered by the client. This is usually mutually-exclusive of `client.certificate_chain` since this value also exists in that list..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientCertificate = "tls.client.certificate"
    /**
    /// Array of PEM-encoded certificates that make up the certificate chain offered by the client. This is usually mutually-exclusive of `client.certificate` since that value should be the first certificate in the chain..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientCertificateChain = "tls.client.certificate_chain"
    /**
    /// Certificate fingerprint using the MD5 digest of DER-encoded version of certificate offered by the client. For consistency with other hash values, this value should be formatted as an uppercase hash..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientHashMd5 = "tls.client.hash.md5"
    /**
    /// Certificate fingerprint using the SHA1 digest of DER-encoded version of certificate offered by the client. For consistency with other hash values, this value should be formatted as an uppercase hash..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientHashSha1 = "tls.client.hash.sha1"
    /**
    /// Certificate fingerprint using the SHA256 digest of DER-encoded version of certificate offered by the client. For consistency with other hash values, this value should be formatted as an uppercase hash..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientHashSha256 = "tls.client.hash.sha256"
    /**
    /// Distinguished name of [subject](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6) of the issuer of the x.509 certificate presented by the client..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientIssuer = "tls.client.issuer"
    /**
    /// A hash that identifies clients based on how they perform an SSL/TLS handshake..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientJa3 = "tls.client.ja3"
    /**
    /// Date/Time indicating when client certificate is no longer considered valid..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientNotAfter = "tls.client.not_after"
    /**
    /// Date/Time indicating when client certificate is first considered valid..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientNotBefore = "tls.client.not_before"
    /**
    /// Distinguished name of subject of the x.509 certificate presented by the client..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientSubject = "tls.client.subject"
    /**
    /// Array of ciphers offered by the client during the client hello..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsClientSupportedCiphers = "tls.client.supported_ciphers"
    /**
    /// String indicating the curve used for the given cipher, when applicable.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsCurve = "tls.curve"
    /**
    /// Boolean flag indicating if the TLS negotiation was successful and transitioned to an encrypted tunnel..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsEstablished = "tls.established"
    /**
    /// String indicating the protocol being tunneled. Per the values in the [IANA registry](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids), this string should be lower case..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsNextProtocol = "tls.next_protocol"
    /**
    /// Normalized lowercase protocol name parsed from original string of the negotiated [SSL/TLS protocol version](https://docs.openssl.org/1.1.1/man3/SSL_get_version/#return-values).
    - Requires: Value type should be ``
    */
    case tlsProtocolName = "tls.protocol.name"
    /**
    /// Numeric part of the version parsed from the original string of the negotiated [SSL/TLS protocol version](https://docs.openssl.org/1.1.1/man3/SSL_get_version/#return-values).

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsProtocolVersion = "tls.protocol.version"
    /**
    /// Boolean flag indicating if this TLS connection was resumed from an existing TLS negotiation..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsResumed = "tls.resumed"
    /**
    /// PEM-encoded stand-alone certificate offered by the server. This is usually mutually-exclusive of `server.certificate_chain` since this value also exists in that list..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerCertificate = "tls.server.certificate"
    /**
    /// Array of PEM-encoded certificates that make up the certificate chain offered by the server. This is usually mutually-exclusive of `server.certificate` since that value should be the first certificate in the chain..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerCertificateChain = "tls.server.certificate_chain"
    /**
    /// Certificate fingerprint using the MD5 digest of DER-encoded version of certificate offered by the server. For consistency with other hash values, this value should be formatted as an uppercase hash..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerHashMd5 = "tls.server.hash.md5"
    /**
    /// Certificate fingerprint using the SHA1 digest of DER-encoded version of certificate offered by the server. For consistency with other hash values, this value should be formatted as an uppercase hash..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerHashSha1 = "tls.server.hash.sha1"
    /**
    /// Certificate fingerprint using the SHA256 digest of DER-encoded version of certificate offered by the server. For consistency with other hash values, this value should be formatted as an uppercase hash..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerHashSha256 = "tls.server.hash.sha256"
    /**
    /// Distinguished name of [subject](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6) of the issuer of the x.509 certificate presented by the client..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerIssuer = "tls.server.issuer"
    /**
    /// A hash that identifies servers based on how they perform an SSL/TLS handshake..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerJa3s = "tls.server.ja3s"
    /**
    /// Date/Time indicating when server certificate is no longer considered valid..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerNotAfter = "tls.server.not_after"
    /**
    /// Date/Time indicating when server certificate is first considered valid..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerNotBefore = "tls.server.not_before"
    /**
    /// Distinguished name of subject of the x.509 certificate presented by the server..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case tlsServerSubject = "tls.server.subject"
    /**
    /// Domain extracted from the `url.full`, such as "opentelemetry.io"..

    ~~~
    // Examples

    ~~~

    - Note: /// In some cases a URL may refer to an IP and/or port directly, without a domain name. In this case, the IP address would go to the domain field. If the URL contains a [literal IPv6 address](https://www.rfc-editor.org/rfc/rfc2732#section-2) enclosed by `[` and `]`, the `[` and `]` characters should also be captured in the domain field..
    - Requires: Value type should be ``
    */
    case urlDomain = "url.domain"
    /**
    /// The file extension extracted from the `url.full`, excluding the leading dot..

    ~~~
    // Examples

    ~~~

    - Note: /// The file extension is only set if it exists, as not every url has a file extension. When the file name has multiple extensions `example.tar.gz`, only the last one should be captured `gz`, not `tar.gz`..
    - Requires: Value type should be ``
    */
    case urlExtension = "url.extension"
    /**
    /// The [URI fragment](https://www.rfc-editor.org/rfc/rfc3986#section-3.5) component.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case urlFragment = "url.fragment"
    /**
    /// Absolute URL describing a network resource according to [RFC3986](https://www.rfc-editor.org/rfc/rfc3986).

    ~~~
    // Examples

    ~~~

    - Note: /// For network calls, URL usually has `scheme://host[:port][path][?query][#fragment]` format, where the fragment
      /// is not transmitted over HTTP, but if it is known, it SHOULD be included nevertheless.
      ///
      /// `url.full` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`.
      /// In such case username and password SHOULD be redacted and attribute's value SHOULD be `https://REDACTED:REDACTED@www.example.com/`.
      ///
      /// `url.full` SHOULD capture the absolute URL when it is available (or can be reconstructed).
      ///
      /// Sensitive content provided in `url.full` SHOULD be scrubbed when instrumentations can identify it.
      ///
      ///
      /// Query string values for the following keys SHOULD be redacted by default and replaced by the
      /// value `REDACTED`:
      ///
      /// - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      /// - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      /// - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)
      /// - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)
      ///
      /// This list is subject to change over time.
      ///
      /// When a query string value is redacted, the query string key SHOULD still be preserved, e.g.
      /// `https://www.example.com/path?color=blue&sig=REDACTED`..
    - Requires: Value type should be ``
    */
    case urlFull = "url.full"
    /**
    /// Unmodified original URL as seen in the event source..

    ~~~
    // Examples

    ~~~

    - Note: /// In network monitoring, the observed URL may be a full URL, whereas in access logs, the URL is often just represented as a path. This field is meant to represent the URL as it was observed, complete or not.
      /// `url.original` might contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case password and username SHOULD NOT be redacted and attribute's value SHOULD remain the same..
    - Requires: Value type should be ``
    */
    case urlOriginal = "url.original"
    /**
    /// The [URI path](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) component.

    ~~~
    // Examples

    ~~~

    - Note: /// Sensitive content provided in `url.path` SHOULD be scrubbed when instrumentations can identify it..
    - Requires: Value type should be ``
    */
    case urlPath = "url.path"
    /**
    /// Port extracted from the `url.full`.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case urlPort = "url.port"
    /**
    /// The [URI query](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) component.

    ~~~
    // Examples

    ~~~

    - Note: /// Sensitive content provided in `url.query` SHOULD be scrubbed when instrumentations can identify it.
      ///
      ///
      /// Query string values for the following keys SHOULD be redacted by default and replaced by the value `REDACTED`:
      ///
      /// - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      /// - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      /// - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)
      /// - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)
      ///
      /// This list is subject to change over time.
      ///
      /// When a query string value is redacted, the query string key SHOULD still be preserved, e.g.
      /// `q=OpenTelemetry&sig=REDACTED`..
    - Requires: Value type should be ``
    */
    case urlQuery = "url.query"
    /**
    /// The highest registered url domain, stripped of the subdomain..

    ~~~
    // Examples

    ~~~

    - Note: /// This value can be determined precisely with the [public suffix list](https://publicsuffix.org/). For example, the registered domain for `foo.example.com` is `example.com`. Trying to approximate this by simply taking the last two labels will not work well for TLDs such as `co.uk`..
    - Requires: Value type should be ``
    */
    case urlRegisteredDomain = "url.registered_domain"
    /**
    /// The [URI scheme](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) component identifying the used protocol..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case urlScheme = "url.scheme"
    /**
    /// The subdomain portion of a fully qualified domain name includes all of the names except the host name under the registered_domain. In a partially qualified domain, or if the qualification level of the full name cannot be determined, subdomain contains all of the names below the registered domain..

    ~~~
    // Examples

    ~~~

    - Note: /// The subdomain portion of `www.east.mydomain.co.uk` is `east`. If the domain has multiple levels of subdomain, such as `sub2.sub1.example.com`, the subdomain field should contain `sub2.sub1`, with no trailing period..
    - Requires: Value type should be ``
    */
    case urlSubdomain = "url.subdomain"
    /**
    /// The low-cardinality template of an [absolute path reference](https://www.rfc-editor.org/rfc/rfc3986#section-4.2)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case urlTemplate = "url.template"
    /**
    /// The effective top level domain (eTLD), also known as the domain suffix, is the last part of the domain name. For example, the top level domain for example.com is `com`..

    ~~~
    // Examples

    ~~~

    - Note: /// This value can be determined precisely with the [public suffix list](https://publicsuffix.org/)..
    - Requires: Value type should be ``
    */
    case urlTopLevelDomain = "url.top_level_domain"
    /**
    /// User email address..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case userEmail = "user.email"
    /**
    /// User's full name.

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case userFullName = "user.full_name"
    /**
    /// Unique user hash to correlate information for a user in anonymized form..

    ~~~
    // Examples

    ~~~

    - Note: /// Useful if `user.id` or `user.name` contain confidential information and cannot be used..
    - Requires: Value type should be ``
    */
    case userHash = "user.hash"
    /**
    /// Unique identifier of the user..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case userId = "user.id"
    /**
    /// Short name or login/username of the user..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case userName = "user.name"
    /**
    /// Array of user roles at the time of the event..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case userRoles = "user.roles"
    /**
    /// Name of the user-agent extracted from original. Usually refers to the browser's name..

    ~~~
    // Examples

    ~~~

    - Note: /// [Example](https://www.whatsmyua.info) of extracting browser's name from original string. In the case of using a user-agent for non-browser products, such as microservices with multiple names/versions inside the `user_agent.original`, the most significant name SHOULD be selected. In such a scenario it should align with `user_agent.version`.
    - Requires: Value type should be ``
    */
    case userAgentName = "user_agent.name"
    /**
    /// Value of the [HTTP User-Agent](https://www.rfc-editor.org/rfc/rfc9110.html#field.user-agent) header sent by the client..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case userAgentOriginal = "user_agent.original"
    /**
    /// Human readable operating system name..

    ~~~
    // Examples

    ~~~

    - Note: /// For mapping user agent strings to OS names, libraries such as [ua-parser](https://github.com/ua-parser) can be utilized..
    - Requires: Value type should be ``
    */
    case userAgentOsName = "user_agent.os.name"
    /**
    /// The version string of the operating system as defined in [Version Attributes](/docs/resource/README.md#version-attributes)..

    ~~~
    // Examples

    ~~~

    - Note: /// For mapping user agent strings to OS versions, libraries such as [ua-parser](https://github.com/ua-parser) can be utilized..
    - Requires: Value type should be ``
    */
    case userAgentOsVersion = "user_agent.os.version"
    /**
    /// Specifies the category of synthetic traffic, such as tests or bots..

    - Note: /// This attribute MAY be derived from the contents of the `user_agent.original` attribute. Components that populate the attribute are responsible for determining what they consider to be synthetic bot or test traffic. This attribute can either be set for self-identification purposes, or on telemetry detected to be generated as a result of a synthetic request. This attribute is useful for distinguishing between genuine client traffic and synthetic traffic generated by bots or tests..
    - Requires: Value type should be ``
    */
    case userAgentSyntheticType = "user_agent.synthetic.type"
    /**
    /// Version of the user-agent extracted from original. Usually refers to the browser's version.

    ~~~
    // Examples

    ~~~

    - Note: /// [Example](https://www.whatsmyua.info) of extracting browser's version from original string. In the case of using a user-agent for non-browser products, such as microservices with multiple names/versions inside the `user_agent.original`, the most significant version SHOULD be selected. In such a scenario it should align with `user_agent.name`.
    - Requires: Value type should be ``
    */
    case userAgentVersion = "user_agent.version"
    /**
    /// The type of garbage collection..
    - Requires: Value type should be ``
    */
    case v8jsGcType = "v8js.gc.type"
    /**
    /// The name of the space type of heap memory..

    - Note: /// Value can be retrieved from value `space_name` of [`v8.getHeapSpaceStatistics()`](https://nodejs.org/api/v8.html#v8getheapspacestatistics).
    - Requires: Value type should be ``
    */
    case v8jsHeapSpaceName = "v8js.heap.space.name"
    /**
    /// The ID of the change (pull request/merge request/changelist) if applicable. This is usually a unique (within repository) identifier generated by the VCS system..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsChangeId = "vcs.change.id"
    /**
    /// The state of the change (pull request/merge request/changelist)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsChangeState = "vcs.change.state"
    /**
    /// The human readable title of the change (pull request/merge request/changelist). This title is often a brief summary of the change and may get merged in to a ref as the commit summary..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsChangeTitle = "vcs.change.title"
    /**
    /// The type of line change being measured on a branch or change..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsLineChangeType = "vcs.line_change.type"
    /**
    /// The group owner within the version control system..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsOwnerName = "vcs.owner.name"
    /**
    /// The name of the version control system provider..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsProviderName = "vcs.provider.name"
    /**
    /// The name of the [reference](https://git-scm.com/docs/gitglossary#def_ref) such as **branch** or **tag** in the repository..

    ~~~
    // Examples

    ~~~

    - Note: /// `base` refers to the starting point of a change. For example, `main`
      /// would be the base reference of type branch if you've created a new
      /// reference of type branch from it and created new commits..
    - Requires: Value type should be ``
    */
    case vcsRefBaseName = "vcs.ref.base.name"
    /**
    /// The revision, literally [revised version](https://www.merriam-webster.com/dictionary/revision), The revision most often refers to a commit object in Git, or a revision number in SVN..

    ~~~
    // Examples

    ~~~

    - Note: /// `base` refers to the starting point of a change. For example, `main`
      /// would be the base reference of type branch if you've created a new
      /// reference of type branch from it and created new commits. The
      /// revision can be a full [hash value (see
      /// glossary)](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf),
      /// of the recorded change to a ref within a repository pointing to a
      /// commit [commit](https://git-scm.com/docs/git-commit) object. It does
      /// not necessarily have to be a hash; it can simply define a [revision
      /// number](https://svnbook.red-bean.com/en/1.7/svn.tour.revs.specifiers.html)
      /// which is an integer that is monotonically increasing. In cases where
      /// it is identical to the `ref.base.name`, it SHOULD still be included.
      /// It is up to the implementer to decide which value to set as the
      /// revision based on the VCS system and situational context..
    - Requires: Value type should be ``
    */
    case vcsRefBaseRevision = "vcs.ref.base.revision"
    /**
    /// The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository..

    ~~~
    // Examples

    ~~~

    - Note: /// `base` refers to the starting point of a change. For example, `main`
      /// would be the base reference of type branch if you've created a new
      /// reference of type branch from it and created new commits..
    - Requires: Value type should be ``
    */
    case vcsRefBaseType = "vcs.ref.base.type"
    /**
    /// The name of the [reference](https://git-scm.com/docs/gitglossary#def_ref) such as **branch** or **tag** in the repository..

    ~~~
    // Examples

    ~~~

    - Note: /// `head` refers to where you are right now; the current reference at a
      /// given time..
    - Requires: Value type should be ``
    */
    case vcsRefHeadName = "vcs.ref.head.name"
    /**
    /// The revision, literally [revised version](https://www.merriam-webster.com/dictionary/revision), The revision most often refers to a commit object in Git, or a revision number in SVN..

    ~~~
    // Examples

    ~~~

    - Note: /// `head` refers to where you are right now; the current reference at a
      /// given time.The revision can be a full [hash value (see
      /// glossary)](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf),
      /// of the recorded change to a ref within a repository pointing to a
      /// commit [commit](https://git-scm.com/docs/git-commit) object. It does
      /// not necessarily have to be a hash; it can simply define a [revision
      /// number](https://svnbook.red-bean.com/en/1.7/svn.tour.revs.specifiers.html)
      /// which is an integer that is monotonically increasing. In cases where
      /// it is identical to the `ref.head.name`, it SHOULD still be included.
      /// It is up to the implementer to decide which value to set as the
      /// revision based on the VCS system and situational context..
    - Requires: Value type should be ``
    */
    case vcsRefHeadRevision = "vcs.ref.head.revision"
    /**
    /// The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository..

    ~~~
    // Examples

    ~~~

    - Note: /// `head` refers to where you are right now; the current reference at a
      /// given time..
    - Requires: Value type should be ``
    */
    case vcsRefHeadType = "vcs.ref.head.type"
    /**
    /// The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsRefType = "vcs.ref.type"
    /**
    /// The human readable name of the repository. It SHOULD NOT include any additional identifier like Group/SubGroup in GitLab or organization in GitHub..

    ~~~
    // Examples

    ~~~

    - Note: /// Due to it only being the name, it can clash with forks of the same
      /// repository if collecting telemetry across multiple orgs or groups in
      /// the same backends..
    - Requires: Value type should be ``
    */
    case vcsRepositoryName = "vcs.repository.name"
    /**
    /// The [canonical URL](https://support.google.com/webmasters/answer/10347851?hl=en#:~:text=A%20canonical%20URL%20is%20the,Google%20chooses%20one%20as%20canonical.) of the repository providing the complete HTTP(S) address in order to locate and identify the repository through a browser..

    ~~~
    // Examples

    ~~~

    - Note: /// In Git Version Control Systems, the canonical URL SHOULD NOT include
      /// the `.git` extension..
    - Requires: Value type should be ``
    */
    case vcsRepositoryUrlFull = "vcs.repository.url.full"
    /**
    /// The type of revision comparison..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case vcsRevisionDeltaDirection = "vcs.revision_delta.direction"
    /**
    /// Additional description of the web engine (e.g. detailed version and edition information)..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case webengineDescription = "webengine.description"
    /**
    /// The name of the web engine..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case webengineName = "webengine.name"
    /**
    /// The version of the web engine..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case webengineVersion = "webengine.version"
    /**
    /// The System Management Facility (SMF) Identifier uniquely identified a z/OS system within a SYSPLEX or mainframe environment and is used for system and performance analysis..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case zosSmfId = "zos.smf.id"
    /**
    /// The name of the SYSPLEX to which the z/OS system belongs too..

    ~~~
    // Examples

    ~~~
    - Requires: Value type should be ``
    */
    case zosSysplexName = "zos.sysplex.name"

    // MARK: - Manual Definitions
    // Some definitions have not yet been added to the YAML which generates this script.
    // As such as we have some manually defined cases.

    /**
    An exception event **MUST** be called "exception" as per the [specification](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/exceptions.md).
    */
    case exception = "exception";
}