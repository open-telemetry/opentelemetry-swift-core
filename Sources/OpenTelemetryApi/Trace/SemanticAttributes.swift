/*
* Copyright The OpenTelemetry Authors
* SPDX-License-Identifier: Apache-2.0
*/

// DO **NOT** EDIT. This file is automatically generated.import Foundation

public enum SemanticAttributes: String {

  /**
    Unique identifier for a particular build or compilation of the application..
    ~~~
    // Examples
      attributes[.AppBuildId] = "6cff0a7e-cefc-4668-96f5-1273d8b334d0"
      attributes[.AppBuildId] = "9f2b833506aa6973a92fde9733e6271f"
      attributes[.AppBuildId] = "my-app-1.0.0-code-123"
    ~~~
    - Requires: Value type should be `String`
  */
  case appBuildId = "app.build_id"

  /**
    A unique identifier representing the installation of an application on a specific device.
    ~~~
    // Examples
      attributes[.AppInstallationId] = "2ab2916d-a51f-4ac8-80ee-45ac31a28092"
    ~~~
    - Note: Its value SHOULD persist across launches of the same application installation, including through application upgrades.
      It SHOULD change if the application is uninstalled or if all applications of the vendor are uninstalled.
      Additionally, users might be able to reset this value (e.g. by clearing application data).
      If an app is installed multiple times on the same device (e.g. in different accounts on Android), each `app.installation.id` SHOULD have a different value.
      If multiple OpenTelemetry SDKs are used within the same application, they SHOULD use the same value for `app.installation.id`.
      Hardware IDs (e.g. serial number, IMEI, MAC address) MUST NOT be used as the `app.installation.id`.

      For iOS, this value SHOULD be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/identifierforvendor).

      For Android, examples of `app.installation.id` implementations include:

      - [Firebase Installation ID](https://firebase.google.com/docs/projects/manage-installations).
      - A globally unique UUID which is persisted across sessions in your application.
      - [App set ID](https://developer.android.com/identity/app-set-id).
      - [`Settings.getString(Settings.Secure.ANDROID_ID)`](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).

      More information about Android identifier best practices can be found in the [Android user data IDs guide](https://developer.android.com/training/articles/user-data-ids).
    - Requires: Value type should be `String`
  */
  case appInstallationId = "app.installation.id"

  /**
    A number of frame renders that experienced jank..
    ~~~
    // Examples
      attributes[.AppJankFrameCount] = 9
      attributes[.AppJankFrameCount] = 42
    ~~~
    - Note: Depending on platform limitations, the value provided MAY be approximation.
    - Requires: Value type should be `Int`
  */
  case appJankFrameCount = "app.jank.frame_count"

  /**
    The time period, in seconds, for which this jank is being reported..
    ~~~
    // Examples
      attributes[.AppJankPeriod] = 1.0
      attributes[.AppJankPeriod] = 5.0
      attributes[.AppJankPeriod] = 10.24
    ~~~
    - Requires: Value type should be `double`
  */
  case appJankPeriod = "app.jank.period"

  /**
    The minimum rendering threshold for this jank, in seconds..
    ~~~
    // Examples
      attributes[.AppJankThreshold] = 0.016
      attributes[.AppJankThreshold] = 0.7
      attributes[.AppJankThreshold] = 1.024
    ~~~
    - Requires: Value type should be `double`
  */
  case appJankThreshold = "app.jank.threshold"

  /**
    The x (horizontal) coordinate of a screen coordinate, in screen pixels..
    ~~~
    // Examples
      attributes[.AppScreenCoordinateX] = 0
      attributes[.AppScreenCoordinateX] = 131
    ~~~
    - Requires: Value type should be `Int`
  */
  case appScreenCoordinateX = "app.screen.coordinate.x"

  /**
    The y (vertical) component of a screen coordinate, in screen pixels..
    ~~~
    // Examples
      attributes[.AppScreenCoordinateY] = 12
      attributes[.AppScreenCoordinateY] = 99
    ~~~
    - Requires: Value type should be `Int`
  */
  case appScreenCoordinateY = "app.screen.coordinate.y"

  /**
    An identifier that uniquely differentiates this widget from other widgets in the same application..
    ~~~
    // Examples
      attributes[.AppWidgetId] = "f9bc787d-ff05-48ad-90e1-fca1d46130b3"
      attributes[.AppWidgetId] = "submit_order_1829"
    ~~~
    - Note: A widget is an application component, typically an on-screen visual GUI element.
    - Requires: Value type should be `String`
  */
  case appWidgetId = "app.widget.id"

  /**
    The name of an application widget..
    ~~~
    // Examples
      attributes[.AppWidgetName] = "submit"
      attributes[.AppWidgetName] = "attack"
      attributes[.AppWidgetName] = "Clear Cart"
    ~~~
    - Note: A widget is an application component, typically an on-screen visual GUI element.
    - Requires: Value type should be `String`
  */
  case appWidgetName = "app.widget.name"

  /**
    The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html)..
    - Requires: Value should be one of [`SemanticAttributes.CassandraConsistencyLevelValues`](x-source-tag://otelCassandraConsistencyLevelValues) (of type `String`)
  */
  case cassandraConsistencyLevel = "cassandra.consistency.level"

  /**
    The data center of the coordinating node for a query..
    ~~~
    // Examples
  
      attributes[.CassandraCoordinatorDc] = "us-west-2"
    ~~~
    - Requires: Value type should be `String`
  */
  case cassandraCoordinatorDc = "cassandra.coordinator.dc"

  /**
    The ID of the coordinating node for a query..
    ~~~
    // Examples
  
      attributes[.CassandraCoordinatorId] = "be13faa2-8574-4d71-926d-27f16cf8a7af"
    ~~~
    - Requires: Value type should be `String`
  */
  case cassandraCoordinatorId = "cassandra.coordinator.id"

  /**
    The fetch size used for paging, i.e. how many rows will be returned at once..
    ~~~
    // Examples
      attributes[.CassandraPageSize] = 5000
    ~~~
    - Requires: Value type should be `Int`
  */
  case cassandraPageSize = "cassandra.page.size"

  /**
    Whether or not the query is idempotent..
    - Requires: Value type should be `Bool`
  */
  case cassandraQueryIdempotent = "cassandra.query.idempotent"

  /**
    The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively..
    ~~~
    // Examples
      attributes[.CassandraSpeculativeExecutionCount] = 0
      attributes[.CassandraSpeculativeExecutionCount] = 2
    ~~~
    - Requires: Value type should be `Int`
  */
  case cassandraSpeculativeExecutionCount = "cassandra.speculative_execution.count"

  /**
    Client address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..
    ~~~
    // Examples
      attributes[.ClientAddress] = "client.example.com"
      attributes[.ClientAddress] = "10.1.2.80"
      attributes[.ClientAddress] = "/tmp/my.sock"
    ~~~
    - Note: When observed from the server side, and when communicating through an intermediary, `client.address` SHOULD represent the client address behind any intermediaries,  for example proxies, if it's available.
    - Requires: Value type should be `String`
  */
  case clientAddress = "client.address"

  /**
    Client port number..
    ~~~
    // Examples
      attributes[.ClientPort] = 65123
    ~~~
    - Note: When observed from the server side, and when communicating through an intermediary, `client.port` SHOULD represent the client port behind any intermediaries,  for example proxies, if it's available.
    - Requires: Value type should be `Int`
  */
  case clientPort = "client.port"

  /**
    The column number in `code.file.path` best representing the operation. It SHOULD point within the code unit named in `code.function.name`. This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Line'. This constraint is imposed to prevent redundancy and maintain data integrity..
    ~~~
    // Examples
  
      attributes[.CodeColumnNumber] = 16
    ~~~
    - Requires: Value type should be `Int`
  */
  case codeColumnNumber = "code.column.number"

  /**
    The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path). This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Function'. This constraint is imposed to prevent redundancy and maintain data integrity..
    ~~~
    // Examples
  
      attributes[.CodeFilePath] = "/usr/local/MyApplication/content_root/app/index.php"
    ~~~
    - Requires: Value type should be `String`
  */
  case codeFilePath = "code.file.path"

  /**
    The method or function fully-qualified name without arguments. The value should fit the natural representation of the language runtime, which is also likely the same used within `code.stacktrace` attribute value. This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Function'. This constraint is imposed to prevent redundancy and maintain data integrity..
    ~~~
    // Examples
      attributes[.CodeFunctionName] = "com.example.MyHttpService.serveRequest"
      attributes[.CodeFunctionName] = "GuzzleHttp\Client::transfer"
      attributes[.CodeFunctionName] = "fopen"
    ~~~
    - Note: Values and format depends on each language runtime, thus it is impossible to provide an exhaustive list of examples.
      The values are usually the same (or prefixes of) the ones found in native stack trace representation stored in
      `code.stacktrace` without information on arguments.

      Examples:

      - Java method: `com.example.MyHttpService.serveRequest`
      - Java anonymous class method: `com.mycompany.Main$1.myMethod`
      - Java lambda method: `com.mycompany.Main$$Lambda/0x0000748ae4149c00.myMethod`
      - PHP function: `GuzzleHttp\Client::transfer`
      - Go function: `github.com/my/repo/pkg.foo.func5`
      - Elixir: `OpenTelemetry.Ctx.new`
      - Erlang: `opentelemetry_ctx:new`
      - Rust: `playground::my_module::my_cool_func`
      - C function: `fopen`
    - Requires: Value type should be `String`
  */
  case codeFunctionName = "code.function.name"

  /**
    The line number in `code.file.path` best representing the operation. It SHOULD point within the code unit named in `code.function.name`. This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Line'. This constraint is imposed to prevent redundancy and maintain data integrity..
    ~~~
    // Examples
  
      attributes[.CodeLineNumber] = 42
    ~~~
    - Requires: Value type should be `Int`
  */
  case codeLineNumber = "code.line.number"

  /**
    A stacktrace as a string in the natural representation for the language runtime. The representation is identical to [`exception.stacktrace`](/docs/exceptions/exceptions-spans.md#stacktrace-representation). This attribute MUST NOT be used on the Profile signal since the data is already captured in 'message Location'. This constraint is imposed to prevent redundancy and maintain data integrity..
    ~~~
    // Examples
  
      attributes[.CodeStacktrace] = "at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\n at com.example.GenerateTrace.main(GenerateTrace.java:5)
      "
    ~~~
    - Requires: Value type should be `String`
  */
  case codeStacktrace = "code.stacktrace"

  /**
    The logical CPU number [0..n-1].
    ~~~
    // Examples
      attributes[.CpuLogicalNumber] = 1
    ~~~
    - Requires: Value type should be `Int`
  */
  case cpuLogicalNumber = "cpu.logical_number"

  /**
    The mode of the CPU.
    ~~~
    // Examples
      attributes[.CpuMode] = user
      attributes[.CpuMode] = system
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.CpuModeValues`](x-source-tag://otelCpuModeValues) (of type `String`)
  */
  case cpuMode = "cpu.mode"

  /**
    Value of the garbage collector collection generation..
    ~~~
    // Examples
      attributes[.CpythonGcGeneration] = 0
      attributes[.CpythonGcGeneration] = 1
      attributes[.CpythonGcGeneration] = 2
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.CpythonGcGenerationValues`](x-source-tag://otelCpythonGcGenerationValues) (of type `Int`)
  */
  case cpythonGcGeneration = "cpython.gc.generation"

  /**
    The name of the connection pool; unique within the instrumented application. In case the connection pool implementation doesn't provide a name, instrumentation SHOULD use a combination of parameters that would make the name unique, for example, combining attributes `server.address`, `server.port`, and `db.namespace`, formatted as `server.address:server.port/db.namespace`. Instrumentations that generate connection pool name following different patterns SHOULD document it..
    ~~~
    // Examples
      attributes[.DbClientConnectionPoolName] = "myDataSource"
    ~~~
    - Requires: Value type should be `String`
  */
  case dbClientConnectionPoolName = "db.client.connection.pool.name"

  /**
    The state of a connection in the pool.
    ~~~
    // Examples
      attributes[.DbClientConnectionState] = idle
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.DbClientConnectionStateValues`](x-source-tag://otelDbClientConnectionStateValues) (of type `String`)
  */
  case dbClientConnectionState = "db.client.connection.state"

  /**
    The name of a collection (table, container) within the database..
    ~~~
    // Examples
      attributes[.DbCollectionName] = "public.users"
      attributes[.DbCollectionName] = "customers"
    ~~~
    - Note: It is RECOMMENDED to capture the value as provided by the application
      without attempting to do any case normalization.

      The collection name SHOULD NOT be extracted from `db.query.text`,
      when the database system supports query text with multiple collections
      in non-batch operations.

      For batch operations, if the individual operations are known to have the same
      collection name then that collection name SHOULD be used.
    - Requires: Value type should be `String`
  */
  case dbCollectionName = "db.collection.name"

  /**
    The name of the database, fully qualified within the server address and port..
    ~~~
    // Examples
      attributes[.DbNamespace] = "customers"
      attributes[.DbNamespace] = "test.users"
    ~~~
    - Note: If a database system has multiple namespace components, they SHOULD be concatenated from the most general to the most specific namespace component, using `|` as a separator between the components. Any missing components (and their associated separators) SHOULD be omitted.
      Semantic conventions for individual database systems SHOULD document what `db.namespace` means in the context of that system.
      It is RECOMMENDED to capture the value as provided by the application without attempting to do any case normalization.
    - Requires: Value type should be `String`
  */
  case dbNamespace = "db.namespace"

  /**
    The number of queries included in a batch operation..
    ~~~
    // Examples
      attributes[.DbOperationBatchSize] = 2
      attributes[.DbOperationBatchSize] = 3
      attributes[.DbOperationBatchSize] = 4
    ~~~
    - Note: Operations are only considered batches when they contain two or more operations, and so `db.operation.batch.size` SHOULD never be `1`.
    - Requires: Value type should be `Int`
  */
  case dbOperationBatchSize = "db.operation.batch.size"

  /**
    The name of the operation or command being executed..
    ~~~
    // Examples
      attributes[.DbOperationName] = "findAndModify"
      attributes[.DbOperationName] = "HMSET"
      attributes[.DbOperationName] = "SELECT"
    ~~~
    - Note: It is RECOMMENDED to capture the value as provided by the application
      without attempting to do any case normalization.

      The operation name SHOULD NOT be extracted from `db.query.text`,
      when the database system supports query text with multiple operations
      in non-batch operations.

      If spaces can occur in the operation name, multiple consecutive spaces
      SHOULD be normalized to a single space.

      For batch operations, if the individual operations are known to have the same operation name
      then that operation name SHOULD be used prepended by `BATCH `,
      otherwise `db.operation.name` SHOULD be `BATCH` or some other database
      system specific term if more applicable.
    - Requires: Value type should be `String`
  */
  case dbOperationName = "db.operation.name"

  /**
    A database operation parameter, with `<key>` being the parameter name, and the attribute value being a string representation of the parameter value..
    ~~~
    // Examples
      attributes[.DbOperationParameter] = "someval"
      attributes[.DbOperationParameter] = "55"
    ~~~
    - Note: For example, a client-side maximum number of rows to read from the database
      MAY be recorded as the `db.operation.parameter.max_rows` attribute.

      `db.query.text` parameters SHOULD be captured using `db.query.parameter.<key>`
      instead of `db.operation.parameter.<key>`.
    - Requires: Value type should be `template[string]`
  */
  case dbOperationParameter = "db.operation.parameter"

  /**
    A database query parameter, with `<key>` being the parameter name, and the attribute value being a string representation of the parameter value..
    ~~~
    // Examples
      attributes[.DbQueryParameter] = "someval"
      attributes[.DbQueryParameter] = "55"
    ~~~
    - Note: If a query parameter has no name and instead is referenced only by index,
      then `<key>` SHOULD be the 0-based index.

      `db.query.parameter.<key>` SHOULD match
      up with the parameterized placeholders present in `db.query.text`.

      `db.query.parameter.<key>` SHOULD NOT be captured on batch operations.

      Examples:

      - For a query `SELECT * FROM users where username =  %s` with the parameter `"jdoe"`,
        the attribute `db.query.parameter.0` SHOULD be set to `"jdoe"`.
      - For a query `"SELECT * FROM users WHERE username = %(username)s;` with parameter
        `username = "jdoe"`, the attribute `db.query.parameter.username` SHOULD be set to `"jdoe"`.
    - Requires: Value type should be `template[string]`
  */
  case dbQueryParameter = "db.query.parameter"

  /**
    Low cardinality summary of a database query..
    ~~~
    // Examples
      attributes[.DbQuerySummary] = "SELECT wuser_table"
      attributes[.DbQuerySummary] = "INSERT shipping_details SELECT orders"
      attributes[.DbQuerySummary] = "get user by id"
    ~~~
    - Note: The query summary describes a class of database queries and is useful
      as a grouping key, especially when analyzing telemetry for database
      calls involving complex queries.

      Summary may be available to the instrumentation through
      instrumentation hooks or other means. If it is not available, instrumentations
      that support query parsing SHOULD generate a summary following
      [Generating query summary](/docs/database/database-spans.md#generating-a-summary-of-the-query)
      section.
    - Requires: Value type should be `String`
  */
  case dbQuerySummary = "db.query.summary"

  /**
    The database query being executed..
    ~~~
    // Examples
      attributes[.DbQueryText] = "SELECT * FROM wuser_table where username = ?"
      attributes[.DbQueryText] = "SET mykey ?"
    ~~~
    - Note: For sanitization see [Sanitization of `db.query.text`](/docs/database/database-spans.md#sanitization-of-dbquerytext).
      For batch operations, if the individual operations are known to have the same query text then that query text SHOULD be used, otherwise all of the individual query texts SHOULD be concatenated with separator `; ` or some other database system specific separator if more applicable.
      Parameterized query text SHOULD NOT be sanitized. Even though parameterized query text can potentially have sensitive data, by using a parameterized query the user is giving a strong signal that any sensitive data will be passed as parameter values, and the benefit to observability of capturing the static part of the query text by default outweighs the risk.
    - Requires: Value type should be `String`
  */
  case dbQueryText = "db.query.text"

  /**
    Number of rows returned by the operation..
    ~~~
    // Examples
      attributes[.DbResponseReturnedRows] = 10
      attributes[.DbResponseReturnedRows] = 30
      attributes[.DbResponseReturnedRows] = 1000
    ~~~
    - Requires: Value type should be `Int`
  */
  case dbResponseReturnedRows = "db.response.returned_rows"

  /**
    Database response status code..
    ~~~
    // Examples
      attributes[.DbResponseStatusCode] = "102"
      attributes[.DbResponseStatusCode] = "ORA-17002"
      attributes[.DbResponseStatusCode] = "08P01"
      attributes[.DbResponseStatusCode] = "404"
    ~~~
    - Note: The status code returned by the database. Usually it represents an error code, but may also represent partial success, warning, or differentiate between various types of successful outcomes.
      Semantic conventions for individual database systems SHOULD document what `db.response.status_code` means in the context of that system.
    - Requires: Value type should be `String`
  */
  case dbResponseStatusCode = "db.response.status_code"

  /**
    The name of a stored procedure within the database..
    ~~~
    // Examples
      attributes[.DbStoredProcedureName] = "GetCustomer"
    ~~~
    - Note: It is RECOMMENDED to capture the value as provided by the application
      without attempting to do any case normalization.

      For batch operations, if the individual operations are known to have the same
      stored procedure name then that stored procedure name SHOULD be used.
    - Requires: Value type should be `String`
  */
  case dbStoredProcedureName = "db.stored_procedure.name"

  /**
    The database management system (DBMS) product as identified by the client instrumentation..
    - Note: The actual DBMS may differ from the one identified by the client. For example, when using PostgreSQL client libraries to connect to a CockroachDB, the `db.system.name` is set to `postgresql` based on the instrumentation's best knowledge.
    - Requires: Value should be one of [`SemanticAttributes.DbSystemNameValues`](x-source-tag://otelDbSystemNameValues) (of type `String`)
  */
  case dbSystemName = "db.system.name"

  /**
    Destination address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..
    ~~~
    // Examples
      attributes[.DestinationAddress] = "destination.example.com"
      attributes[.DestinationAddress] = "10.1.2.80"
      attributes[.DestinationAddress] = "/tmp/my.sock"
    ~~~
    - Note: When observed from the source side, and when communicating through an intermediary, `destination.address` SHOULD represent the destination address behind any intermediaries, for example proxies, if it's available.
    - Requires: Value type should be `String`
  */
  case destinationAddress = "destination.address"

  /**
    Destination port number.
    ~~~
    // Examples
      attributes[.DestinationPort] = 3389
      attributes[.DestinationPort] = 2888
    ~~~
    - Requires: Value type should be `Int`
  */
  case destinationPort = "destination.port"

  /**
    A unique identifier representing the device.
    ~~~
    // Examples
      attributes[.DeviceId] = "123456789012345"
      attributes[.DeviceId] = "01:23:45:67:89:AB"
    ~~~
    - Note: Its value SHOULD be identical for all apps on a device and it SHOULD NOT change if an app is uninstalled and re-installed.
      However, it might be resettable by the user for all apps on a device.
      Hardware IDs (e.g. vendor-specific serial number, IMEI or MAC address) MAY be used as values.

      More information about Android identifier best practices can be found in the [Android user data IDs guide](https://developer.android.com/training/articles/user-data-ids).

      > [!WARNING]> This attribute may contain sensitive (PII) information. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply,
      > ensure you do your own due diligence.> Due to these reasons, this identifier is not recommended for consumer applications and will likely result in rejection from both Google Play and App Store.
      > However, it may be appropriate for specific enterprise scenarios, such as kiosk devices or enterprise-managed devices, with appropriate compliance clearance.
      > Any instrumentation providing this identifier MUST implement it as an opt-in feature.> See [`app.installation.id`](/docs/registry/attributes/app.md#app-installation-id)>  for a more privacy-preserving alternative.
    - Requires: Value type should be `String`
  */
  case deviceId = "device.id"

  /**
    The name of the device manufacturer.
    ~~~
    // Examples
      attributes[.DeviceManufacturer] = "Apple"
      attributes[.DeviceManufacturer] = "Samsung"
    ~~~
    - Note: The Android OS provides this field via [Build](https://developer.android.com/reference/android/os/Build#MANUFACTURER). iOS apps SHOULD hardcode the value `Apple`.
    - Requires: Value type should be `String`
  */
  case deviceManufacturer = "device.manufacturer"

  /**
    The model identifier for the device.
    ~~~
    // Examples
      attributes[.DeviceModelIdentifier] = "iPhone3,4"
      attributes[.DeviceModelIdentifier] = "SM-G920F"
    ~~~
    - Note: It's recommended this value represents a machine-readable version of the model identifier rather than the market or consumer-friendly name of the device.
    - Requires: Value type should be `String`
  */
  case deviceModelIdentifier = "device.model.identifier"

  /**
    The marketing name for the device model.
    ~~~
    // Examples
      attributes[.DeviceModelName] = "iPhone 6s Plus"
      attributes[.DeviceModelName] = "Samsung Galaxy S6"
    ~~~
    - Note: It's recommended this value represents a human-readable version of the device model rather than a machine-readable alternative.
    - Requires: Value type should be `String`
  */
  case deviceModelName = "device.model.name"

  /**
    The disk IO operation direction..
    ~~~
    // Examples
      attributes[.DiskIoDirection] = read
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.DiskIoDirectionValues`](x-source-tag://otelDiskIoDirectionValues) (of type `String`)
  */
  case diskIoDirection = "disk.io.direction"

  /**
    The list of IPv4 or IPv6 addresses resolved during DNS lookup..
    ~~~
    // Examples
      attributes[.DnsAnswers] = ["10.0.0.1", "2001:0db8:85a3:0000:0000:8a2e:0370:7334"]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case dnsAnswers = "dns.answers"

  /**
    The name being queried..
    ~~~
    // Examples
      attributes[.DnsQuestionName] = "www.example.com"
      attributes[.DnsQuestionName] = "opentelemetry.io"
    ~~~
    - Note: If the name field contains non-printable characters (below 32 or above 126), those characters should be represented as escaped base 10 integers (\DDD). Back slashes and quotes should be escaped. Tabs, carriage returns, and line feeds should be converted to \t, \r, and \n respectively.
    - Requires: Value type should be `String`
  */
  case dnsQuestionName = "dns.question.name"

  /**
    Represents the human-readable identifier of the node/instance to which a request was routed..
    ~~~
    // Examples
      attributes[.ElasticsearchNodeName] = "instance-0000000001"
    ~~~
    - Requires: Value type should be `String`
  */
  case elasticsearchNodeName = "elasticsearch.node.name"

  /**
    Unique identifier of an end user in the system. It maybe a username, email address, or other identifier..
    ~~~
    // Examples
      attributes[.EnduserId] = "username"
    ~~~
    - Note: Unique identifier of an end user in the system.

      > [!Warning]
      > This field contains sensitive (PII) information.
    - Requires: Value type should be `String`
  */
  case enduserId = "enduser.id"

  /**
    Pseudonymous identifier of an end user. This identifier should be a random value that is not directly linked or associated with the end user's actual identity..
    ~~~
    // Examples
      attributes[.EnduserPseudoId] = "QdH5CAWJgqVT4rOr0qtumf"
    ~~~
    - Note: Pseudonymous identifier of an end user.

      > [!Warning]
      > This field contains sensitive (linkable PII) information.
    - Requires: Value type should be `String`
  */
  case enduserPseudoId = "enduser.pseudo.id"

  /**
    A message providing more detail about an error in human-readable form..
    ~~~
    // Examples
      attributes[.ErrorMessage] = "Unexpected input type: string"
      attributes[.ErrorMessage] = "The user has exceeded their storage quota"
    ~~~
    - Note: `error.message` should provide additional context and detail about an error.
      It is NOT RECOMMENDED to duplicate the value of `error.type` in `error.message`.
      It is also NOT RECOMMENDED to duplicate the value of `exception.message` in `error.message`.

      `error.message` is NOT RECOMMENDED for metrics or spans due to its unbounded cardinality and overlap with span status.
    - Requires: Value type should be `String`
  */
  case errorMessage = "error.message"

  /**
    Describes a class of error the operation ended with..
    ~~~
    // Examples
      attributes[.ErrorType] = timeout
      attributes[.ErrorType] = java.net.UnknownHostException
      attributes[.ErrorType] = server_certificate_invalid
      attributes[.ErrorType] = 500
    ~~~
    - Note: The `error.type` SHOULD be predictable, and SHOULD have low cardinality.

      When `error.type` is set to a type (e.g., an exception type), its
      canonical class name identifying the type within the artifact SHOULD be used.

      Instrumentations SHOULD document the list of errors they report.

      The cardinality of `error.type` within one instrumentation library SHOULD be low.
      Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
      should be prepared for `error.type` to have high cardinality at query time when no
      additional filters are applied.

      If the operation has completed successfully, instrumentations SHOULD NOT set `error.type`.

      If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
      it's RECOMMENDED to:

      - Use a domain-specific attribute
      - Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.
    - Requires: Value should be one of [`SemanticAttributes.ErrorTypeValues`](x-source-tag://otelErrorTypeValues) (of type `String`)
  */
  case errorType = "error.type"

  /**
    The exception message..
    ~~~
    // Examples
      attributes[.ExceptionMessage] = "Division by zero"
      attributes[.ExceptionMessage] = "Can't convert 'int' object to str implicitly"
    ~~~
    - Requires: Value type should be `String`
  */
  case exceptionMessage = "exception.message"

  /**
    A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG..
    ~~~
    // Examples
  
      attributes[.ExceptionStacktrace] = "Exception in thread \"main\" java.lang.RuntimeException: Test exception\n at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\n at com.example.GenerateTrace.main(GenerateTrace.java:5)
      "
    ~~~
    - Requires: Value type should be `String`
  */
  case exceptionStacktrace = "exception.stacktrace"

  /**
    The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it..
    ~~~
    // Examples
      attributes[.ExceptionType] = "java.net.ConnectException"
      attributes[.ExceptionType] = "OSError"
    ~~~
    - Requires: Value type should be `String`
  */
  case exceptionType = "exception.type"

  /**
    Time when the file was last accessed, in ISO 8601 format..
    ~~~
    // Examples
      attributes[.FileAccessed] = "2021-01-01T12:00:00Z"
    ~~~
    - Note: This attribute might not be supported by some file systems — NFS, FAT32, in embedded OS, etc.
    - Requires: Value type should be `String`
  */
  case fileAccessed = "file.accessed"

  /**
    Array of file attributes..
    ~~~
    // Examples
      attributes[.FileAttributes] = ["readonly", "hidden"]
    ~~~
    - Note: Attributes names depend on the OS or file system. Here’s a non-exhaustive list of values expected for this attribute: `archive`, `compressed`, `directory`, `encrypted`, `execute`, `hidden`, `immutable`, `journaled`, `read`, `readonly`, `symbolic link`, `system`, `temporary`, `write`.
    - Requires: Value type should be `[String]`
  */
  case fileAttributes = "file.attributes"

  /**
    Time when the file attributes or metadata was last changed, in ISO 8601 format..
    ~~~
    // Examples
      attributes[.FileChanged] = "2021-01-01T12:00:00Z"
    ~~~
    - Note: `file.changed` captures the time when any of the file's properties or attributes (including the content) are changed, while `file.modified` captures the timestamp when the file content is modified.
    - Requires: Value type should be `String`
  */
  case fileChanged = "file.changed"

  /**
    Time when the file was created, in ISO 8601 format..
    ~~~
    // Examples
      attributes[.FileCreated] = "2021-01-01T12:00:00Z"
    ~~~
    - Note: This attribute might not be supported by some file systems — NFS, FAT32, in embedded OS, etc.
    - Requires: Value type should be `String`
  */
  case fileCreated = "file.created"

  /**
    Directory where the file is located. It should include the drive letter, when appropriate..
    ~~~
    // Examples
      attributes[.FileDirectory] = "/home/user"
      attributes[.FileDirectory] = "C:\Program Files\MyApp"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileDirectory = "file.directory"

  /**
    File extension, excluding the leading dot..
    ~~~
    // Examples
      attributes[.FileExtension] = "png"
      attributes[.FileExtension] = "gz"
    ~~~
    - Note: When the file name has multiple extensions (example.tar.gz), only the last one should be captured ("gz", not "tar.gz").
    - Requires: Value type should be `String`
  */
  case fileExtension = "file.extension"

  /**
    Name of the fork. A fork is additional data associated with a filesystem object..
    ~~~
    // Examples
      attributes[.FileForkName] = "Zone.Identifier"
    ~~~
    - Note: On Linux, a resource fork is used to store additional data with a filesystem object. A file always has at least one fork for the data portion, and additional forks may exist.
      On NTFS, this is analogous to an Alternate Data Stream (ADS), and the default data stream for a file is just called $DATA. Zone.Identifier is commonly used by Windows to track contents downloaded from the Internet. An ADS is typically of the form: C:\path\to\filename.extension:some_fork_name, and some_fork_name is the value that should populate `fork_name`. `filename.extension` should populate `file.name`, and `extension` should populate `file.extension`. The full path, `file.path`, will include the fork name.
    - Requires: Value type should be `String`
  */
  case fileForkName = "file.fork_name"

  /**
    Primary Group ID (GID) of the file..
    ~~~
    // Examples
      attributes[.FileGroupId] = "1000"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileGroupId = "file.group.id"

  /**
    Primary group name of the file..
    ~~~
    // Examples
      attributes[.FileGroupName] = "users"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileGroupName = "file.group.name"

  /**
    Inode representing the file in the filesystem..
    ~~~
    // Examples
      attributes[.FileInode] = "256383"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileInode = "file.inode"

  /**
    Mode of the file in octal representation..
    ~~~
    // Examples
      attributes[.FileMode] = "0640"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileMode = "file.mode"

  /**
    Time when the file content was last modified, in ISO 8601 format..
    ~~~
    // Examples
      attributes[.FileModified] = "2021-01-01T12:00:00Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileModified = "file.modified"

  /**
    Name of the file including the extension, without the directory..
    ~~~
    // Examples
      attributes[.FileName] = "example.png"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileName = "file.name"

  /**
    The user ID (UID) or security identifier (SID) of the file owner..
    ~~~
    // Examples
      attributes[.FileOwnerId] = "1000"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileOwnerId = "file.owner.id"

  /**
    Username of the file owner..
    ~~~
    // Examples
      attributes[.FileOwnerName] = "root"
    ~~~
    - Requires: Value type should be `String`
  */
  case fileOwnerName = "file.owner.name"

  /**
    Full path to the file, including the file name. It should include the drive letter, when appropriate..
    ~~~
    // Examples
      attributes[.FilePath] = "/home/alice/example.png"
      attributes[.FilePath] = "C:\Program Files\MyApp\myapp.exe"
    ~~~
    - Requires: Value type should be `String`
  */
  case filePath = "file.path"

  /**
    File size in bytes..
    - Requires: Value type should be `Int`
  */
  case fileSize = "file.size"

  /**
    Path to the target of a symbolic link..
    ~~~
    // Examples
      attributes[.FileSymbolicLinkTargetPath] = "/usr/bin/python3"
    ~~~
    - Note: This attribute is only applicable to symbolic links.
    - Requires: Value type should be `String`
  */
  case fileSymbolicLinkTargetPath = "file.symbolic_link.target_path"

  /**
    Two-letter code representing continent’s name..
    - Requires: Value should be one of [`SemanticAttributes.GeoContinentCodeValues`](x-source-tag://otelGeoContinentCodeValues) (of type `String`)
  */
  case geoContinentCode = "geo.continent.code"

  /**
    Two-letter ISO Country Code ([ISO 3166-1 alpha2](https://wikipedia.org/wiki/ISO_3166-1#Codes))..
    ~~~
    // Examples
      attributes[.GeoCountryIsoCode] = "CA"
    ~~~
    - Requires: Value type should be `String`
  */
  case geoCountryIsoCode = "geo.country.iso_code"

  /**
    Locality name. Represents the name of a city, town, village, or similar populated place..
    ~~~
    // Examples
      attributes[.GeoLocalityName] = "Montreal"
      attributes[.GeoLocalityName] = "Berlin"
    ~~~
    - Requires: Value type should be `String`
  */
  case geoLocalityName = "geo.locality.name"

  /**
    Latitude of the geo location in [WGS84](https://wikipedia.org/wiki/World_Geodetic_System#WGS84)..
    ~~~
    // Examples
      attributes[.GeoLocationLat] = 45.505918
    ~~~
    - Requires: Value type should be `double`
  */
  case geoLocationLat = "geo.location.lat"

  /**
    Longitude of the geo location in [WGS84](https://wikipedia.org/wiki/World_Geodetic_System#WGS84)..
    ~~~
    // Examples
      attributes[.GeoLocationLon] = -73.61483
    ~~~
    - Requires: Value type should be `double`
  */
  case geoLocationLon = "geo.location.lon"

  /**
    Postal code associated with the location. Values appropriate for this field may also be known as a postcode or ZIP code and will vary widely from country to country..
    ~~~
    // Examples
      attributes[.GeoPostalCode] = "94040"
    ~~~
    - Requires: Value type should be `String`
  */
  case geoPostalCode = "geo.postal_code"

  /**
    Region ISO code ([ISO 3166-2](https://wikipedia.org/wiki/ISO_3166-2))..
    ~~~
    // Examples
      attributes[.GeoRegionIsoCode] = "CA-QC"
    ~~~
    - Requires: Value type should be `String`
  */
  case geoRegionIsoCode = "geo.region.iso_code"

  /**
    The type of memory..
    ~~~
    // Examples
      attributes[.GoMemoryType] = other
      attributes[.GoMemoryType] = stack
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.GoMemoryTypeValues`](x-source-tag://otelGoMemoryTypeValues) (of type `String`)
  */
  case goMemoryType = "go.memory.type"

  /**
    The GraphQL document being executed..
    ~~~
    // Examples
  
      attributes[.GraphqlDocument] = "query findBookById { bookById(id: ?) { name } }"
    ~~~
    - Note: The value may be sanitized to exclude sensitive information.
    - Requires: Value type should be `String`
  */
  case graphqlDocument = "graphql.document"

  /**
    The name of the operation being executed..
    ~~~
    // Examples
  
      attributes[.GraphqlOperationName] = "findBookById"
    ~~~
    - Requires: Value type should be `String`
  */
  case graphqlOperationName = "graphql.operation.name"

  /**
    The type of the operation being executed..
    ~~~
    // Examples
      attributes[.GraphqlOperationType] = query
      attributes[.GraphqlOperationType] = mutation
      attributes[.GraphqlOperationType] = subscription
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.GraphqlOperationTypeValues`](x-source-tag://otelGraphqlOperationTypeValues) (of type `String`)
  */
  case graphqlOperationType = "graphql.operation.type"

  /**
    Unique identifier for the application.
    ~~~
    // Examples
      attributes[.HerokuAppId] = "2daa2797-e42b-4624-9322-ec3f968df4da"
    ~~~
    - Requires: Value type should be `String`
  */
  case herokuAppId = "heroku.app.id"

  /**
    Commit hash for the current release.
    ~~~
    // Examples
      attributes[.HerokuReleaseCommit] = "e6134959463efd8966b20e75b913cafe3f5ec"
    ~~~
    - Requires: Value type should be `String`
  */
  case herokuReleaseCommit = "heroku.release.commit"

  /**
    Time and date the release was created.
    ~~~
    // Examples
      attributes[.HerokuReleaseCreationTimestamp] = "2022-10-23T18:00:42Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case herokuReleaseCreationTimestamp = "heroku.release.creation_timestamp"

  /**
    The CPU architecture the host system is running on..
    - Requires: Value should be one of [`SemanticAttributes.HostArchValues`](x-source-tag://otelHostArchValues) (of type `String`)
  */
  case hostArch = "host.arch"

  /**
    The amount of level 2 memory cache available to the processor (in Bytes)..
    ~~~
    // Examples
      attributes[.HostCpuCacheL2Size] = 12288000
    ~~~
    - Requires: Value type should be `Int`
  */
  case hostCpuCacheL2Size = "host.cpu.cache.l2.size"

  /**
    Family or generation of the CPU..
    ~~~
    // Examples
      attributes[.HostCpuFamily] = "6"
      attributes[.HostCpuFamily] = "PA-RISC 1.1e"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostCpuFamily = "host.cpu.family"

  /**
    Model identifier. It provides more granular information about the CPU, distinguishing it from other CPUs within the same family..
    ~~~
    // Examples
      attributes[.HostCpuModelId] = "6"
      attributes[.HostCpuModelId] = "9000/778/B180L"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostCpuModelId = "host.cpu.model.id"

  /**
    Model designation of the processor..
    ~~~
    // Examples
      attributes[.HostCpuModelName] = "11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostCpuModelName = "host.cpu.model.name"

  /**
    Stepping or core revisions..
    ~~~
    // Examples
      attributes[.HostCpuStepping] = "1"
      attributes[.HostCpuStepping] = "r1p1"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostCpuStepping = "host.cpu.stepping"

  /**
    Processor manufacturer identifier. A maximum 12-character string..
    ~~~
    // Examples
      attributes[.HostCpuVendorId] = "GenuineIntel"
    ~~~
    - Note: [CPUID](https://wiki.osdev.org/CPUID) command returns the vendor ID string in EBX, EDX and ECX registers. Writing these to memory in this order results in a 12-character string.
    - Requires: Value type should be `String`
  */
  case hostCpuVendorId = "host.cpu.vendor.id"

  /**
    Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider. For non-containerized systems, this should be the `machine-id`. See the table below for the sources to use to determine the `machine-id` based on operating system..
    ~~~
    // Examples
      attributes[.HostId] = "fdbf79e8af94cb7f9e8df36789187052"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostId = "host.id"

  /**
    VM image ID or host OS image ID. For Cloud, this value is from the provider..
    ~~~
    // Examples
      attributes[.HostImageId] = "ami-07b06b442921831e5"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostImageId = "host.image.id"

  /**
    Name of the VM image or OS install the host was instantiated from..
    ~~~
    // Examples
      attributes[.HostImageName] = "infra-ami-eks-worker-node-7d4ec78312"
      attributes[.HostImageName] = "CentOS-8-x86_64-1905"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostImageName = "host.image.name"

  /**
    The version string of the VM image or host OS as defined in [Version Attributes](/docs/resource/README.md#version-attributes)..
    ~~~
    // Examples
      attributes[.HostImageVersion] = "0.1"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostImageVersion = "host.image.version"

  /**
    Available IP addresses of the host, excluding loopback interfaces..
    ~~~
    // Examples
      attributes[.HostIp] = ["192.168.1.140", "fe80::abc2:4a28:737a:609e"]
    ~~~
    - Note: IPv4 Addresses MUST be specified in dotted-quad notation. IPv6 addresses MUST be specified in the [RFC 5952](https://www.rfc-editor.org/rfc/rfc5952.html) format.
    - Requires: Value type should be `[String]`
  */
  case hostIp = "host.ip"

  /**
    Available MAC addresses of the host, excluding loopback interfaces..
    ~~~
    // Examples
      attributes[.HostMac] = ["AC-DE-48-23-45-67", "AC-DE-48-23-45-67-01-9F"]
    ~~~
    - Note: MAC Addresses MUST be represented in [IEEE RA hexadecimal form](https://standards.ieee.org/wp-content/uploads/import/documents/tutorials/eui.pdf): as hyphen-separated octets in uppercase hexadecimal form from most to least significant.
    - Requires: Value type should be `[String]`
  */
  case hostMac = "host.mac"

  /**
    Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user..
    ~~~
    // Examples
      attributes[.HostName] = "opentelemetry-test"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostName = "host.name"

  /**
    Type of host. For Cloud, this must be the machine type..
    ~~~
    // Examples
      attributes[.HostType] = "n1-standard-1"
    ~~~
    - Requires: Value type should be `String`
  */
  case hostType = "host.type"

  /**
    State of the HTTP connection in the HTTP connection pool..
    ~~~
    // Examples
      attributes[.HttpConnectionState] = active
      attributes[.HttpConnectionState] = idle
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.HttpConnectionStateValues`](x-source-tag://otelHttpConnectionStateValues) (of type `String`)
  */
  case httpConnectionState = "http.connection.state"

  /**
    The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size..
    ~~~
    // Examples
  
      attributes[.HttpRequestBodySize] = 3495
    ~~~
    - Requires: Value type should be `Int`
  */
  case httpRequestBodySize = "http.request.body.size"

  /**
    HTTP request headers, `<key>` being the normalized HTTP Header name (lowercase), the value being the header values..
    ~~~
    // Examples
      attributes[.HttpRequestHeader] = ["application/json"]
      attributes[.HttpRequestHeader] = ["1.2.3.4", "1.2.3.5"]
    ~~~
    - Note: Instrumentations SHOULD require an explicit configuration of which headers are to be captured.
      Including all request headers can be a security risk - explicit configuration helps avoid leaking sensitive information.

      The `User-Agent` header is already captured in the `user_agent.original` attribute.
      Users MAY explicitly configure instrumentations to capture them even though it is not recommended.

      The attribute value MUST consist of either multiple header values as an array of strings
      or a single-item array containing a possibly comma-concatenated string, depending on the way
      the HTTP library provides access to headers.

      Examples:

      - A header `Content-Type: application/json` SHOULD be recorded as the `http.request.header.content-type`
        attribute with value `["application/json"]`.
      - A header `X-Forwarded-For: 1.2.3.4, 1.2.3.5` SHOULD be recorded as the `http.request.header.x-forwarded-for`
        attribute with value `["1.2.3.4", "1.2.3.5"]` or `["1.2.3.4, 1.2.3.5"]` depending on the HTTP library.
    - Requires: Value type should be `template[string[]]`
  */
  case httpRequestHeader = "http.request.header"

  /**
    HTTP request method..
    ~~~
    // Examples
      attributes[.HttpRequestMethod] = GET
      attributes[.HttpRequestMethod] = POST
      attributes[.HttpRequestMethod] = HEAD
    ~~~
    - Note: HTTP request method value SHOULD be "known" to the instrumentation.
      By default, this convention defines "known" methods as the ones listed in [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-methods)
      and the PATCH method defined in [RFC5789](https://www.rfc-editor.org/rfc/rfc5789.html).

      If the HTTP request method is not known to instrumentation, it MUST set the `http.request.method` attribute to `_OTHER`.

      If the HTTP instrumentation could end up converting valid HTTP request methods to `_OTHER`, then it MUST provide a way to override
      the list of known HTTP methods. If this override is done via environment variable, then the environment variable MUST be named
      OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS and support a comma-separated list of case-sensitive known HTTP methods
      (this list MUST be a full override of the default known method, it is not a list of known methods in addition to the defaults).

      HTTP method names are case-sensitive and `http.request.method` attribute value MUST match a known HTTP method name exactly.
      Instrumentations for specific web frameworks that consider HTTP methods to be case insensitive, SHOULD populate a canonical equivalent.
      Tracing instrumentations that do so, MUST also set `http.request.method_original` to the original value.
    - Requires: Value should be one of [`SemanticAttributes.HttpRequestMethodValues`](x-source-tag://otelHttpRequestMethodValues) (of type `String`)
  */
  case httpRequestMethod = "http.request.method"

  /**
    Original HTTP method sent by the client in the request line..
    ~~~
    // Examples
      attributes[.HttpRequestMethodOriginal] = "GeT"
      attributes[.HttpRequestMethodOriginal] = "ACL"
      attributes[.HttpRequestMethodOriginal] = "foo"
    ~~~
    - Requires: Value type should be `String`
  */
  case httpRequestMethodOriginal = "http.request.method_original"

  /**
    The ordinal number of request resending attempt (for any reason, including redirects)..
    ~~~
    // Examples
  
      attributes[.HttpRequestResendCount] = 3
    ~~~
    - Note: The resend count SHOULD be updated each time an HTTP request gets resent by the client, regardless of what was the cause of the resending (e.g. redirection, authorization failure, 503 Server Unavailable, network issues, or any other).
    - Requires: Value type should be `Int`
  */
  case httpRequestResendCount = "http.request.resend_count"

  /**
    The total size of the request in bytes. This should be the total number of bytes sent over the wire, including the request line (HTTP/1.1), framing (HTTP/2 and HTTP/3), headers, and request body if any..
    ~~~
    // Examples
  
      attributes[.HttpRequestSize] = 1437
    ~~~
    - Requires: Value type should be `Int`
  */
  case httpRequestSize = "http.request.size"

  /**
    The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size..
    ~~~
    // Examples
  
      attributes[.HttpResponseBodySize] = 3495
    ~~~
    - Requires: Value type should be `Int`
  */
  case httpResponseBodySize = "http.response.body.size"

  /**
    HTTP response headers, `<key>` being the normalized HTTP Header name (lowercase), the value being the header values..
    ~~~
    // Examples
      attributes[.HttpResponseHeader] = ["application/json"]
      attributes[.HttpResponseHeader] = ["abc", "def"]
    ~~~
    - Note: Instrumentations SHOULD require an explicit configuration of which headers are to be captured.
      Including all response headers can be a security risk - explicit configuration helps avoid leaking sensitive information.

      Users MAY explicitly configure instrumentations to capture them even though it is not recommended.

      The attribute value MUST consist of either multiple header values as an array of strings
      or a single-item array containing a possibly comma-concatenated string, depending on the way
      the HTTP library provides access to headers.

      Examples:

      - A header `Content-Type: application/json` header SHOULD be recorded as the `http.request.response.content-type`
        attribute with value `["application/json"]`.
      - A header `My-custom-header: abc, def` header SHOULD be recorded as the `http.response.header.my-custom-header`
        attribute with value `["abc", "def"]` or `["abc, def"]` depending on the HTTP library.
    - Requires: Value type should be `template[string[]]`
  */
  case httpResponseHeader = "http.response.header"

  /**
    The total size of the response in bytes. This should be the total number of bytes sent over the wire, including the status line (HTTP/1.1), framing (HTTP/2 and HTTP/3), headers, and response body and trailers if any..
    ~~~
    // Examples
  
      attributes[.HttpResponseSize] = 1437
    ~~~
    - Requires: Value type should be `Int`
  */
  case httpResponseSize = "http.response.size"

  /**
    [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6)..
    ~~~
    // Examples
      attributes[.HttpResponseStatusCode] = 200
    ~~~
    - Requires: Value type should be `Int`
  */
  case httpResponseStatusCode = "http.response.status_code"

  /**
    The matched route, that is, the path template in the format used by the respective server framework..
    ~~~
    // Examples
      attributes[.HttpRoute] = "/users/:userID?"
      attributes[.HttpRoute] = "{controller}/{action}/{id?}"
    ~~~
    - Note: MUST NOT be populated when this is not supported by the HTTP server framework as the route attribute should have low-cardinality and the URI path can NOT substitute it.
      SHOULD include the [application root](/docs/http/http-spans.md#http-server-definitions) if there is one.
    - Requires: Value type should be `String`
  */
  case httpRoute = "http.route"

  /**
    Design capacity in Watts-hours or Amper-hours.
    ~~~
    // Examples
      attributes[.HwBatteryCapacity] = "9.3Ah"
      attributes[.HwBatteryCapacity] = "50Wh"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwBatteryCapacity = "hw.battery.capacity"

  /**
    Battery [chemistry](https://schemas.dmtf.org/wbem/cim-html/2.31.0/CIM_Battery.html), e.g. Lithium-Ion, Nickel-Cadmium, etc..
    ~~~
    // Examples
      attributes[.HwBatteryChemistry] = "Li-ion"
      attributes[.HwBatteryChemistry] = "NiMH"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwBatteryChemistry = "hw.battery.chemistry"

  /**
    The current state of the battery.
    - Requires: Value should be one of [`SemanticAttributes.HwBatteryStateValues`](x-source-tag://otelHwBatteryStateValues) (of type `String`)
  */
  case hwBatteryState = "hw.battery.state"

  /**
    BIOS version of the hardware component.
    ~~~
    // Examples
      attributes[.HwBiosVersion] = "1.2.3"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwBiosVersion = "hw.bios_version"

  /**
    Driver version for the hardware component.
    ~~~
    // Examples
      attributes[.HwDriverVersion] = "10.2.1-3"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwDriverVersion = "hw.driver_version"

  /**
    Type of the enclosure (useful for modular systems).
    ~~~
    // Examples
      attributes[.HwEnclosureType] = "Computer"
      attributes[.HwEnclosureType] = "Storage"
      attributes[.HwEnclosureType] = "Switch"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwEnclosureType = "hw.enclosure.type"

  /**
    Firmware version of the hardware component.
    ~~~
    // Examples
      attributes[.HwFirmwareVersion] = "2.0.1"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwFirmwareVersion = "hw.firmware_version"

  /**
    Type of task the GPU is performing.
    - Requires: Value should be one of [`SemanticAttributes.HwGpuTaskValues`](x-source-tag://otelHwGpuTaskValues) (of type `String`)
  */
  case hwGpuTask = "hw.gpu.task"

  /**
    An identifier for the hardware component, unique within the monitored host.
    ~~~
    // Examples
      attributes[.HwId] = "win32battery_battery_testsysa33_1"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwId = "hw.id"

  /**
    Type of limit for hardware components.
    - Requires: Value should be one of [`SemanticAttributes.HwLimitTypeValues`](x-source-tag://otelHwLimitTypeValues) (of type `String`)
  */
  case hwLimitType = "hw.limit_type"

  /**
    RAID Level of the logical disk.
    ~~~
    // Examples
      attributes[.HwLogicalDiskRaidLevel] = "RAID0+1"
      attributes[.HwLogicalDiskRaidLevel] = "RAID5"
      attributes[.HwLogicalDiskRaidLevel] = "RAID10"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwLogicalDiskRaidLevel = "hw.logical_disk.raid_level"

  /**
    State of the logical disk space usage.
    - Requires: Value should be one of [`SemanticAttributes.HwLogicalDiskStateValues`](x-source-tag://otelHwLogicalDiskStateValues) (of type `String`)
  */
  case hwLogicalDiskState = "hw.logical_disk.state"

  /**
    Type of the memory module.
    ~~~
    // Examples
      attributes[.HwMemoryType] = "DDR4"
      attributes[.HwMemoryType] = "DDR5"
      attributes[.HwMemoryType] = "LPDDR5"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwMemoryType = "hw.memory.type"

  /**
    Descriptive model name of the hardware component.
    ~~~
    // Examples
      attributes[.HwModel] = "PERC H740P"
      attributes[.HwModel] = "Intel(R) Core(TM) i7-10700K"
      attributes[.HwModel] = "Dell XPS 15 Battery"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwModel = "hw.model"

  /**
    An easily-recognizable name for the hardware component.
    ~~~
    // Examples
      attributes[.HwName] = "eth0"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwName = "hw.name"

  /**
    Logical addresses of the adapter (e.g. IP address, or WWPN).
    ~~~
    // Examples
      attributes[.HwNetworkLogicalAddresses] = ["172.16.8.21", "57.11.193.42"]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case hwNetworkLogicalAddresses = "hw.network.logical_addresses"

  /**
    Physical address of the adapter (e.g. MAC address, or WWNN).
    ~~~
    // Examples
      attributes[.HwNetworkPhysicalAddress] = "00-90-F5-E9-7B-36"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwNetworkPhysicalAddress = "hw.network.physical_address"

  /**
    Unique identifier of the parent component (typically the `hw.id` attribute of the enclosure, or disk controller).
    ~~~
    // Examples
      attributes[.HwParent] = "dellStorage_perc_0"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwParent = "hw.parent"

  /**
    [S.M.A.R.T.](https://wikipedia.org/wiki/S.M.A.R.T.) (Self-Monitoring, Analysis, and Reporting Technology) attribute of the physical disk.
    ~~~
    // Examples
      attributes[.HwPhysicalDiskSmartAttribute] = "Spin Retry Count"
      attributes[.HwPhysicalDiskSmartAttribute] = "Seek Error Rate"
      attributes[.HwPhysicalDiskSmartAttribute] = "Raw Read Error Rate"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwPhysicalDiskSmartAttribute = "hw.physical_disk.smart_attribute"

  /**
    State of the physical disk endurance utilization.
    - Requires: Value should be one of [`SemanticAttributes.HwPhysicalDiskStateValues`](x-source-tag://otelHwPhysicalDiskStateValues) (of type `String`)
  */
  case hwPhysicalDiskState = "hw.physical_disk.state"

  /**
    Type of the physical disk.
    ~~~
    // Examples
      attributes[.HwPhysicalDiskType] = "HDD"
      attributes[.HwPhysicalDiskType] = "SSD"
      attributes[.HwPhysicalDiskType] = "10K"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwPhysicalDiskType = "hw.physical_disk.type"

  /**
    Location of the sensor.
    ~~~
    // Examples
      attributes[.HwSensorLocation] = "cpu0"
      attributes[.HwSensorLocation] = "ps1"
      attributes[.HwSensorLocation] = "INLET"
      attributes[.HwSensorLocation] = "CPU0_DIE"
      attributes[.HwSensorLocation] = "AMBIENT"
      attributes[.HwSensorLocation] = "MOTHERBOARD"
      attributes[.HwSensorLocation] = "PS0 V3_3"
      attributes[.HwSensorLocation] = "MAIN_12V"
      attributes[.HwSensorLocation] = "CPU_VCORE"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwSensorLocation = "hw.sensor_location"

  /**
    Serial number of the hardware component.
    ~~~
    // Examples
      attributes[.HwSerialNumber] = "CNFCP0123456789"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwSerialNumber = "hw.serial_number"

  /**
    The current state of the component.
    - Requires: Value should be one of [`SemanticAttributes.HwStateValues`](x-source-tag://otelHwStateValues) (of type `String`)
  */
  case hwState = "hw.state"

  /**
    Type of tape drive operation.
    - Requires: Value should be one of [`SemanticAttributes.HwTapeDriveOperationTypeValues`](x-source-tag://otelHwTapeDriveOperationTypeValues) (of type `String`)
  */
  case hwTapeDriveOperationType = "hw.tape_drive.operation_type"

  /**
    Type of the component.
    - Note: Describes the category of the hardware component for which `hw.state` is being reported. For example, `hw.type=temperature` along with `hw.state=degraded` would indicate that the temperature of the hardware component has been reported as `degraded`.
    - Requires: Value should be one of [`SemanticAttributes.HwTypeValues`](x-source-tag://otelHwTypeValues) (of type `String`)
  */
  case hwType = "hw.type"

  /**
    Vendor name of the hardware component.
    ~~~
    // Examples
      attributes[.HwVendor] = "Dell"
      attributes[.HwVendor] = "HP"
      attributes[.HwVendor] = "Intel"
      attributes[.HwVendor] = "AMD"
      attributes[.HwVendor] = "LSI"
      attributes[.HwVendor] = "Lenovo"
    ~~~
    - Requires: Value type should be `String`
  */
  case hwVendor = "hw.vendor"

  /**
    This attribute represents the state of the application..
    - Note: The iOS lifecycle states are defined in the [UIApplicationDelegate documentation](https://developer.apple.com/documentation/uikit/uiapplicationdelegate), and from which the `OS terminology` column values are derived.
    - Requires: Value should be one of [`SemanticAttributes.IosAppStateValues`](x-source-tag://otelIosAppStateValues) (of type `String`)
  */
  case iosAppState = "ios.app.state"

  /**
    The Linux Slab memory state.
    ~~~
    // Examples
      attributes[.LinuxMemorySlabState] = reclaimable
      attributes[.LinuxMemorySlabState] = unreclaimable
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.LinuxMemorySlabStateValues`](x-source-tag://otelLinuxMemorySlabStateValues) (of type `String`)
  */
  case linuxMemorySlabState = "linux.memory.slab.state"

  /**
    The basename of the file..
    ~~~
    // Examples
      attributes[.LogFileName] = "audit.log"
    ~~~
    - Requires: Value type should be `String`
  */
  case logFileName = "log.file.name"

  /**
    The basename of the file, with symlinks resolved..
    ~~~
    // Examples
      attributes[.LogFileNameResolved] = "uuid.log"
    ~~~
    - Requires: Value type should be `String`
  */
  case logFileNameResolved = "log.file.name_resolved"

  /**
    The full path to the file..
    ~~~
    // Examples
      attributes[.LogFilePath] = "/var/log/mysql/audit.log"
    ~~~
    - Requires: Value type should be `String`
  */
  case logFilePath = "log.file.path"

  /**
    The full path to the file, with symlinks resolved..
    ~~~
    // Examples
      attributes[.LogFilePathResolved] = "/var/lib/docker/uuid.log"
    ~~~
    - Requires: Value type should be `String`
  */
  case logFilePathResolved = "log.file.path_resolved"

  /**
    The stream associated with the log. See below for a list of well-known values..
    - Requires: Value should be one of [`SemanticAttributes.LogIostreamValues`](x-source-tag://otelLogIostreamValues) (of type `String`)
  */
  case logIostream = "log.iostream"

  /**
    The complete original Log Record..
    ~~~
    // Examples
      attributes[.LogRecordOriginal] = "77 <86>1 2015-08-06T21:58:59.694Z 192.168.2.133 inactive - - - Something happened"
      attributes[.LogRecordOriginal] = "[INFO] 8/3/24 12:34:56 Something happened"
    ~~~
    - Note: This value MAY be added when processing a Log Record which was originally transmitted as a string or equivalent data type AND the Body field of the Log Record does not contain the same value. (e.g. a syslog or a log record read from a file.)
    - Requires: Value type should be `String`
  */
  case logRecordOriginal = "log.record.original"

  /**
    A unique identifier for the Log Record..
    ~~~
    // Examples
      attributes[.LogRecordUid] = "01ARZ3NDEKTSV4RRFFQ69G5FAV"
    ~~~
    - Note: If an id is provided, other log records with the same id will be considered duplicates and can be removed safely. This means, that two distinguishable log records MUST have different values.
      The id MAY be an [Universally Unique Lexicographically Sortable Identifier (ULID)](https://github.com/ulid/spec), but other identifiers (e.g. UUID) may be used as needed.
    - Requires: Value type should be `String`
  */
  case logRecordUid = "log.record.uid"

  /**
    Name of the logical partition that hosts a systems with a mainframe operating system..
    ~~~
    // Examples
      attributes[.MainframeLparName] = "LPAR01"
    ~~~
    - Requires: Value type should be `String`
  */
  case mainframeLparName = "mainframe.lpar.name"

  /**
    The number of messages sent, received, or processed in the scope of the batching operation..
    ~~~
    // Examples
      attributes[.MessagingBatchMessageCount] = 0
      attributes[.MessagingBatchMessageCount] = 1
      attributes[.MessagingBatchMessageCount] = 2
    ~~~
    - Note: Instrumentations SHOULD NOT set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations SHOULD use `messaging.batch.message_count` for batching APIs and SHOULD NOT use it for single-message APIs.
    - Requires: Value type should be `Int`
  */
  case messagingBatchMessageCount = "messaging.batch.message_count"

  /**
    A unique identifier for the client that consumes or produces a message..
    ~~~
    // Examples
      attributes[.MessagingClientId] = "client-5"
      attributes[.MessagingClientId] = "myhost@8742@s8083jm"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingClientId = "messaging.client.id"

  /**
    The name of the consumer group with which a consumer is associated..
    ~~~
    // Examples
      attributes[.MessagingConsumerGroupName] = "my-group"
      attributes[.MessagingConsumerGroupName] = "indexer"
    ~~~
    - Note: Semantic conventions for individual messaging systems SHOULD document whether `messaging.consumer.group.name` is applicable and what it means in the context of that system.
    - Requires: Value type should be `String`
  */
  case messagingConsumerGroupName = "messaging.consumer.group.name"

  /**
    A boolean that is true if the message destination is anonymous (could be unnamed or have auto-generated name)..
    - Requires: Value type should be `Bool`
  */
  case messagingDestinationAnonymous = "messaging.destination.anonymous"

  /**
    The message destination name.
    ~~~
    // Examples
      attributes[.MessagingDestinationName] = "MyQueue"
      attributes[.MessagingDestinationName] = "MyTopic"
    ~~~
    - Note: Destination name SHOULD uniquely identify a specific queue, topic or other entity within the broker. If
      the broker doesn't have such notion, the destination name SHOULD uniquely identify the broker.
    - Requires: Value type should be `String`
  */
  case messagingDestinationName = "messaging.destination.name"

  /**
    The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`..
    ~~~
    // Examples
  
      attributes[.MessagingDestinationPartitionId] = "1"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingDestinationPartitionId = "messaging.destination.partition.id"

  /**
    The name of the destination subscription from which a message is consumed..
    ~~~
    // Examples
      attributes[.MessagingDestinationSubscriptionName] = "subscription-a"
    ~~~
    - Note: Semantic conventions for individual messaging systems SHOULD document whether `messaging.destination.subscription.name` is applicable and what it means in the context of that system.
    - Requires: Value type should be `String`
  */
  case messagingDestinationSubscriptionName = "messaging.destination.subscription.name"

  /**
    Low cardinality representation of the messaging destination name.
    ~~~
    // Examples
      attributes[.MessagingDestinationTemplate] = "/customers/{customerId}"
    ~~~
    - Note: Destination names could be constructed from templates. An example would be a destination name involving a user name or product id. Although the destination name in this case is of high cardinality, the underlying template is of low cardinality and can be effectively used for grouping and aggregation.
    - Requires: Value type should be `String`
  */
  case messagingDestinationTemplate = "messaging.destination.template"

  /**
    A boolean that is true if the message destination is temporary and might not exist anymore after messages are processed..
    - Requires: Value type should be `Bool`
  */
  case messagingDestinationTemporary = "messaging.destination.temporary"

  /**
    The UTC epoch seconds at which the message has been accepted and stored in the entity..
    ~~~
    // Examples
  
      attributes[.MessagingEventhubsMessageEnqueuedTime] = 1701393730
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingEventhubsMessageEnqueuedTime = "messaging.eventhubs.message.enqueued_time"

  /**
    The ack deadline in seconds set for the modify ack deadline request..
    ~~~
    // Examples
  
      attributes[.MessagingGcpPubsubMessageAckDeadline] = 10
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingGcpPubsubMessageAckDeadline = "messaging.gcp_pubsub.message.ack_deadline"

  /**
    The ack id for a given message..
    ~~~
    // Examples
  
      attributes[.MessagingGcpPubsubMessageAckId] = "ack_id"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingGcpPubsubMessageAckId = "messaging.gcp_pubsub.message.ack_id"

  /**
    The delivery attempt for a given message..
    ~~~
    // Examples
  
      attributes[.MessagingGcpPubsubMessageDeliveryAttempt] = 2
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingGcpPubsubMessageDeliveryAttempt = "messaging.gcp_pubsub.message.delivery_attempt"

  /**
    The ordering key for a given message. If the attribute is not present, the message does not have an ordering key..
    ~~~
    // Examples
  
      attributes[.MessagingGcpPubsubMessageOrderingKey] = "ordering_key"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingGcpPubsubMessageOrderingKey = "messaging.gcp_pubsub.message.ordering_key"

  /**
    Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute MUST NOT be set..
    ~~~
    // Examples
  
      attributes[.MessagingKafkaMessageKey] = "myKey"
    ~~~
    - Note: If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.
    - Requires: Value type should be `String`
  */
  case messagingKafkaMessageKey = "messaging.kafka.message.key"

  /**
    A boolean that is true if the message is a tombstone..
    - Requires: Value type should be `Bool`
  */
  case messagingKafkaMessageTombstone = "messaging.kafka.message.tombstone"

  /**
    The offset of a record in the corresponding Kafka partition..
    ~~~
    // Examples
  
      attributes[.MessagingKafkaOffset] = 42
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingKafkaOffset = "messaging.kafka.offset"

  /**
    The size of the message body in bytes..
    ~~~
    // Examples
  
      attributes[.MessagingMessageBodySize] = 1439
    ~~~
    - Note: This can refer to both the compressed or uncompressed body size. If both sizes are known, the uncompressed
      body size should be used.
    - Requires: Value type should be `Int`
  */
  case messagingMessageBodySize = "messaging.message.body.size"

  /**
    The conversation ID identifying the conversation to which the message belongs, represented as a string. Sometimes called "Correlation ID"..
    ~~~
    // Examples
  
      attributes[.MessagingMessageConversationId] = "MyConversationId"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingMessageConversationId = "messaging.message.conversation_id"

  /**
    The size of the message body and metadata in bytes..
    ~~~
    // Examples
  
      attributes[.MessagingMessageEnvelopeSize] = 2738
    ~~~
    - Note: This can refer to both the compressed or uncompressed size. If both sizes are known, the uncompressed
      size should be used.
    - Requires: Value type should be `Int`
  */
  case messagingMessageEnvelopeSize = "messaging.message.envelope.size"

  /**
    A value used by the messaging system as an identifier for the message, represented as a string..
    ~~~
    // Examples
  
      attributes[.MessagingMessageId] = "452a7c7c7c7048c2f887f61572b18fc2"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingMessageId = "messaging.message.id"

  /**
    The system-specific name of the messaging operation..
    ~~~
    // Examples
      attributes[.MessagingOperationName] = "ack"
      attributes[.MessagingOperationName] = "nack"
      attributes[.MessagingOperationName] = "send"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingOperationName = "messaging.operation.name"

  /**
    A string identifying the type of the messaging operation..
    - Note: If a custom value is used, it MUST be of low cardinality.
    - Requires: Value should be one of [`SemanticAttributes.MessagingOperationTypeValues`](x-source-tag://otelMessagingOperationTypeValues) (of type `String`)
  */
  case messagingOperationType = "messaging.operation.type"

  /**
    RabbitMQ message routing key..
    ~~~
    // Examples
  
      attributes[.MessagingRabbitmqDestinationRoutingKey] = "myKey"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingRabbitmqDestinationRoutingKey = "messaging.rabbitmq.destination.routing_key"

  /**
    RabbitMQ message delivery tag.
    ~~~
    // Examples
  
      attributes[.MessagingRabbitmqMessageDeliveryTag] = 123
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingRabbitmqMessageDeliveryTag = "messaging.rabbitmq.message.delivery_tag"

  /**
    Model of message consumption. This only applies to consumer spans..
    - Requires: Value should be one of [`SemanticAttributes.MessagingRocketmqConsumptionModelValues`](x-source-tag://otelMessagingRocketmqConsumptionModelValues) (of type `String`)
  */
  case messagingRocketmqConsumptionModel = "messaging.rocketmq.consumption_model"

  /**
    The delay time level for delay message, which determines the message delay time..
    ~~~
    // Examples
  
      attributes[.MessagingRocketmqMessageDelayTimeLevel] = 3
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingRocketmqMessageDelayTimeLevel = "messaging.rocketmq.message.delay_time_level"

  /**
    The timestamp in milliseconds that the delay message is expected to be delivered to consumer..
    ~~~
    // Examples
  
      attributes[.MessagingRocketmqMessageDeliveryTimestamp] = 1665987217045
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingRocketmqMessageDeliveryTimestamp = "messaging.rocketmq.message.delivery_timestamp"

  /**
    It is essential for FIFO message. Messages that belong to the same message group are always processed one by one within the same consumer group..
    ~~~
    // Examples
  
      attributes[.MessagingRocketmqMessageGroup] = "myMessageGroup"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingRocketmqMessageGroup = "messaging.rocketmq.message.group"

  /**
    Key(s) of message, another way to mark message besides message id..
    ~~~
    // Examples
      attributes[.MessagingRocketmqMessageKeys] = ["keyA", "keyB"]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case messagingRocketmqMessageKeys = "messaging.rocketmq.message.keys"

  /**
    The secondary classifier of message besides topic..
    ~~~
    // Examples
  
      attributes[.MessagingRocketmqMessageTag] = "tagA"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingRocketmqMessageTag = "messaging.rocketmq.message.tag"

  /**
    Type of message..
    - Requires: Value should be one of [`SemanticAttributes.MessagingRocketmqMessageTypeValues`](x-source-tag://otelMessagingRocketmqMessageTypeValues) (of type `String`)
  */
  case messagingRocketmqMessageType = "messaging.rocketmq.message.type"

  /**
    Namespace of RocketMQ resources, resources in different namespaces are individual..
    ~~~
    // Examples
  
      attributes[.MessagingRocketmqNamespace] = "myNamespace"
    ~~~
    - Requires: Value type should be `String`
  */
  case messagingRocketmqNamespace = "messaging.rocketmq.namespace"

  /**
    Describes the [settlement type](https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock)..
    - Requires: Value should be one of [`SemanticAttributes.MessagingServicebusDispositionStatusValues`](x-source-tag://otelMessagingServicebusDispositionStatusValues) (of type `String`)
  */
  case messagingServicebusDispositionStatus = "messaging.servicebus.disposition_status"

  /**
    Number of deliveries that have been attempted for this message..
    ~~~
    // Examples
  
      attributes[.MessagingServicebusMessageDeliveryCount] = 2
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingServicebusMessageDeliveryCount = "messaging.servicebus.message.delivery_count"

  /**
    The UTC epoch seconds at which the message has been accepted and stored in the entity..
    ~~~
    // Examples
  
      attributes[.MessagingServicebusMessageEnqueuedTime] = 1701393730
    ~~~
    - Requires: Value type should be `Int`
  */
  case messagingServicebusMessageEnqueuedTime = "messaging.servicebus.message.enqueued_time"

  /**
    The messaging system as identified by the client instrumentation..
    - Note: The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.
    - Requires: Value should be one of [`SemanticAttributes.MessagingSystemValues`](x-source-tag://otelMessagingSystemValues) (of type `String`)
  */
  case messagingSystem = "messaging.system"

  /**
    The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network..
    ~~~
    // Examples
  
      attributes[.NetworkCarrierIcc] = "DE"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkCarrierIcc = "network.carrier.icc"

  /**
    The mobile carrier country code..
    ~~~
    // Examples
  
      attributes[.NetworkCarrierMcc] = "310"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkCarrierMcc = "network.carrier.mcc"

  /**
    The mobile carrier network code..
    ~~~
    // Examples
  
      attributes[.NetworkCarrierMnc] = "001"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkCarrierMnc = "network.carrier.mnc"

  /**
    The name of the mobile carrier..
    ~~~
    // Examples
  
      attributes[.NetworkCarrierName] = "sprint"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkCarrierName = "network.carrier.name"

  /**
    The state of network connection.
    ~~~
    // Examples
      attributes[.NetworkConnectionState] = close_wait
    ~~~
    - Note: Connection states are defined as part of the [rfc9293](https://datatracker.ietf.org/doc/html/rfc9293#section-3.3.2)
    - Requires: Value should be one of [`SemanticAttributes.NetworkConnectionStateValues`](x-source-tag://otelNetworkConnectionStateValues) (of type `String`)
  */
  case networkConnectionState = "network.connection.state"

  /**
    This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection..
    ~~~
    // Examples
  
      attributes[.NetworkConnectionSubtype] = LTE
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.NetworkConnectionSubtypeValues`](x-source-tag://otelNetworkConnectionSubtypeValues) (of type `String`)
  */
  case networkConnectionSubtype = "network.connection.subtype"

  /**
    The internet connection type..
    ~~~
    // Examples
  
      attributes[.NetworkConnectionType] = wifi
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.NetworkConnectionTypeValues`](x-source-tag://otelNetworkConnectionTypeValues) (of type `String`)
  */
  case networkConnectionType = "network.connection.type"

  /**
    The network interface name..
    ~~~
    // Examples
      attributes[.NetworkInterfaceName] = "lo"
      attributes[.NetworkInterfaceName] = "eth0"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkInterfaceName = "network.interface.name"

  /**
    The network IO operation direction..
    ~~~
    // Examples
      attributes[.NetworkIoDirection] = transmit
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.NetworkIoDirectionValues`](x-source-tag://otelNetworkIoDirectionValues) (of type `String`)
  */
  case networkIoDirection = "network.io.direction"

  /**
    Local address of the network connection - IP address or Unix domain socket name..
    ~~~
    // Examples
      attributes[.NetworkLocalAddress] = "10.1.2.80"
      attributes[.NetworkLocalAddress] = "/tmp/my.sock"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkLocalAddress = "network.local.address"

  /**
    Local port number of the network connection..
    ~~~
    // Examples
      attributes[.NetworkLocalPort] = 65123
    ~~~
    - Requires: Value type should be `Int`
  */
  case networkLocalPort = "network.local.port"

  /**
    Peer address of the network connection - IP address or Unix domain socket name..
    ~~~
    // Examples
      attributes[.NetworkPeerAddress] = "10.1.2.80"
      attributes[.NetworkPeerAddress] = "/tmp/my.sock"
    ~~~
    - Requires: Value type should be `String`
  */
  case networkPeerAddress = "network.peer.address"

  /**
    Peer port number of the network connection..
    ~~~
    // Examples
      attributes[.NetworkPeerPort] = 65123
    ~~~
    - Requires: Value type should be `Int`
  */
  case networkPeerPort = "network.peer.port"

  /**
    [OSI application layer](https://wikipedia.org/wiki/Application_layer) or non-OSI equivalent..
    ~~~
    // Examples
      attributes[.NetworkProtocolName] = "amqp"
      attributes[.NetworkProtocolName] = "http"
      attributes[.NetworkProtocolName] = "mqtt"
    ~~~
    - Note: The value SHOULD be normalized to lowercase.
    - Requires: Value type should be `String`
  */
  case networkProtocolName = "network.protocol.name"

  /**
    The actual version of the protocol used for network communication..
    ~~~
    // Examples
      attributes[.NetworkProtocolVersion] = "1.1"
      attributes[.NetworkProtocolVersion] = "2"
    ~~~
    - Note: If protocol version is subject to negotiation (for example using [ALPN](https://www.rfc-editor.org/rfc/rfc7301.html)), this attribute SHOULD be set to the negotiated version. If the actual protocol version is not known, this attribute SHOULD NOT be set.
    - Requires: Value type should be `String`
  */
  case networkProtocolVersion = "network.protocol.version"

  /**
    [OSI transport layer](https://wikipedia.org/wiki/Transport_layer) or [inter-process communication method](https://wikipedia.org/wiki/Inter-process_communication)..
    ~~~
    // Examples
      attributes[.NetworkTransport] = tcp
      attributes[.NetworkTransport] = udp
    ~~~
    - Note: The value SHOULD be normalized to lowercase.

      Consider always setting the transport when setting a port number, since
      a port number is ambiguous without knowing the transport. For example
      different processes could be listening on TCP port 12345 and UDP port 12345.
    - Requires: Value should be one of [`SemanticAttributes.NetworkTransportValues`](x-source-tag://otelNetworkTransportValues) (of type `String`)
  */
  case networkTransport = "network.transport"

  /**
    [OSI network layer](https://wikipedia.org/wiki/Network_layer) or non-OSI equivalent..
    ~~~
    // Examples
      attributes[.NetworkType] = ipv4
      attributes[.NetworkType] = ipv6
    ~~~
    - Note: The value SHOULD be normalized to lowercase.
    - Requires: Value should be one of [`SemanticAttributes.NetworkTypeValues`](x-source-tag://otelNetworkTypeValues) (of type `String`)
  */
  case networkType = "network.type"

  /**
    The state of event loop time..
    - Requires: Value should be one of [`SemanticAttributes.NodejsEventloopStateValues`](x-source-tag://otelNodejsEventloopStateValues) (of type `String`)
  */
  case nodejsEventloopState = "nodejs.eventloop.state"

  /**
    The digest of the OCI image manifest. For container images specifically is the digest by which the container image is known..
    ~~~
    // Examples
      attributes[.OciManifestDigest] = "sha256:e4ca62c0d62f3e886e684806dfe9d4e0cda60d54986898173c1083856cfda0f4"
    ~~~
    - Note: Follows [OCI Image Manifest Specification](https://github.com/opencontainers/image-spec/blob/main/manifest.md), and specifically the [Digest property](https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests).
      An example can be found in [Example Image Manifest](https://github.com/opencontainers/image-spec/blob/main/manifest.md#example-image-manifest).
    - Requires: Value type should be `String`
  */
  case ociManifestDigest = "oci.manifest.digest"

  /**
    The service tier requested. May be a specific tier, default, or auto..
    ~~~
    // Examples
      attributes[.OpenaiRequestServiceTier] = auto
      attributes[.OpenaiRequestServiceTier] = default
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.OpenaiRequestServiceTierValues`](x-source-tag://otelOpenaiRequestServiceTierValues) (of type `String`)
  */
  case openaiRequestServiceTier = "openai.request.service_tier"

  /**
    The service tier used for the response..
    ~~~
    // Examples
      attributes[.OpenaiResponseServiceTier] = "scale"
      attributes[.OpenaiResponseServiceTier] = "default"
    ~~~
    - Requires: Value type should be `String`
  */
  case openaiResponseServiceTier = "openai.response.service_tier"

  /**
    A fingerprint to track any eventual change in the Generative AI environment..
    ~~~
    // Examples
      attributes[.OpenaiResponseSystemFingerprint] = "fp_44709d6fcb"
    ~~~
    - Requires: Value type should be `String`
  */
  case openaiResponseSystemFingerprint = "openai.response.system_fingerprint"

  /**
    Parent-child Reference type.
    - Note: The causal relationship between a child Span and a parent Span.
    - Requires: Value should be one of [`SemanticAttributes.OpentracingRefTypeValues`](x-source-tag://otelOpentracingRefTypeValues) (of type `String`)
  */
  case opentracingRefType = "opentracing.ref_type"

  /**
    Unique identifier for a particular build or compilation of the operating system..
    ~~~
    // Examples
      attributes[.OsBuildId] = "TQ3C.230805.001.B2"
      attributes[.OsBuildId] = "20E247"
      attributes[.OsBuildId] = "22621"
    ~~~
    - Requires: Value type should be `String`
  */
  case osBuildId = "os.build_id"

  /**
    Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands..
    ~~~
    // Examples
      attributes[.OsDescription] = "Microsoft Windows [Version 10.0.18363.778]"
      attributes[.OsDescription] = "Ubuntu 18.04.1 LTS"
    ~~~
    - Requires: Value type should be `String`
  */
  case osDescription = "os.description"

  /**
    Human readable operating system name..
    ~~~
    // Examples
      attributes[.OsName] = "iOS"
      attributes[.OsName] = "Android"
      attributes[.OsName] = "Ubuntu"
    ~~~
    - Requires: Value type should be `String`
  */
  case osName = "os.name"

  /**
    The operating system type..
    - Requires: Value should be one of [`SemanticAttributes.OsTypeValues`](x-source-tag://otelOsTypeValues) (of type `String`)
  */
  case osType = "os.type"

  /**
    The version string of the operating system as defined in [Version Attributes](/docs/resource/README.md#version-attributes)..
    ~~~
    // Examples
      attributes[.OsVersion] = "14.2.1"
      attributes[.OsVersion] = "18.04.1"
    ~~~
    - Requires: Value type should be `String`
  */
  case osVersion = "os.version"

  /**
    A name uniquely identifying the instance of the OpenTelemetry component within its containing SDK instance..
    ~~~
    // Examples
      attributes[.OtelComponentName] = "otlp_grpc_span_exporter/0"
      attributes[.OtelComponentName] = "custom-name"
    ~~~
    - Note: Implementations SHOULD ensure a low cardinality for this attribute, even across application or SDK restarts.
      E.g. implementations MUST NOT use UUIDs as values for this attribute.

      Implementations MAY achieve these goals by following a `<otel.component.type>/<instance-counter>` pattern, e.g. `batching_span_processor/0`.
      Hereby `otel.component.type` refers to the corresponding attribute value of the component.

      The value of `instance-counter` MAY be automatically assigned by the component and uniqueness within the enclosing SDK instance MUST be guaranteed.
      For example, `<instance-counter>` MAY be implemented by using a monotonically increasing counter (starting with `0`), which is incremented every time an
      instance of the given component type is started.

      With this implementation, for example the first Batching Span Processor would have `batching_span_processor/0`
      as `otel.component.name`, the second one `batching_span_processor/1` and so on.
      These values will therefore be reused in the case of an application restart.
    - Requires: Value type should be `String`
  */
  case otelComponentName = "otel.component.name"

  /**
    A name identifying the type of the OpenTelemetry component..
    ~~~
    // Examples
      attributes[.OtelComponentType] = batching_span_processor
      attributes[.OtelComponentType] = com.example.MySpanExporter
    ~~~
    - Note: If none of the standardized values apply, implementations SHOULD use the language-defined name of the type.
      E.g. for Java the fully qualified classname SHOULD be used in this case.
    - Requires: Value should be one of [`SemanticAttributes.OtelComponentTypeValues`](x-source-tag://otelOtelComponentTypeValues) (of type `String`)
  */
  case otelComponentType = "otel.component.type"

  /**
    The name of the instrumentation scope - (`InstrumentationScope.Name` in OTLP)..
    ~~~
    // Examples
      attributes[.OtelScopeName] = "io.opentelemetry.contrib.mongodb"
    ~~~
    - Requires: Value type should be `String`
  */
  case otelScopeName = "otel.scope.name"

  /**
    The schema URL of the instrumentation scope..
    ~~~
    // Examples
      attributes[.OtelScopeSchemaUrl] = "https://opentelemetry.io/schemas/1.31.0"
    ~~~
    - Requires: Value type should be `String`
  */
  case otelScopeSchemaUrl = "otel.scope.schema_url"

  /**
    The version of the instrumentation scope - (`InstrumentationScope.Version` in OTLP)..
    ~~~
    // Examples
      attributes[.OtelScopeVersion] = "1.0.0"
    ~~~
    - Requires: Value type should be `String`
  */
  case otelScopeVersion = "otel.scope.version"

  /**
    Determines whether the span has a parent span, and if so, [whether it is a remote parent](https://opentelemetry.io/docs/specs/otel/trace/api/#isremote).
    - Requires: Value should be one of [`SemanticAttributes.OtelSpanParentOriginValues`](x-source-tag://otelOtelSpanParentOriginValues) (of type `String`)
  */
  case otelSpanParentOrigin = "otel.span.parent.origin"

  /**
    The result value of the sampler for this span.
    - Requires: Value should be one of [`SemanticAttributes.OtelSpanSamplingResultValues`](x-source-tag://otelOtelSpanSamplingResultValues) (of type `String`)
  */
  case otelSpanSamplingResult = "otel.span.sampling_result"

  /**
    Name of the code, either "OK" or "ERROR". MUST NOT be set if the status code is UNSET..
    - Requires: Value should be one of [`SemanticAttributes.OtelStatusCodeValues`](x-source-tag://otelOtelStatusCodeValues) (of type `String`)
  */
  case otelStatusCode = "otel.status_code"

  /**
    Description of the Status if it has a value, otherwise not set..
    ~~~
    // Examples
      attributes[.OtelStatusDescription] = "resource not found"
    ~~~
    - Requires: Value type should be `String`
  */
  case otelStatusDescription = "otel.status_description"

  /**
    The [`service.name`](/docs/resource/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any..
    ~~~
    // Examples
  
      attributes[.PeerService] = "AuthTokenCache"
    ~~~
    - Requires: Value type should be `String`
  */
  case peerService = "peer.service"

  /**
    Length of the process.command_args array.
    ~~~
    // Examples
      attributes[.ProcessArgsCount] = 4
    ~~~
    - Note: This field can be useful for querying or performing bucket analysis on how many arguments were provided to start a process. More arguments may be an indication of suspicious activity.
    - Requires: Value type should be `Int`
  */
  case processArgsCount = "process.args_count"

  /**
    The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`..
    ~~~
    // Examples
      attributes[.ProcessCommand] = "cmd/otelcol"
    ~~~
    - Requires: Value type should be `String`
  */
  case processCommand = "process.command"

  /**
    All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`. SHOULD NOT be collected by default unless there is sanitization that excludes sensitive data..
    ~~~
    // Examples
      attributes[.ProcessCommandArgs] = ["cmd/otecol", "--config=config.yaml"]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case processCommandArgs = "process.command_args"

  /**
    The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead. SHOULD NOT be collected by default unless there is sanitization that excludes sensitive data..
    ~~~
    // Examples
      attributes[.ProcessCommandLine] = "C:\cmd\otecol --config=\"my directory\config.yaml\""
    ~~~
    - Requires: Value type should be `String`
  */
  case processCommandLine = "process.command_line"

  /**
    Specifies whether the context switches for this data point were voluntary or involuntary..
    - Requires: Value should be one of [`SemanticAttributes.ProcessContextSwitchTypeValues`](x-source-tag://otelProcessContextSwitchTypeValues) (of type `String`)
  */
  case processContextSwitchType = "process.context_switch_type"

  /**
    The date and time the process was created, in ISO 8601 format..
    ~~~
    // Examples
      attributes[.ProcessCreationTime] = "2023-11-21T09:25:34.853Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case processCreationTime = "process.creation.time"

  /**
    Process environment variables, `<key>` being the environment variable name, the value being the environment variable value..
    ~~~
    // Examples
      attributes[.ProcessEnvironmentVariable] = "ubuntu"
      attributes[.ProcessEnvironmentVariable] = "/usr/local/bin:/usr/bin"
    ~~~
    - Note: Examples:

      - an environment variable `USER` with value `"ubuntu"` SHOULD be recorded
        as the `process.environment_variable.USER` attribute with value `"ubuntu"`.
      - an environment variable `PATH` with value `"/usr/local/bin:/usr/bin"`
        SHOULD be recorded as the `process.environment_variable.PATH` attribute
        with value `"/usr/local/bin:/usr/bin"`.
    - Requires: Value type should be `template[string]`
  */
  case processEnvironmentVariable = "process.environment_variable"

  /**
    The GNU build ID as found in the `.note.gnu.build-id` ELF section (hex string)..
    ~~~
    // Examples
      attributes[.ProcessExecutableBuildIdGnu] = "c89b11207f6479603b0d49bf291c092c2b719293"
    ~~~
    - Requires: Value type should be `String`
  */
  case processExecutableBuildIdGnu = "process.executable.build_id.gnu"

  /**
    The Go build ID as retrieved by `go tool buildid <go executable>`..
    ~~~
    // Examples
      attributes[.ProcessExecutableBuildIdGo] = "foh3mEXu7BLZjsN9pOwG/kATcXlYVCDEFouRMQed_/WwRFB1hPo9LBkekthSPG/x8hMC8emW2cCjXD0_1aY"
    ~~~
    - Requires: Value type should be `String`
  */
  case processExecutableBuildIdGo = "process.executable.build_id.go"

  /**
    Profiling specific build ID for executables. See the OTel specification for Profiles for more information..
    ~~~
    // Examples
      attributes[.ProcessExecutableBuildIdHtlhash] = "600DCAFE4A110000F2BF38C493F5FB92"
    ~~~
    - Requires: Value type should be `String`
  */
  case processExecutableBuildIdHtlhash = "process.executable.build_id.htlhash"

  /**
    The name of the process executable. On Linux based systems, this SHOULD be set to the base name of the target of `/proc/[pid]/exe`. On Windows, this SHOULD be set to the base name of `GetProcessImageFileNameW`..
    ~~~
    // Examples
      attributes[.ProcessExecutableName] = "otelcol"
    ~~~
    - Requires: Value type should be `String`
  */
  case processExecutableName = "process.executable.name"

  /**
    The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`..
    ~~~
    // Examples
      attributes[.ProcessExecutablePath] = "/usr/bin/cmd/otelcol"
    ~~~
    - Requires: Value type should be `String`
  */
  case processExecutablePath = "process.executable.path"

  /**
    The exit code of the process..
    ~~~
    // Examples
      attributes[.ProcessExitCode] = 127
    ~~~
    - Requires: Value type should be `Int`
  */
  case processExitCode = "process.exit.code"

  /**
    The date and time the process exited, in ISO 8601 format..
    ~~~
    // Examples
      attributes[.ProcessExitTime] = "2023-11-21T09:26:12.315Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case processExitTime = "process.exit.time"

  /**
    The PID of the process's group leader. This is also the process group ID (PGID) of the process..
    ~~~
    // Examples
      attributes[.ProcessGroupLeaderPid] = 23
    ~~~
    - Requires: Value type should be `Int`
  */
  case processGroupLeaderPid = "process.group_leader.pid"

  /**
    Whether the process is connected to an interactive shell..
    - Requires: Value type should be `Bool`
  */
  case processInteractive = "process.interactive"

  /**
    The control group associated with the process..
    ~~~
    // Examples
      attributes[.ProcessLinuxCgroup] = "1:name=systemd:/user.slice/user-1000.slice/session-3.scope"
      attributes[.ProcessLinuxCgroup] = "0::/user.slice/user-1000.slice/user@1000.service/tmux-spawn-0267755b-4639-4a27-90ed-f19f88e53748.scope"
    ~~~
    - Note: Control groups (cgroups) are a kernel feature used to organize and manage process resources. This attribute provides the path(s) to the cgroup(s) associated with the process, which should match the contents of the [/proc/[PID]/cgroup](https://man7.org/linux/man-pages/man7/cgroups.7.html) file.
    - Requires: Value type should be `String`
  */
  case processLinuxCgroup = "process.linux.cgroup"

  /**
    The username of the user that owns the process..
    ~~~
    // Examples
      attributes[.ProcessOwner] = "root"
    ~~~
    - Requires: Value type should be `String`
  */
  case processOwner = "process.owner"

  /**
    The type of page fault for this data point. Type `major` is for major/hard page faults, and `minor` is for minor/soft page faults..
    - Requires: Value should be one of [`SemanticAttributes.ProcessPagingFaultTypeValues`](x-source-tag://otelProcessPagingFaultTypeValues) (of type `String`)
  */
  case processPagingFaultType = "process.paging.fault_type"

  /**
    Parent Process identifier (PPID)..
    ~~~
    // Examples
      attributes[.ProcessParentPid] = 111
    ~~~
    - Requires: Value type should be `Int`
  */
  case processParentPid = "process.parent_pid"

  /**
    Process identifier (PID)..
    ~~~
    // Examples
      attributes[.ProcessPid] = 1234
    ~~~
    - Requires: Value type should be `Int`
  */
  case processPid = "process.pid"

  /**
    The real user ID (RUID) of the process..
    ~~~
    // Examples
      attributes[.ProcessRealUserId] = 1000
    ~~~
    - Requires: Value type should be `Int`
  */
  case processRealUserId = "process.real_user.id"

  /**
    The username of the real user of the process..
    ~~~
    // Examples
      attributes[.ProcessRealUserName] = "operator"
    ~~~
    - Requires: Value type should be `String`
  */
  case processRealUserName = "process.real_user.name"

  /**
    An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment..
    ~~~
    // Examples
  
      attributes[.ProcessRuntimeDescription] = "Eclipse OpenJ9 Eclipse OpenJ9 VM openj9-0.21.0"
    ~~~
    - Requires: Value type should be `String`
  */
  case processRuntimeDescription = "process.runtime.description"

  /**
    The name of the runtime of this process..
    ~~~
    // Examples
      attributes[.ProcessRuntimeName] = "OpenJDK Runtime Environment"
    ~~~
    - Requires: Value type should be `String`
  */
  case processRuntimeName = "process.runtime.name"

  /**
    The version of the runtime of this process, as returned by the runtime without modification..
    ~~~
    // Examples
  
      attributes[.ProcessRuntimeVersion] = "14.0.2"
    ~~~
    - Requires: Value type should be `String`
  */
  case processRuntimeVersion = "process.runtime.version"

  /**
    The saved user ID (SUID) of the process..
    ~~~
    // Examples
      attributes[.ProcessSavedUserId] = 1002
    ~~~
    - Requires: Value type should be `Int`
  */
  case processSavedUserId = "process.saved_user.id"

  /**
    The username of the saved user..
    ~~~
    // Examples
      attributes[.ProcessSavedUserName] = "operator"
    ~~~
    - Requires: Value type should be `String`
  */
  case processSavedUserName = "process.saved_user.name"

  /**
    The PID of the process's session leader. This is also the session ID (SID) of the process..
    ~~~
    // Examples
      attributes[.ProcessSessionLeaderPid] = 14
    ~~~
    - Requires: Value type should be `Int`
  */
  case processSessionLeaderPid = "process.session_leader.pid"

  /**
    Process title (proctitle).
    ~~~
    // Examples
      attributes[.ProcessTitle] = "cat /etc/hostname"
      attributes[.ProcessTitle] = "xfce4-session"
      attributes[.ProcessTitle] = "bash"
    ~~~
    - Note: In many Unix-like systems, process title (proctitle), is the string that represents the name or command line of a running process, displayed by system monitoring tools like ps, top, and htop.
    - Requires: Value type should be `String`
  */
  case processTitle = "process.title"

  /**
    The effective user ID (EUID) of the process..
    ~~~
    // Examples
      attributes[.ProcessUserId] = 1001
    ~~~
    - Requires: Value type should be `Int`
  */
  case processUserId = "process.user.id"

  /**
    The username of the effective user of the process..
    ~~~
    // Examples
      attributes[.ProcessUserName] = "root"
    ~~~
    - Requires: Value type should be `String`
  */
  case processUserName = "process.user.name"

  /**
    Virtual process identifier..
    ~~~
    // Examples
      attributes[.ProcessVpid] = 12
    ~~~
    - Note: The process ID within a PID namespace. This is not necessarily unique across all processes on the host but it is unique within the process namespace that the process exists within.
    - Requires: Value type should be `Int`
  */
  case processVpid = "process.vpid"

  /**
    The working directory of the process..
    ~~~
    // Examples
      attributes[.ProcessWorkingDirectory] = "/root"
    ~~~
    - Requires: Value type should be `String`
  */
  case processWorkingDirectory = "process.working_directory"

  /**
    Describes the interpreter or compiler of a single frame..
    ~~~
    // Examples
      attributes[.ProfileFrameType] = cpython
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.ProfileFrameTypeValues`](x-source-tag://otelProfileFrameTypeValues) (of type `String`)
  */
  case profileFrameType = "profile.frame.type"

  /**
    A categorization value keyword used by the entity using the rule for detection of this event.
    ~~~
    // Examples
      attributes[.SecurityRuleCategory] = "Attempted Information Leak"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleCategory = "security_rule.category"

  /**
    The description of the rule generating the event..
    ~~~
    // Examples
      attributes[.SecurityRuleDescription] = "Block requests to public DNS over HTTPS / TLS protocols"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleDescription = "security_rule.description"

  /**
    Name of the license under which the rule used to generate this event is made available..
    ~~~
    // Examples
      attributes[.SecurityRuleLicense] = "Apache 2.0"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleLicense = "security_rule.license"

  /**
    The name of the rule or signature generating the event..
    ~~~
    // Examples
      attributes[.SecurityRuleName] = "BLOCK_DNS_over_TLS"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleName = "security_rule.name"

  /**
    Reference URL to additional information about the rule used to generate this event..
    ~~~
    // Examples
      attributes[.SecurityRuleReference] = "https://en.wikipedia.org/wiki/DNS_over_TLS"
    ~~~
    - Note: The URL can point to the vendor’s documentation about the rule. If that’s not available, it can also be a link to a more general page describing this type of alert.
    - Requires: Value type should be `String`
  */
  case securityRuleReference = "security_rule.reference"

  /**
    Name of the ruleset, policy, group, or parent category in which the rule used to generate this event is a member..
    ~~~
    // Examples
      attributes[.SecurityRuleRulesetName] = "Standard_Protocol_Filters"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleRulesetName = "security_rule.ruleset.name"

  /**
    A rule ID that is unique within the scope of a set or group of agents, observers, or other entities using the rule for detection of this event..
    ~~~
    // Examples
      attributes[.SecurityRuleUuid] = "550e8400-e29b-41d4-a716-446655440000"
      attributes[.SecurityRuleUuid] = "1100110011"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleUuid = "security_rule.uuid"

  /**
    The version / revision of the rule being used for analysis..
    ~~~
    // Examples
      attributes[.SecurityRuleVersion] = "1.0.0"
    ~~~
    - Requires: Value type should be `String`
  */
  case securityRuleVersion = "security_rule.version"

  /**
    Server domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..
    ~~~
    // Examples
      attributes[.ServerAddress] = "example.com"
      attributes[.ServerAddress] = "10.1.2.80"
      attributes[.ServerAddress] = "/tmp/my.sock"
    ~~~
    - Note: When observed from the client side, and when communicating through an intermediary, `server.address` SHOULD represent the server address behind any intermediaries, for example proxies, if it's available.
    - Requires: Value type should be `String`
  */
  case serverAddress = "server.address"

  /**
    Server port number..
    ~~~
    // Examples
      attributes[.ServerPort] = 80
      attributes[.ServerPort] = 8080
      attributes[.ServerPort] = 443
    ~~~
    - Note: When observed from the client side, and when communicating through an intermediary, `server.port` SHOULD represent the server port behind any intermediaries, for example proxies, if it's available.
    - Requires: Value type should be `Int`
  */
  case serverPort = "server.port"

  /**
    The string ID of the service instance..
    ~~~
    // Examples
      attributes[.ServiceInstanceId] = "627cc493-f310-47de-96bd-71410b7dec09"
    ~~~
    - Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words
      `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to
      distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled
      service).

      Implementations, such as SDKs, are recommended to generate a random Version 1 or Version 4 [RFC
      4122](https://www.ietf.org/rfc/rfc4122.txt) UUID, but are free to use an inherent unique ID as the source of
      this value if stability is desirable. In that case, the ID SHOULD be used as source of a UUID Version 5 and
      SHOULD use the following UUID as the namespace: `4d63009a-8d0f-11ee-aad7-4c796ed8e320`.

      UUIDs are typically recommended, as only an opaque value for the purposes of identifying a service instance is
      needed. Similar to what can be seen in the man page for the
      [`/etc/machine-id`](https://www.freedesktop.org/software/systemd/man/latest/machine-id.html) file, the underlying
      data, such as pod name and namespace should be treated as confidential, being the user's choice to expose it
      or not via another resource attribute.

      For applications running behind an application server (like unicorn), we do not recommend using one identifier
      for all processes participating in the application. Instead, it's recommended each division (e.g. a worker
      thread in unicorn) to have its own instance.id.

      It's not recommended for a Collector to set `service.instance.id` if it can't unambiguously determine the
      service instance that is generating that telemetry. For instance, creating an UUID based on `pod.name` will
      likely be wrong, as the Collector might not know from which container within that pod the telemetry originated.
      However, Collectors can set the `service.instance.id` if they can unambiguously determine the service instance
      for that telemetry. This is typically the case for scraping receivers, as they know the target address and
      port.
    - Requires: Value type should be `String`
  */
  case serviceInstanceId = "service.instance.id"

  /**
    Logical name of the service..
    ~~~
    // Examples
      attributes[.ServiceName] = "shoppingcart"
    ~~~
    - Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
    - Requires: Value type should be `String`
  */
  case serviceName = "service.name"

  /**
    A namespace for `service.name`..
    ~~~
    // Examples
      attributes[.ServiceNamespace] = "Shop"
    ~~~
    - Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
    - Requires: Value type should be `String`
  */
  case serviceNamespace = "service.namespace"

  /**
    The version string of the service API or implementation. The format is not defined by these conventions..
    ~~~
    // Examples
      attributes[.ServiceVersion] = "2.0.0"
      attributes[.ServiceVersion] = "a01dbef8a"
    ~~~
    - Requires: Value type should be `String`
  */
  case serviceVersion = "service.version"

  /**
    A unique id to identify a session..
    ~~~
    // Examples
  
      attributes[.SessionId] = "00112233-4455-6677-8899-aabbccddeeff"
    ~~~
    - Requires: Value type should be `String`
  */
  case sessionId = "session.id"

  /**
    The previous `session.id` for this user, when known..
    ~~~
    // Examples
  
      attributes[.SessionPreviousId] = "00112233-4455-6677-8899-aabbccddeeff"
    ~~~
    - Requires: Value type should be `String`
  */
  case sessionPreviousId = "session.previous_id"

  /**
    Source address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name..
    ~~~
    // Examples
      attributes[.SourceAddress] = "source.example.com"
      attributes[.SourceAddress] = "10.1.2.80"
      attributes[.SourceAddress] = "/tmp/my.sock"
    ~~~
    - Note: When observed from the destination side, and when communicating through an intermediary, `source.address` SHOULD represent the source address behind any intermediaries, for example proxies, if it's available.
    - Requires: Value type should be `String`
  */
  case sourceAddress = "source.address"

  /**
    Source port number.
    ~~~
    // Examples
      attributes[.SourcePort] = 3389
      attributes[.SourcePort] = 2888
    ~~~
    - Requires: Value type should be `Int`
  */
  case sourcePort = "source.port"

  /**
    Deprecated, use `cpu.logical_number` instead..
    ~~~
    // Examples
      attributes[.SystemCpuLogicalNumber] = 1
    ~~~
    - Requires: Value type should be `Int`
  */
  case systemCpuLogicalNumber = "system.cpu.logical_number"

  /**
    The device identifier.
    ~~~
    // Examples
      attributes[.SystemDevice] = "(identifier)"
    ~~~
    - Requires: Value type should be `String`
  */
  case systemDevice = "system.device"

  /**
    The filesystem mode.
    ~~~
    // Examples
      attributes[.SystemFilesystemMode] = "rw, ro"
    ~~~
    - Requires: Value type should be `String`
  */
  case systemFilesystemMode = "system.filesystem.mode"

  /**
    The filesystem mount path.
    ~~~
    // Examples
      attributes[.SystemFilesystemMountpoint] = "/mnt/data"
    ~~~
    - Requires: Value type should be `String`
  */
  case systemFilesystemMountpoint = "system.filesystem.mountpoint"

  /**
    The filesystem state.
    ~~~
    // Examples
      attributes[.SystemFilesystemState] = used
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemFilesystemStateValues`](x-source-tag://otelSystemFilesystemStateValues) (of type `String`)
  */
  case systemFilesystemState = "system.filesystem.state"

  /**
    The filesystem type.
    ~~~
    // Examples
      attributes[.SystemFilesystemType] = ext4
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemFilesystemTypeValues`](x-source-tag://otelSystemFilesystemTypeValues) (of type `String`)
  */
  case systemFilesystemType = "system.filesystem.type"

  /**
    The memory state.
    ~~~
    // Examples
      attributes[.SystemMemoryState] = free
      attributes[.SystemMemoryState] = cached
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemMemoryStateValues`](x-source-tag://otelSystemMemoryStateValues) (of type `String`)
  */
  case systemMemoryState = "system.memory.state"

  /**
    The paging access direction.
    ~~~
    // Examples
      attributes[.SystemPagingDirection] = in
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemPagingDirectionValues`](x-source-tag://otelSystemPagingDirectionValues) (of type `String`)
  */
  case systemPagingDirection = "system.paging.direction"

  /**
    The memory paging state.
    ~~~
    // Examples
      attributes[.SystemPagingState] = free
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemPagingStateValues`](x-source-tag://otelSystemPagingStateValues) (of type `String`)
  */
  case systemPagingState = "system.paging.state"

  /**
    The memory paging type.
    ~~~
    // Examples
      attributes[.SystemPagingType] = minor
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemPagingTypeValues`](x-source-tag://otelSystemPagingTypeValues) (of type `String`)
  */
  case systemPagingType = "system.paging.type"

  /**
    The process state, e.g., [Linux Process State Codes](https://man7.org/linux/man-pages/man1/ps.1.html#PROCESS_STATE_CODES).
    ~~~
    // Examples
      attributes[.SystemProcessStatus] = running
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.SystemProcessStatusValues`](x-source-tag://otelSystemProcessStatusValues) (of type `String`)
  */
  case systemProcessStatus = "system.process.status"

  /**
    The name of the auto instrumentation agent or distribution, if used..
    ~~~
    // Examples
      attributes[.TelemetryDistroName] = "parts-unlimited-java"
    ~~~
    - Note: Official auto instrumentation agents and distributions SHOULD set the `telemetry.distro.name` attribute to
      a string starting with `opentelemetry-`, e.g. `opentelemetry-java-instrumentation`.
    - Requires: Value type should be `String`
  */
  case telemetryDistroName = "telemetry.distro.name"

  /**
    The version string of the auto instrumentation agent or distribution, if used..
    ~~~
    // Examples
      attributes[.TelemetryDistroVersion] = "1.2.3"
    ~~~
    - Requires: Value type should be `String`
  */
  case telemetryDistroVersion = "telemetry.distro.version"

  /**
    The language of the telemetry SDK..
    - Requires: Value should be one of [`SemanticAttributes.TelemetrySdkLanguageValues`](x-source-tag://otelTelemetrySdkLanguageValues) (of type `String`)
  */
  case telemetrySdkLanguage = "telemetry.sdk.language"

  /**
    The name of the telemetry SDK as defined above..
    ~~~
    // Examples
      attributes[.TelemetrySdkName] = "opentelemetry"
    ~~~
    - Note: The OpenTelemetry SDK MUST set the `telemetry.sdk.name` attribute to `opentelemetry`.
      If another SDK, like a fork or a vendor-provided implementation, is used, this SDK MUST set the
      `telemetry.sdk.name` attribute to the fully-qualified class or module name of this SDK's main entry point
      or another suitable identifier depending on the language.
      The identifier `opentelemetry` is reserved and MUST NOT be used in this case.
      All custom identifiers SHOULD be stable across different versions of an implementation.
    - Requires: Value type should be `String`
  */
  case telemetrySdkName = "telemetry.sdk.name"

  /**
    The version string of the telemetry SDK..
    ~~~
    // Examples
      attributes[.TelemetrySdkVersion] = "1.2.3"
    ~~~
    - Requires: Value type should be `String`
  */
  case telemetrySdkVersion = "telemetry.sdk.version"

  /**
    The fully qualified human readable name of the [test case](https://wikipedia.org/wiki/Test_case)..
    ~~~
    // Examples
      attributes[.TestCaseName] = "org.example.TestCase1.test1"
      attributes[.TestCaseName] = "example/tests/TestCase1.test1"
      attributes[.TestCaseName] = "ExampleTestCase1_test1"
    ~~~
    - Requires: Value type should be `String`
  */
  case testCaseName = "test.case.name"

  /**
    The status of the actual test case result from test execution..
    ~~~
    // Examples
      attributes[.TestCaseResultStatus] = pass
      attributes[.TestCaseResultStatus] = fail
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.TestCaseResultStatusValues`](x-source-tag://otelTestCaseResultStatusValues) (of type `String`)
  */
  case testCaseResultStatus = "test.case.result.status"

  /**
    The human readable name of a [test suite](https://wikipedia.org/wiki/Test_suite)..
    ~~~
    // Examples
      attributes[.TestSuiteName] = "TestSuite1"
    ~~~
    - Requires: Value type should be `String`
  */
  case testSuiteName = "test.suite.name"

  /**
    The status of the test suite run..
    ~~~
    // Examples
      attributes[.TestSuiteRunStatus] = success
      attributes[.TestSuiteRunStatus] = failure
      attributes[.TestSuiteRunStatus] = skipped
      attributes[.TestSuiteRunStatus] = aborted
      attributes[.TestSuiteRunStatus] = timed_out
      attributes[.TestSuiteRunStatus] = in_progress
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.TestSuiteRunStatusValues`](x-source-tag://otelTestSuiteRunStatusValues) (of type `String`)
  */
  case testSuiteRunStatus = "test.suite.run.status"

  /**
    Current "managed" thread ID (as opposed to OS thread ID)..
    ~~~
    // Examples
  
      attributes[.ThreadId] = 42
    ~~~
    - Requires: Value type should be `Int`
  */
  case threadId = "thread.id"

  /**
    Current thread name..
    ~~~
    // Examples
  
      attributes[.ThreadName] = "main"
    ~~~
    - Requires: Value type should be `String`
  */
  case threadName = "thread.name"

  /**
    String indicating the [cipher](https://datatracker.ietf.org/doc/html/rfc5246#appendix-A.5) used during the current connection..
    ~~~
    // Examples
      attributes[.TlsCipher] = "TLS_RSA_WITH_3DES_EDE_CBC_SHA"
      attributes[.TlsCipher] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"
    ~~~
    - Note: The values allowed for `tls.cipher` MUST be one of the `Descriptions` of the [registered TLS Cipher Suits](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#table-tls-parameters-4).
    - Requires: Value type should be `String`
  */
  case tlsCipher = "tls.cipher"

  /**
    PEM-encoded stand-alone certificate offered by the client. This is usually mutually-exclusive of `client.certificate_chain` since this value also exists in that list..
    ~~~
    // Examples
      attributes[.TlsClientCertificate] = "MII..."
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientCertificate = "tls.client.certificate"

  /**
    Array of PEM-encoded certificates that make up the certificate chain offered by the client. This is usually mutually-exclusive of `client.certificate` since that value should be the first certificate in the chain..
    ~~~
    // Examples
      attributes[.TlsClientCertificateChain] = ["MII...", "MI..."]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case tlsClientCertificateChain = "tls.client.certificate_chain"

  /**
    Certificate fingerprint using the MD5 digest of DER-encoded version of certificate offered by the client. For consistency with other hash values, this value should be formatted as an uppercase hash..
    ~~~
    // Examples
      attributes[.TlsClientHashMd5] = "0F76C7F2C55BFD7D8E8B8F4BFBF0C9EC"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientHashMd5 = "tls.client.hash.md5"

  /**
    Certificate fingerprint using the SHA1 digest of DER-encoded version of certificate offered by the client. For consistency with other hash values, this value should be formatted as an uppercase hash..
    ~~~
    // Examples
      attributes[.TlsClientHashSha1] = "9E393D93138888D288266C2D915214D1D1CCEB2A"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientHashSha1 = "tls.client.hash.sha1"

  /**
    Certificate fingerprint using the SHA256 digest of DER-encoded version of certificate offered by the client. For consistency with other hash values, this value should be formatted as an uppercase hash..
    ~~~
    // Examples
      attributes[.TlsClientHashSha256] = "0687F666A054EF17A08E2F2162EAB4CBC0D265E1D7875BE74BF3C712CA92DAF0"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientHashSha256 = "tls.client.hash.sha256"

  /**
    Distinguished name of [subject](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6) of the issuer of the x.509 certificate presented by the client..
    ~~~
    // Examples
      attributes[.TlsClientIssuer] = "CN=Example Root CA, OU=Infrastructure Team, DC=example, DC=com"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientIssuer = "tls.client.issuer"

  /**
    A hash that identifies clients based on how they perform an SSL/TLS handshake..
    ~~~
    // Examples
      attributes[.TlsClientJa3] = "d4e5b18d6b55c71272893221c96ba240"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientJa3 = "tls.client.ja3"

  /**
    Date/Time indicating when client certificate is no longer considered valid..
    ~~~
    // Examples
      attributes[.TlsClientNotAfter] = "2021-01-01T00:00:00.000Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientNotAfter = "tls.client.not_after"

  /**
    Date/Time indicating when client certificate is first considered valid..
    ~~~
    // Examples
      attributes[.TlsClientNotBefore] = "1970-01-01T00:00:00.000Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientNotBefore = "tls.client.not_before"

  /**
    Distinguished name of subject of the x.509 certificate presented by the client..
    ~~~
    // Examples
      attributes[.TlsClientSubject] = "CN=myclient, OU=Documentation Team, DC=example, DC=com"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsClientSubject = "tls.client.subject"

  /**
    Array of ciphers offered by the client during the client hello..
    ~~~
    // Examples
      attributes[.TlsClientSupportedCiphers] = ["TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case tlsClientSupportedCiphers = "tls.client.supported_ciphers"

  /**
    String indicating the curve used for the given cipher, when applicable.
    ~~~
    // Examples
      attributes[.TlsCurve] = "secp256r1"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsCurve = "tls.curve"

  /**
    Boolean flag indicating if the TLS negotiation was successful and transitioned to an encrypted tunnel..
    ~~~
    // Examples
      attributes[.TlsEstablished] = true
    ~~~
    - Requires: Value type should be `Bool`
  */
  case tlsEstablished = "tls.established"

  /**
    String indicating the protocol being tunneled. Per the values in the [IANA registry](https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids), this string should be lower case..
    ~~~
    // Examples
      attributes[.TlsNextProtocol] = "http/1.1"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsNextProtocol = "tls.next_protocol"

  /**
    Normalized lowercase protocol name parsed from original string of the negotiated [SSL/TLS protocol version](https://docs.openssl.org/1.1.1/man3/SSL_get_version/#return-values).
    - Requires: Value should be one of [`SemanticAttributes.TlsProtocolNameValues`](x-source-tag://otelTlsProtocolNameValues) (of type `String`)
  */
  case tlsProtocolName = "tls.protocol.name"

  /**
    Numeric part of the version parsed from the original string of the negotiated [SSL/TLS protocol version](https://docs.openssl.org/1.1.1/man3/SSL_get_version/#return-values).
    ~~~
    // Examples
      attributes[.TlsProtocolVersion] = "1.2"
      attributes[.TlsProtocolVersion] = "3"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsProtocolVersion = "tls.protocol.version"

  /**
    Boolean flag indicating if this TLS connection was resumed from an existing TLS negotiation..
    ~~~
    // Examples
      attributes[.TlsResumed] = true
    ~~~
    - Requires: Value type should be `Bool`
  */
  case tlsResumed = "tls.resumed"

  /**
    PEM-encoded stand-alone certificate offered by the server. This is usually mutually-exclusive of `server.certificate_chain` since this value also exists in that list..
    ~~~
    // Examples
      attributes[.TlsServerCertificate] = "MII..."
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerCertificate = "tls.server.certificate"

  /**
    Array of PEM-encoded certificates that make up the certificate chain offered by the server. This is usually mutually-exclusive of `server.certificate` since that value should be the first certificate in the chain..
    ~~~
    // Examples
      attributes[.TlsServerCertificateChain] = ["MII...", "MI..."]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case tlsServerCertificateChain = "tls.server.certificate_chain"

  /**
    Certificate fingerprint using the MD5 digest of DER-encoded version of certificate offered by the server. For consistency with other hash values, this value should be formatted as an uppercase hash..
    ~~~
    // Examples
      attributes[.TlsServerHashMd5] = "0F76C7F2C55BFD7D8E8B8F4BFBF0C9EC"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerHashMd5 = "tls.server.hash.md5"

  /**
    Certificate fingerprint using the SHA1 digest of DER-encoded version of certificate offered by the server. For consistency with other hash values, this value should be formatted as an uppercase hash..
    ~~~
    // Examples
      attributes[.TlsServerHashSha1] = "9E393D93138888D288266C2D915214D1D1CCEB2A"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerHashSha1 = "tls.server.hash.sha1"

  /**
    Certificate fingerprint using the SHA256 digest of DER-encoded version of certificate offered by the server. For consistency with other hash values, this value should be formatted as an uppercase hash..
    ~~~
    // Examples
      attributes[.TlsServerHashSha256] = "0687F666A054EF17A08E2F2162EAB4CBC0D265E1D7875BE74BF3C712CA92DAF0"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerHashSha256 = "tls.server.hash.sha256"

  /**
    Distinguished name of [subject](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6) of the issuer of the x.509 certificate presented by the client..
    ~~~
    // Examples
      attributes[.TlsServerIssuer] = "CN=Example Root CA, OU=Infrastructure Team, DC=example, DC=com"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerIssuer = "tls.server.issuer"

  /**
    A hash that identifies servers based on how they perform an SSL/TLS handshake..
    ~~~
    // Examples
      attributes[.TlsServerJa3s] = "d4e5b18d6b55c71272893221c96ba240"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerJa3s = "tls.server.ja3s"

  /**
    Date/Time indicating when server certificate is no longer considered valid..
    ~~~
    // Examples
      attributes[.TlsServerNotAfter] = "2021-01-01T00:00:00.000Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerNotAfter = "tls.server.not_after"

  /**
    Date/Time indicating when server certificate is first considered valid..
    ~~~
    // Examples
      attributes[.TlsServerNotBefore] = "1970-01-01T00:00:00.000Z"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerNotBefore = "tls.server.not_before"

  /**
    Distinguished name of subject of the x.509 certificate presented by the server..
    ~~~
    // Examples
      attributes[.TlsServerSubject] = "CN=myserver, OU=Documentation Team, DC=example, DC=com"
    ~~~
    - Requires: Value type should be `String`
  */
  case tlsServerSubject = "tls.server.subject"

  /**
    Domain extracted from the `url.full`, such as "opentelemetry.io"..
    ~~~
    // Examples
      attributes[.UrlDomain] = "www.foo.bar"
      attributes[.UrlDomain] = "opentelemetry.io"
      attributes[.UrlDomain] = "3.12.167.2"
      attributes[.UrlDomain] = "[1080:0:0:0:8:800:200C:417A]"
    ~~~
    - Note: In some cases a URL may refer to an IP and/or port directly, without a domain name. In this case, the IP address would go to the domain field. If the URL contains a [literal IPv6 address](https://www.rfc-editor.org/rfc/rfc2732#section-2) enclosed by `[` and `]`, the `[` and `]` characters should also be captured in the domain field.
    - Requires: Value type should be `String`
  */
  case urlDomain = "url.domain"

  /**
    The file extension extracted from the `url.full`, excluding the leading dot..
    ~~~
    // Examples
      attributes[.UrlExtension] = "png"
      attributes[.UrlExtension] = "gz"
    ~~~
    - Note: The file extension is only set if it exists, as not every url has a file extension. When the file name has multiple extensions `example.tar.gz`, only the last one should be captured `gz`, not `tar.gz`.
    - Requires: Value type should be `String`
  */
  case urlExtension = "url.extension"

  /**
    The [URI fragment](https://www.rfc-editor.org/rfc/rfc3986#section-3.5) component.
    ~~~
    // Examples
      attributes[.UrlFragment] = "SemConv"
    ~~~
    - Requires: Value type should be `String`
  */
  case urlFragment = "url.fragment"

  /**
    Absolute URL describing a network resource according to [RFC3986](https://www.rfc-editor.org/rfc/rfc3986).
    ~~~
    // Examples
      attributes[.UrlFull] = "https://www.foo.bar/search?q=OpenTelemetry#SemConv"
      attributes[.UrlFull] = "//localhost"
    ~~~
    - Note: For network calls, URL usually has `scheme://host[:port][path][?query][#fragment]` format, where the fragment
      is not transmitted over HTTP, but if it is known, it SHOULD be included nevertheless.

      `url.full` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`.
      In such case username and password SHOULD be redacted and attribute's value SHOULD be `https://REDACTED:REDACTED@www.example.com/`.

      `url.full` SHOULD capture the absolute URL when it is available (or can be reconstructed).

      Sensitive content provided in `url.full` SHOULD be scrubbed when instrumentations can identify it.


      Query string values for the following keys SHOULD be redacted by default and replaced by the
      value `REDACTED`:

      - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)
      - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)

      This list is subject to change over time.

      When a query string value is redacted, the query string key SHOULD still be preserved, e.g.
      `https://www.example.com/path?color=blue&sig=REDACTED`.
    - Requires: Value type should be `String`
  */
  case urlFull = "url.full"

  /**
    Unmodified original URL as seen in the event source..
    ~~~
    // Examples
      attributes[.UrlOriginal] = "https://www.foo.bar/search?q=OpenTelemetry#SemConv"
      attributes[.UrlOriginal] = "search?q=OpenTelemetry"
    ~~~
    - Note: In network monitoring, the observed URL may be a full URL, whereas in access logs, the URL is often just represented as a path. This field is meant to represent the URL as it was observed, complete or not.
      `url.original` might contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case password and username SHOULD NOT be redacted and attribute's value SHOULD remain the same.
    - Requires: Value type should be `String`
  */
  case urlOriginal = "url.original"

  /**
    The [URI path](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) component.
    ~~~
    // Examples
      attributes[.UrlPath] = "/search"
    ~~~
    - Note: Sensitive content provided in `url.path` SHOULD be scrubbed when instrumentations can identify it.
    - Requires: Value type should be `String`
  */
  case urlPath = "url.path"

  /**
    Port extracted from the `url.full`.
    ~~~
    // Examples
      attributes[.UrlPort] = 443
    ~~~
    - Requires: Value type should be `Int`
  */
  case urlPort = "url.port"

  /**
    The [URI query](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) component.
    ~~~
    // Examples
      attributes[.UrlQuery] = "q=OpenTelemetry"
    ~~~
    - Note: Sensitive content provided in `url.query` SHOULD be scrubbed when instrumentations can identify it.


      Query string values for the following keys SHOULD be redacted by default and replaced by the value `REDACTED`:

      - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
      - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)
      - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)

      This list is subject to change over time.

      When a query string value is redacted, the query string key SHOULD still be preserved, e.g.
      `q=OpenTelemetry&sig=REDACTED`.
    - Requires: Value type should be `String`
  */
  case urlQuery = "url.query"

  /**
    The highest registered url domain, stripped of the subdomain..
    ~~~
    // Examples
      attributes[.UrlRegisteredDomain] = "example.com"
      attributes[.UrlRegisteredDomain] = "foo.co.uk"
    ~~~
    - Note: This value can be determined precisely with the [public suffix list](https://publicsuffix.org/). For example, the registered domain for `foo.example.com` is `example.com`. Trying to approximate this by simply taking the last two labels will not work well for TLDs such as `co.uk`.
    - Requires: Value type should be `String`
  */
  case urlRegisteredDomain = "url.registered_domain"

  /**
    The [URI scheme](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) component identifying the used protocol..
    ~~~
    // Examples
      attributes[.UrlScheme] = "https"
      attributes[.UrlScheme] = "ftp"
      attributes[.UrlScheme] = "telnet"
    ~~~
    - Requires: Value type should be `String`
  */
  case urlScheme = "url.scheme"

  /**
    The subdomain portion of a fully qualified domain name includes all of the names except the host name under the registered_domain. In a partially qualified domain, or if the qualification level of the full name cannot be determined, subdomain contains all of the names below the registered domain..
    ~~~
    // Examples
      attributes[.UrlSubdomain] = "east"
      attributes[.UrlSubdomain] = "sub2.sub1"
    ~~~
    - Note: The subdomain portion of `www.east.mydomain.co.uk` is `east`. If the domain has multiple levels of subdomain, such as `sub2.sub1.example.com`, the subdomain field should contain `sub2.sub1`, with no trailing period.
    - Requires: Value type should be `String`
  */
  case urlSubdomain = "url.subdomain"

  /**
    The low-cardinality template of an [absolute path reference](https://www.rfc-editor.org/rfc/rfc3986#section-4.2)..
    ~~~
    // Examples
      attributes[.UrlTemplate] = "/users/{id}"
      attributes[.UrlTemplate] = "/users/:id"
      attributes[.UrlTemplate] = "/users?id={id}"
    ~~~
    - Requires: Value type should be `String`
  */
  case urlTemplate = "url.template"

  /**
    The effective top level domain (eTLD), also known as the domain suffix, is the last part of the domain name. For example, the top level domain for example.com is `com`..
    ~~~
    // Examples
      attributes[.UrlTopLevelDomain] = "com"
      attributes[.UrlTopLevelDomain] = "co.uk"
    ~~~
    - Note: This value can be determined precisely with the [public suffix list](https://publicsuffix.org/).
    - Requires: Value type should be `String`
  */
  case urlTopLevelDomain = "url.top_level_domain"

  /**
    User email address..
    ~~~
    // Examples
      attributes[.UserEmail] = "a.einstein@example.com"
    ~~~
    - Requires: Value type should be `String`
  */
  case userEmail = "user.email"

  /**
    User's full name.
    ~~~
    // Examples
      attributes[.UserFullName] = "Albert Einstein"
    ~~~
    - Requires: Value type should be `String`
  */
  case userFullName = "user.full_name"

  /**
    Unique user hash to correlate information for a user in anonymized form..
    ~~~
    // Examples
      attributes[.UserHash] = "364fc68eaf4c8acec74a4e52d7d1feaa"
    ~~~
    - Note: Useful if `user.id` or `user.name` contain confidential information and cannot be used.
    - Requires: Value type should be `String`
  */
  case userHash = "user.hash"

  /**
    Unique identifier of the user..
    ~~~
    // Examples
      attributes[.UserId] = "S-1-5-21-202424912787-2692429404-2351956786-1000"
    ~~~
    - Requires: Value type should be `String`
  */
  case userId = "user.id"

  /**
    Short name or login/username of the user..
    ~~~
    // Examples
      attributes[.UserName] = "a.einstein"
    ~~~
    - Requires: Value type should be `String`
  */
  case userName = "user.name"

  /**
    Array of user roles at the time of the event..
    ~~~
    // Examples
      attributes[.UserRoles] = ["admin", "reporting_user"]
    ~~~
    - Requires: Value type should be `[String]`
  */
  case userRoles = "user.roles"

  /**
    Name of the user-agent extracted from original. Usually refers to the browser's name..
    ~~~
    // Examples
      attributes[.UserAgentName] = "Safari"
      attributes[.UserAgentName] = "YourApp"
    ~~~
    - Note: [Example](https://www.whatsmyua.info) of extracting browser's name from original string. In the case of using a user-agent for non-browser products, such as microservices with multiple names/versions inside the `user_agent.original`, the most significant name SHOULD be selected. In such a scenario it should align with `user_agent.version`
    - Requires: Value type should be `String`
  */
  case userAgentName = "user_agent.name"

  /**
    Value of the [HTTP User-Agent](https://www.rfc-editor.org/rfc/rfc9110.html#field.user-agent) header sent by the client..
    ~~~
    // Examples
      attributes[.UserAgentOriginal] = "CERN-LineMode/2.15 libwww/2.17b3"
      attributes[.UserAgentOriginal] = "Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1"
      attributes[.UserAgentOriginal] = "YourApp/1.0.0 grpc-java-okhttp/1.27.2"
    ~~~
    - Requires: Value type should be `String`
  */
  case userAgentOriginal = "user_agent.original"

  /**
    Human readable operating system name..
    ~~~
    // Examples
      attributes[.UserAgentOsName] = "iOS"
      attributes[.UserAgentOsName] = "Android"
      attributes[.UserAgentOsName] = "Ubuntu"
    ~~~
    - Note: For mapping user agent strings to OS names, libraries such as [ua-parser](https://github.com/ua-parser) can be utilized.
    - Requires: Value type should be `String`
  */
  case userAgentOsName = "user_agent.os.name"

  /**
    The version string of the operating system as defined in [Version Attributes](/docs/resource/README.md#version-attributes)..
    ~~~
    // Examples
      attributes[.UserAgentOsVersion] = "14.2.1"
      attributes[.UserAgentOsVersion] = "18.04.1"
    ~~~
    - Note: For mapping user agent strings to OS versions, libraries such as [ua-parser](https://github.com/ua-parser) can be utilized.
    - Requires: Value type should be `String`
  */
  case userAgentOsVersion = "user_agent.os.version"

  /**
    Specifies the category of synthetic traffic, such as tests or bots..
    - Note: This attribute MAY be derived from the contents of the `user_agent.original` attribute. Components that populate the attribute are responsible for determining what they consider to be synthetic bot or test traffic. This attribute can either be set for self-identification purposes, or on telemetry detected to be generated as a result of a synthetic request. This attribute is useful for distinguishing between genuine client traffic and synthetic traffic generated by bots or tests.
    - Requires: Value should be one of [`SemanticAttributes.UserAgentSyntheticTypeValues`](x-source-tag://otelUserAgentSyntheticTypeValues) (of type `String`)
  */
  case userAgentSyntheticType = "user_agent.synthetic.type"

  /**
    Version of the user-agent extracted from original. Usually refers to the browser's version.
    ~~~
    // Examples
      attributes[.UserAgentVersion] = "14.1.2"
      attributes[.UserAgentVersion] = "1.0.0"
    ~~~
    - Note: [Example](https://www.whatsmyua.info) of extracting browser's version from original string. In the case of using a user-agent for non-browser products, such as microservices with multiple names/versions inside the `user_agent.original`, the most significant version SHOULD be selected. In such a scenario it should align with `user_agent.name`
    - Requires: Value type should be `String`
  */
  case userAgentVersion = "user_agent.version"

  /**
    The type of garbage collection..
    - Requires: Value should be one of [`SemanticAttributes.V8jsGcTypeValues`](x-source-tag://otelV8jsGcTypeValues) (of type `String`)
  */
  case v8jsGcType = "v8js.gc.type"

  /**
    The name of the space type of heap memory..
    - Note: Value can be retrieved from value `space_name` of [`v8.getHeapSpaceStatistics()`](https://nodejs.org/api/v8.html#v8getheapspacestatistics)
    - Requires: Value should be one of [`SemanticAttributes.V8jsHeapSpaceNameValues`](x-source-tag://otelV8jsHeapSpaceNameValues) (of type `String`)
  */
  case v8jsHeapSpaceName = "v8js.heap.space.name"

  /**
    The ID of the change (pull request/merge request/changelist) if applicable. This is usually a unique (within repository) identifier generated by the VCS system..
    ~~~
    // Examples
      attributes[.VcsChangeId] = "123"
    ~~~
    - Requires: Value type should be `String`
  */
  case vcsChangeId = "vcs.change.id"

  /**
    The state of the change (pull request/merge request/changelist)..
    ~~~
    // Examples
      attributes[.VcsChangeState] = open
      attributes[.VcsChangeState] = closed
      attributes[.VcsChangeState] = merged
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.VcsChangeStateValues`](x-source-tag://otelVcsChangeStateValues) (of type `String`)
  */
  case vcsChangeState = "vcs.change.state"

  /**
    The human readable title of the change (pull request/merge request/changelist). This title is often a brief summary of the change and may get merged in to a ref as the commit summary..
    ~~~
    // Examples
      attributes[.VcsChangeTitle] = "Fixes broken thing"
      attributes[.VcsChangeTitle] = "feat: add my new feature"
      attributes[.VcsChangeTitle] = "[chore] update dependency"
    ~~~
    - Requires: Value type should be `String`
  */
  case vcsChangeTitle = "vcs.change.title"

  /**
    The type of line change being measured on a branch or change..
    ~~~
    // Examples
      attributes[.VcsLineChangeType] = added
      attributes[.VcsLineChangeType] = removed
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.VcsLineChangeTypeValues`](x-source-tag://otelVcsLineChangeTypeValues) (of type `String`)
  */
  case vcsLineChangeType = "vcs.line_change.type"

  /**
    The group owner within the version control system..
    ~~~
    // Examples
      attributes[.VcsOwnerName] = "my-org"
      attributes[.VcsOwnerName] = "myteam"
      attributes[.VcsOwnerName] = "business-unit"
    ~~~
    - Requires: Value type should be `String`
  */
  case vcsOwnerName = "vcs.owner.name"

  /**
    The name of the version control system provider..
    ~~~
    // Examples
      attributes[.VcsProviderName] = github
      attributes[.VcsProviderName] = gitlab
      attributes[.VcsProviderName] = gitea
      attributes[.VcsProviderName] = bitbucket
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.VcsProviderNameValues`](x-source-tag://otelVcsProviderNameValues) (of type `String`)
  */
  case vcsProviderName = "vcs.provider.name"

  /**
    The name of the [reference](https://git-scm.com/docs/gitglossary#def_ref) such as **branch** or **tag** in the repository..
    ~~~
    // Examples
      attributes[.VcsRefBaseName] = "my-feature-branch"
      attributes[.VcsRefBaseName] = "tag-1-test"
    ~~~
    - Note: `base` refers to the starting point of a change. For example, `main`
      would be the base reference of type branch if you've created a new
      reference of type branch from it and created new commits.
    - Requires: Value type should be `String`
  */
  case vcsRefBaseName = "vcs.ref.base.name"

  /**
    The revision, literally [revised version](https://www.merriam-webster.com/dictionary/revision), The revision most often refers to a commit object in Git, or a revision number in SVN..
    ~~~
    // Examples
      attributes[.VcsRefBaseRevision] = "9d59409acf479dfa0df1aa568182e43e43df8bbe28d60fcf2bc52e30068802cc"
      attributes[.VcsRefBaseRevision] = "main"
      attributes[.VcsRefBaseRevision] = "123"
      attributes[.VcsRefBaseRevision] = "HEAD"
    ~~~
    - Note: `base` refers to the starting point of a change. For example, `main`
      would be the base reference of type branch if you've created a new
      reference of type branch from it and created new commits. The
      revision can be a full [hash value (see
      glossary)](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf),
      of the recorded change to a ref within a repository pointing to a
      commit [commit](https://git-scm.com/docs/git-commit) object. It does
      not necessarily have to be a hash; it can simply define a [revision
      number](https://svnbook.red-bean.com/en/1.7/svn.tour.revs.specifiers.html)
      which is an integer that is monotonically increasing. In cases where
      it is identical to the `ref.base.name`, it SHOULD still be included.
      It is up to the implementer to decide which value to set as the
      revision based on the VCS system and situational context.
    - Requires: Value type should be `String`
  */
  case vcsRefBaseRevision = "vcs.ref.base.revision"

  /**
    The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository..
    ~~~
    // Examples
      attributes[.VcsRefBaseType] = branch
      attributes[.VcsRefBaseType] = tag
    ~~~
    - Note: `base` refers to the starting point of a change. For example, `main`
      would be the base reference of type branch if you've created a new
      reference of type branch from it and created new commits.
    - Requires: Value should be one of [`SemanticAttributes.VcsRefBaseTypeValues`](x-source-tag://otelVcsRefBaseTypeValues) (of type `String`)
  */
  case vcsRefBaseType = "vcs.ref.base.type"

  /**
    The name of the [reference](https://git-scm.com/docs/gitglossary#def_ref) such as **branch** or **tag** in the repository..
    ~~~
    // Examples
      attributes[.VcsRefHeadName] = "my-feature-branch"
      attributes[.VcsRefHeadName] = "tag-1-test"
    ~~~
    - Note: `head` refers to where you are right now; the current reference at a
      given time.
    - Requires: Value type should be `String`
  */
  case vcsRefHeadName = "vcs.ref.head.name"

  /**
    The revision, literally [revised version](https://www.merriam-webster.com/dictionary/revision), The revision most often refers to a commit object in Git, or a revision number in SVN..
    ~~~
    // Examples
      attributes[.VcsRefHeadRevision] = "9d59409acf479dfa0df1aa568182e43e43df8bbe28d60fcf2bc52e30068802cc"
      attributes[.VcsRefHeadRevision] = "main"
      attributes[.VcsRefHeadRevision] = "123"
      attributes[.VcsRefHeadRevision] = "HEAD"
    ~~~
    - Note: `head` refers to where you are right now; the current reference at a
      given time.The revision can be a full [hash value (see
      glossary)](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf),
      of the recorded change to a ref within a repository pointing to a
      commit [commit](https://git-scm.com/docs/git-commit) object. It does
      not necessarily have to be a hash; it can simply define a [revision
      number](https://svnbook.red-bean.com/en/1.7/svn.tour.revs.specifiers.html)
      which is an integer that is monotonically increasing. In cases where
      it is identical to the `ref.head.name`, it SHOULD still be included.
      It is up to the implementer to decide which value to set as the
      revision based on the VCS system and situational context.
    - Requires: Value type should be `String`
  */
  case vcsRefHeadRevision = "vcs.ref.head.revision"

  /**
    The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository..
    ~~~
    // Examples
      attributes[.VcsRefHeadType] = branch
      attributes[.VcsRefHeadType] = tag
    ~~~
    - Note: `head` refers to where you are right now; the current reference at a
      given time.
    - Requires: Value should be one of [`SemanticAttributes.VcsRefHeadTypeValues`](x-source-tag://otelVcsRefHeadTypeValues) (of type `String`)
  */
  case vcsRefHeadType = "vcs.ref.head.type"

  /**
    The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository..
    ~~~
    // Examples
      attributes[.VcsRefType] = branch
      attributes[.VcsRefType] = tag
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.VcsRefTypeValues`](x-source-tag://otelVcsRefTypeValues) (of type `String`)
  */
  case vcsRefType = "vcs.ref.type"

  /**
    The human readable name of the repository. It SHOULD NOT include any additional identifier like Group/SubGroup in GitLab or organization in GitHub..
    ~~~
    // Examples
      attributes[.VcsRepositoryName] = "semantic-conventions"
      attributes[.VcsRepositoryName] = "my-cool-repo"
    ~~~
    - Note: Due to it only being the name, it can clash with forks of the same
      repository if collecting telemetry across multiple orgs or groups in
      the same backends.
    - Requires: Value type should be `String`
  */
  case vcsRepositoryName = "vcs.repository.name"

  /**
    The [canonical URL](https://support.google.com/webmasters/answer/10347851?hl=en#:~:text=A%20canonical%20URL%20is%20the,Google%20chooses%20one%20as%20canonical.) of the repository providing the complete HTTP(S) address in order to locate and identify the repository through a browser..
    ~~~
    // Examples
      attributes[.VcsRepositoryUrlFull] = "https://github.com/opentelemetry/open-telemetry-collector-contrib"
      attributes[.VcsRepositoryUrlFull] = "https://gitlab.com/my-org/my-project/my-projects-project/repo"
    ~~~
    - Note: In Git Version Control Systems, the canonical URL SHOULD NOT include
      the `.git` extension.
    - Requires: Value type should be `String`
  */
  case vcsRepositoryUrlFull = "vcs.repository.url.full"

  /**
    The type of revision comparison..
    ~~~
    // Examples
      attributes[.VcsRevisionDeltaDirection] = ahead
      attributes[.VcsRevisionDeltaDirection] = behind
    ~~~
    - Requires: Value should be one of [`SemanticAttributes.VcsRevisionDeltaDirectionValues`](x-source-tag://otelVcsRevisionDeltaDirectionValues) (of type `String`)
  */
  case vcsRevisionDeltaDirection = "vcs.revision_delta.direction"

  /**
    Additional description of the web engine (e.g. detailed version and edition information)..
    ~~~
    // Examples
      attributes[.WebengineDescription] = "WildFly Full 21.0.0.Final (WildFly Core 13.0.1.Final) - 2.2.2.Final"
    ~~~
    - Requires: Value type should be `String`
  */
  case webengineDescription = "webengine.description"

  /**
    The name of the web engine..
    ~~~
    // Examples
      attributes[.WebengineName] = "WildFly"
    ~~~
    - Requires: Value type should be `String`
  */
  case webengineName = "webengine.name"

  /**
    The version of the web engine..
    ~~~
    // Examples
      attributes[.WebengineVersion] = "21.0.0"
    ~~~
    - Requires: Value type should be `String`
  */
  case webengineVersion = "webengine.version"

  /**
    The System Management Facility (SMF) Identifier uniquely identified a z/OS system within a SYSPLEX or mainframe environment and is used for system and performance analysis..
    ~~~
    // Examples
      attributes[.ZosSmfId] = "SYS1"
    ~~~
    - Requires: Value type should be `String`
  */
  case zosSmfId = "zos.smf.id"

  /**
    The name of the SYSPLEX to which the z/OS system belongs too..
    ~~~
    // Examples
      attributes[.ZosSysplexName] = "SYSPLEX1"
    ~~~
    - Requires: Value type should be `String`
  */
  case zosSysplexName = "zos.sysplex.name"

// MARK: - Manual Definitions
// Some definitions have not yet been added to the YAML which generates this script.
// As such as we have some manually defined cases.

/**
An exception event **MUST** be called "exception" as per the [specification](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/exceptions.md).
*/
case exception = "exception";

/** 
  The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
*/
/// - Tag: otelCassandraConsistencyLevelValues
public struct CassandraConsistencyLevelValues: CustomStringConvertible {
  // All
  public static let All = CassandraConsistencyLevelValues("all") 
  // Each Quorum
  public static let EachQuorum = CassandraConsistencyLevelValues("each_quorum") 
  // Quorum
  public static let Quorum = CassandraConsistencyLevelValues("quorum") 
  // Local Quorum
  public static let LocalQuorum = CassandraConsistencyLevelValues("local_quorum") 
  // One
  public static let One = CassandraConsistencyLevelValues("one") 
  // Two
  public static let Two = CassandraConsistencyLevelValues("two") 
  // Three
  public static let Three = CassandraConsistencyLevelValues("three") 
  // Local One
  public static let LocalOne = CassandraConsistencyLevelValues("local_one") 
  // Any
  public static let Any = CassandraConsistencyLevelValues("any") 
  // Serial
  public static let Serial = CassandraConsistencyLevelValues("serial") 
  // Local Serial
  public static let LocalSerial = CassandraConsistencyLevelValues("local_serial") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The mode of the CPU
*/
/// - Tag: otelCpuModeValues
public struct CpuModeValues: CustomStringConvertible {
  // User
  public static let User = CpuModeValues("user") 
  // System
  public static let System = CpuModeValues("system") 
  // Nice
  public static let Nice = CpuModeValues("nice") 
  // Idle
  public static let Idle = CpuModeValues("idle") 
  // IO Wait
  public static let Iowait = CpuModeValues("iowait") 
  // Interrupt
  public static let Interrupt = CpuModeValues("interrupt") 
  // Steal
  public static let Steal = CpuModeValues("steal") 
  // Kernel
  public static let Kernel = CpuModeValues("kernel") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Value of the garbage collector collection generation.
*/
/// - Tag: otelCpythonGcGenerationValues
public struct CpythonGcGenerationValues: CustomStringConvertible {
  // Generation 0
  public static let Generation0 = CpythonGcGenerationValues(0) 
  // Generation 1
  public static let Generation1 = CpythonGcGenerationValues(1) 
  // Generation 2
  public static let Generation2 = CpythonGcGenerationValues(2) 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The state of a connection in the pool
*/
/// - Tag: otelDbClientConnectionStateValues
public struct DbClientConnectionStateValues: CustomStringConvertible {
  public static let Idle = DbClientConnectionStateValues("idle") 
  public static let Used = DbClientConnectionStateValues("used") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The database management system (DBMS) product as identified by the client instrumentation.
*/
/// - Tag: otelDbSystemNameValues
public struct DbSystemNameValues: CustomStringConvertible {
  // Some other SQL database. Fallback only.
  public static let OtherSql = DbSystemNameValues("other_sql") 
  // [Adabas (Adaptable Database System)](https://documentation.softwareag.com/?pf=adabas)
  public static let SoftwareagAdabas = DbSystemNameValues("softwareag.adabas") 
  // [Actian Ingres](https://www.actian.com/databases/ingres/)
  public static let ActianIngres = DbSystemNameValues("actian.ingres") 
  // [Amazon DynamoDB](https://aws.amazon.com/pm/dynamodb/)
  public static let AwsDynamodb = DbSystemNameValues("aws.dynamodb") 
  // [Amazon Redshift](https://aws.amazon.com/redshift/)
  public static let AwsRedshift = DbSystemNameValues("aws.redshift") 
  // [Azure Cosmos DB](https://learn.microsoft.com/azure/cosmos-db)
  public static let AzureCosmosdb = DbSystemNameValues("azure.cosmosdb") 
  // [InterSystems Caché](https://www.intersystems.com/products/cache/)
  public static let IntersystemsCache = DbSystemNameValues("intersystems.cache") 
  // [Apache Cassandra](https://cassandra.apache.org/)
  public static let Cassandra = DbSystemNameValues("cassandra") 
  // [ClickHouse](https://clickhouse.com/)
  public static let Clickhouse = DbSystemNameValues("clickhouse") 
  // [CockroachDB](https://www.cockroachlabs.com/)
  public static let Cockroachdb = DbSystemNameValues("cockroachdb") 
  // [Couchbase](https://www.couchbase.com/)
  public static let Couchbase = DbSystemNameValues("couchbase") 
  // [Apache CouchDB](https://couchdb.apache.org/)
  public static let Couchdb = DbSystemNameValues("couchdb") 
  // [Apache Derby](https://db.apache.org/derby/)
  public static let Derby = DbSystemNameValues("derby") 
  // [Elasticsearch](https://www.elastic.co/elasticsearch)
  public static let Elasticsearch = DbSystemNameValues("elasticsearch") 
  // [Firebird](https://www.firebirdsql.org/)
  public static let Firebirdsql = DbSystemNameValues("firebirdsql") 
  // [Google Cloud Spanner](https://cloud.google.com/spanner)
  public static let GcpSpanner = DbSystemNameValues("gcp.spanner") 
  // [Apache Geode](https://geode.apache.org/)
  public static let Geode = DbSystemNameValues("geode") 
  // [H2 Database](https://h2database.com/)
  public static let H2database = DbSystemNameValues("h2database") 
  // [Apache HBase](https://hbase.apache.org/)
  public static let Hbase = DbSystemNameValues("hbase") 
  // [Apache Hive](https://hive.apache.org/)
  public static let Hive = DbSystemNameValues("hive") 
  // [HyperSQL Database](https://hsqldb.org/)
  public static let Hsqldb = DbSystemNameValues("hsqldb") 
  // [IBM Db2](https://www.ibm.com/db2)
  public static let IbmDb2 = DbSystemNameValues("ibm.db2") 
  // [IBM Informix](https://www.ibm.com/products/informix)
  public static let IbmInformix = DbSystemNameValues("ibm.informix") 
  // [IBM Netezza](https://www.ibm.com/products/netezza)
  public static let IbmNetezza = DbSystemNameValues("ibm.netezza") 
  // [InfluxDB](https://www.influxdata.com/)
  public static let Influxdb = DbSystemNameValues("influxdb") 
  // [Instant](https://www.instantdb.com/)
  public static let Instantdb = DbSystemNameValues("instantdb") 
  // [MariaDB](https://mariadb.org/)
  public static let Mariadb = DbSystemNameValues("mariadb") 
  // [Memcached](https://memcached.org/)
  public static let Memcached = DbSystemNameValues("memcached") 
  // [MongoDB](https://www.mongodb.com/)
  public static let Mongodb = DbSystemNameValues("mongodb") 
  // [Microsoft SQL Server](https://www.microsoft.com/sql-server)
  public static let MicrosoftSqlServer = DbSystemNameValues("microsoft.sql_server") 
  // [MySQL](https://www.mysql.com/)
  public static let Mysql = DbSystemNameValues("mysql") 
  // [Neo4j](https://neo4j.com/)
  public static let Neo4j = DbSystemNameValues("neo4j") 
  // [OpenSearch](https://opensearch.org/)
  public static let Opensearch = DbSystemNameValues("opensearch") 
  // [Oracle Database](https://www.oracle.com/database/)
  public static let OracleDb = DbSystemNameValues("oracle.db") 
  // [PostgreSQL](https://www.postgresql.org/)
  public static let Postgresql = DbSystemNameValues("postgresql") 
  // [Redis](https://redis.io/)
  public static let Redis = DbSystemNameValues("redis") 
  // [SAP HANA](https://www.sap.com/products/technology-platform/hana/what-is-sap-hana.html)
  public static let SapHana = DbSystemNameValues("sap.hana") 
  // [SAP MaxDB](https://maxdb.sap.com/)
  public static let SapMaxdb = DbSystemNameValues("sap.maxdb") 
  // [SQLite](https://www.sqlite.org/)
  public static let Sqlite = DbSystemNameValues("sqlite") 
  // [Teradata](https://www.teradata.com/)
  public static let Teradata = DbSystemNameValues("teradata") 
  // [Trino](https://trino.io/)
  public static let Trino = DbSystemNameValues("trino") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The disk IO operation direction.
*/
/// - Tag: otelDiskIoDirectionValues
public struct DiskIoDirectionValues: CustomStringConvertible {
  public static let Read = DiskIoDirectionValues("read") 
  public static let Write = DiskIoDirectionValues("write") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Describes a class of error the operation ended with.
*/
/// - Tag: otelErrorTypeValues
public struct ErrorTypeValues: CustomStringConvertible {
  // A fallback error value to be used when the instrumentation doesn't define a custom value.
  public static let Other = ErrorTypeValues("_OTHER") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Two-letter code representing continent’s name.
*/
/// - Tag: otelGeoContinentCodeValues
public struct GeoContinentCodeValues: CustomStringConvertible {
  // Africa
  public static let Af = GeoContinentCodeValues("AF") 
  // Antarctica
  public static let An = GeoContinentCodeValues("AN") 
  // Asia
  public static let As = GeoContinentCodeValues("AS") 
  // Europe
  public static let Eu = GeoContinentCodeValues("EU") 
  // North America
  public static let Na = GeoContinentCodeValues("NA") 
  // Oceania
  public static let Oc = GeoContinentCodeValues("OC") 
  // South America
  public static let Sa = GeoContinentCodeValues("SA") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of memory.
*/
/// - Tag: otelGoMemoryTypeValues
public struct GoMemoryTypeValues: CustomStringConvertible {
  // Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.
  public static let Stack = GoMemoryTypeValues("stack") 
  // Memory used by the Go runtime, excluding other categories of memory usage described in this enumeration.
  public static let Other = GoMemoryTypeValues("other") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of the operation being executed.
*/
/// - Tag: otelGraphqlOperationTypeValues
public struct GraphqlOperationTypeValues: CustomStringConvertible {
  // GraphQL query
  public static let Query = GraphqlOperationTypeValues("query") 
  // GraphQL mutation
  public static let Mutation = GraphqlOperationTypeValues("mutation") 
  // GraphQL subscription
  public static let Subscription = GraphqlOperationTypeValues("subscription") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The CPU architecture the host system is running on.
*/
/// - Tag: otelHostArchValues
public struct HostArchValues: CustomStringConvertible {
  // AMD64
  public static let Amd64 = HostArchValues("amd64") 
  // ARM32
  public static let Arm32 = HostArchValues("arm32") 
  // ARM64
  public static let Arm64 = HostArchValues("arm64") 
  // Itanium
  public static let Ia64 = HostArchValues("ia64") 
  // 32-bit PowerPC
  public static let Ppc32 = HostArchValues("ppc32") 
  // 64-bit PowerPC
  public static let Ppc64 = HostArchValues("ppc64") 
  // IBM z/Architecture
  public static let S390x = HostArchValues("s390x") 
  // 32-bit x86
  public static let X86 = HostArchValues("x86") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  State of the HTTP connection in the HTTP connection pool.
*/
/// - Tag: otelHttpConnectionStateValues
public struct HttpConnectionStateValues: CustomStringConvertible {
  // active state.
  public static let Active = HttpConnectionStateValues("active") 
  // idle state.
  public static let Idle = HttpConnectionStateValues("idle") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  HTTP request method.
*/
/// - Tag: otelHttpRequestMethodValues
public struct HttpRequestMethodValues: CustomStringConvertible {
  // CONNECT method.
  public static let Connect = HttpRequestMethodValues("CONNECT") 
  // DELETE method.
  public static let Delete = HttpRequestMethodValues("DELETE") 
  // GET method.
  public static let Get = HttpRequestMethodValues("GET") 
  // HEAD method.
  public static let Head = HttpRequestMethodValues("HEAD") 
  // OPTIONS method.
  public static let Options = HttpRequestMethodValues("OPTIONS") 
  // PATCH method.
  public static let Patch = HttpRequestMethodValues("PATCH") 
  // POST method.
  public static let Post = HttpRequestMethodValues("POST") 
  // PUT method.
  public static let Put = HttpRequestMethodValues("PUT") 
  // TRACE method.
  public static let Trace = HttpRequestMethodValues("TRACE") 
  // Any HTTP method that the instrumentation has no prior knowledge of.
  public static let Other = HttpRequestMethodValues("_OTHER") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The current state of the battery
*/
/// - Tag: otelHwBatteryStateValues
public struct HwBatteryStateValues: CustomStringConvertible {
  // Charging
  public static let Charging = HwBatteryStateValues("charging") 
  // Discharging
  public static let Discharging = HwBatteryStateValues("discharging") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Type of task the GPU is performing
*/
/// - Tag: otelHwGpuTaskValues
public struct HwGpuTaskValues: CustomStringConvertible {
  // Decoder
  public static let Decoder = HwGpuTaskValues("decoder") 
  // Encoder
  public static let Encoder = HwGpuTaskValues("encoder") 
  // General
  public static let General = HwGpuTaskValues("general") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Type of limit for hardware components
*/
/// - Tag: otelHwLimitTypeValues
public struct HwLimitTypeValues: CustomStringConvertible {
  // Critical
  public static let Critical = HwLimitTypeValues("critical") 
  // Degraded
  public static let Degraded = HwLimitTypeValues("degraded") 
  // High Critical
  public static let HighCritical = HwLimitTypeValues("high.critical") 
  // High Degraded
  public static let HighDegraded = HwLimitTypeValues("high.degraded") 
  // Low Critical
  public static let LowCritical = HwLimitTypeValues("low.critical") 
  // Low Degraded
  public static let LowDegraded = HwLimitTypeValues("low.degraded") 
  // Maximum
  public static let Max = HwLimitTypeValues("max") 
  // Throttled
  public static let Throttled = HwLimitTypeValues("throttled") 
  // Turbo
  public static let Turbo = HwLimitTypeValues("turbo") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  State of the logical disk space usage
*/
/// - Tag: otelHwLogicalDiskStateValues
public struct HwLogicalDiskStateValues: CustomStringConvertible {
  // Used
  public static let Used = HwLogicalDiskStateValues("used") 
  // Free
  public static let Free = HwLogicalDiskStateValues("free") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  State of the physical disk endurance utilization
*/
/// - Tag: otelHwPhysicalDiskStateValues
public struct HwPhysicalDiskStateValues: CustomStringConvertible {
  // Remaining
  public static let Remaining = HwPhysicalDiskStateValues("remaining") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The current state of the component
*/
/// - Tag: otelHwStateValues
public struct HwStateValues: CustomStringConvertible {
  // Degraded
  public static let Degraded = HwStateValues("degraded") 
  // Failed
  public static let Failed = HwStateValues("failed") 
  // Needs Cleaning
  public static let NeedsCleaning = HwStateValues("needs_cleaning") 
  // OK
  public static let Ok = HwStateValues("ok") 
  // Predicted Failure
  public static let PredictedFailure = HwStateValues("predicted_failure") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Type of tape drive operation
*/
/// - Tag: otelHwTapeDriveOperationTypeValues
public struct HwTapeDriveOperationTypeValues: CustomStringConvertible {
  // Mount
  public static let Mount = HwTapeDriveOperationTypeValues("mount") 
  // Unmount
  public static let Unmount = HwTapeDriveOperationTypeValues("unmount") 
  // Clean
  public static let Clean = HwTapeDriveOperationTypeValues("clean") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Type of the component
*/
/// - Tag: otelHwTypeValues
public struct HwTypeValues: CustomStringConvertible {
  // Battery
  public static let Battery = HwTypeValues("battery") 
  // CPU
  public static let Cpu = HwTypeValues("cpu") 
  // Disk controller
  public static let DiskController = HwTypeValues("disk_controller") 
  // Enclosure
  public static let Enclosure = HwTypeValues("enclosure") 
  // Fan
  public static let Fan = HwTypeValues("fan") 
  // GPU
  public static let Gpu = HwTypeValues("gpu") 
  // Logical disk
  public static let LogicalDisk = HwTypeValues("logical_disk") 
  // Memory
  public static let Memory = HwTypeValues("memory") 
  // Network
  public static let Network = HwTypeValues("network") 
  // Physical disk
  public static let PhysicalDisk = HwTypeValues("physical_disk") 
  // Power supply
  public static let PowerSupply = HwTypeValues("power_supply") 
  // Tape drive
  public static let TapeDrive = HwTypeValues("tape_drive") 
  // Temperature
  public static let Temperature = HwTypeValues("temperature") 
  // Voltage
  public static let Voltage = HwTypeValues("voltage") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  This attribute represents the state of the application.
*/
/// - Tag: otelIosAppStateValues
public struct IosAppStateValues: CustomStringConvertible {
  // The app has become `active`. Associated with UIKit notification `applicationDidBecomeActive`.
  public static let Active = IosAppStateValues("active") 
  // The app is now `inactive`. Associated with UIKit notification `applicationWillResignActive`.
  public static let Inactive = IosAppStateValues("inactive") 
  // The app is now in the background. This value is associated with UIKit notification `applicationDidEnterBackground`.
  public static let Background = IosAppStateValues("background") 
  // The app is now in the foreground. This value is associated with UIKit notification `applicationWillEnterForeground`.
  public static let Foreground = IosAppStateValues("foreground") 
  // The app is about to terminate. Associated with UIKit notification `applicationWillTerminate`.
  public static let Terminate = IosAppStateValues("terminate") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The Linux Slab memory state
*/
/// - Tag: otelLinuxMemorySlabStateValues
public struct LinuxMemorySlabStateValues: CustomStringConvertible {
  public static let Reclaimable = LinuxMemorySlabStateValues("reclaimable") 
  public static let Unreclaimable = LinuxMemorySlabStateValues("unreclaimable") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The stream associated with the log. See below for a list of well-known values.
*/
/// - Tag: otelLogIostreamValues
public struct LogIostreamValues: CustomStringConvertible {
  // Logs from stdout stream
  public static let Stdout = LogIostreamValues("stdout") 
  // Events from stderr stream
  public static let Stderr = LogIostreamValues("stderr") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  A string identifying the type of the messaging operation.
*/
/// - Tag: otelMessagingOperationTypeValues
public struct MessagingOperationTypeValues: CustomStringConvertible {
  // A message is created. "Create" spans always refer to a single message and are used to provide a unique creation context for messages in batch sending scenarios.
  public static let Create = MessagingOperationTypeValues("create") 
  // One or more messages are provided for sending to an intermediary. If a single message is sent, the context of the "Send" span can be used as the creation context and no "Create" span needs to be created.
  public static let Send = MessagingOperationTypeValues("send") 
  // One or more messages are requested by a consumer. This operation refers to pull-based scenarios, where consumers explicitly call methods of messaging SDKs to receive messages.
  public static let Receive = MessagingOperationTypeValues("receive") 
  // One or more messages are processed by a consumer.
  public static let Process = MessagingOperationTypeValues("process") 
  // One or more messages are settled.
  public static let Settle = MessagingOperationTypeValues("settle") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Model of message consumption. This only applies to consumer spans.
*/
/// - Tag: otelMessagingRocketmqConsumptionModelValues
public struct MessagingRocketmqConsumptionModelValues: CustomStringConvertible {
  // Clustering consumption model
  public static let Clustering = MessagingRocketmqConsumptionModelValues("clustering") 
  // Broadcasting consumption model
  public static let Broadcasting = MessagingRocketmqConsumptionModelValues("broadcasting") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Type of message.
*/
/// - Tag: otelMessagingRocketmqMessageTypeValues
public struct MessagingRocketmqMessageTypeValues: CustomStringConvertible {
  // Normal message
  public static let Normal = MessagingRocketmqMessageTypeValues("normal") 
  // FIFO message
  public static let Fifo = MessagingRocketmqMessageTypeValues("fifo") 
  // Delay message
  public static let Delay = MessagingRocketmqMessageTypeValues("delay") 
  // Transaction message
  public static let Transaction = MessagingRocketmqMessageTypeValues("transaction") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Describes the [settlement type](https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock).
*/
/// - Tag: otelMessagingServicebusDispositionStatusValues
public struct MessagingServicebusDispositionStatusValues: CustomStringConvertible {
  // Message is completed
  public static let Complete = MessagingServicebusDispositionStatusValues("complete") 
  // Message is abandoned
  public static let Abandon = MessagingServicebusDispositionStatusValues("abandon") 
  // Message is sent to dead letter queue
  public static let DeadLetter = MessagingServicebusDispositionStatusValues("dead_letter") 
  // Message is deferred
  public static let Defer = MessagingServicebusDispositionStatusValues("defer") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The messaging system as identified by the client instrumentation.
*/
/// - Tag: otelMessagingSystemValues
public struct MessagingSystemValues: CustomStringConvertible {
  // Apache ActiveMQ
  public static let Activemq = MessagingSystemValues("activemq") 
  // Amazon Simple Notification Service (SNS)
  public static let AwsSns = MessagingSystemValues("aws.sns") 
  // Amazon Simple Queue Service (SQS)
  public static let AwsSqs = MessagingSystemValues("aws_sqs") 
  // Azure Event Grid
  public static let Eventgrid = MessagingSystemValues("eventgrid") 
  // Azure Event Hubs
  public static let Eventhubs = MessagingSystemValues("eventhubs") 
  // Azure Service Bus
  public static let Servicebus = MessagingSystemValues("servicebus") 
  // Google Cloud Pub/Sub
  public static let GcpPubsub = MessagingSystemValues("gcp_pubsub") 
  // Java Message Service
  public static let Jms = MessagingSystemValues("jms") 
  // Apache Kafka
  public static let Kafka = MessagingSystemValues("kafka") 
  // RabbitMQ
  public static let Rabbitmq = MessagingSystemValues("rabbitmq") 
  // Apache RocketMQ
  public static let Rocketmq = MessagingSystemValues("rocketmq") 
  // Apache Pulsar
  public static let Pulsar = MessagingSystemValues("pulsar") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The state of network connection
*/
/// - Tag: otelNetworkConnectionStateValues
public struct NetworkConnectionStateValues: CustomStringConvertible {
  public static let Closed = NetworkConnectionStateValues("closed") 
  public static let CloseWait = NetworkConnectionStateValues("close_wait") 
  public static let Closing = NetworkConnectionStateValues("closing") 
  public static let Established = NetworkConnectionStateValues("established") 
  public static let FinWait1 = NetworkConnectionStateValues("fin_wait_1") 
  public static let FinWait2 = NetworkConnectionStateValues("fin_wait_2") 
  public static let LastAck = NetworkConnectionStateValues("last_ack") 
  public static let Listen = NetworkConnectionStateValues("listen") 
  public static let SynReceived = NetworkConnectionStateValues("syn_received") 
  public static let SynSent = NetworkConnectionStateValues("syn_sent") 
  public static let TimeWait = NetworkConnectionStateValues("time_wait") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
*/
/// - Tag: otelNetworkConnectionSubtypeValues
public struct NetworkConnectionSubtypeValues: CustomStringConvertible {
  // GPRS
  public static let Gprs = NetworkConnectionSubtypeValues("gprs") 
  // EDGE
  public static let Edge = NetworkConnectionSubtypeValues("edge") 
  // UMTS
  public static let Umts = NetworkConnectionSubtypeValues("umts") 
  // CDMA
  public static let Cdma = NetworkConnectionSubtypeValues("cdma") 
  // EVDO Rel. 0
  public static let Evdo0 = NetworkConnectionSubtypeValues("evdo_0") 
  // EVDO Rev. A
  public static let EvdoA = NetworkConnectionSubtypeValues("evdo_a") 
  // CDMA2000 1XRTT
  public static let Cdma20001xrtt = NetworkConnectionSubtypeValues("cdma2000_1xrtt") 
  // HSDPA
  public static let Hsdpa = NetworkConnectionSubtypeValues("hsdpa") 
  // HSUPA
  public static let Hsupa = NetworkConnectionSubtypeValues("hsupa") 
  // HSPA
  public static let Hspa = NetworkConnectionSubtypeValues("hspa") 
  // IDEN
  public static let Iden = NetworkConnectionSubtypeValues("iden") 
  // EVDO Rev. B
  public static let EvdoB = NetworkConnectionSubtypeValues("evdo_b") 
  // LTE
  public static let Lte = NetworkConnectionSubtypeValues("lte") 
  // EHRPD
  public static let Ehrpd = NetworkConnectionSubtypeValues("ehrpd") 
  // HSPAP
  public static let Hspap = NetworkConnectionSubtypeValues("hspap") 
  // GSM
  public static let Gsm = NetworkConnectionSubtypeValues("gsm") 
  // TD-SCDMA
  public static let TdScdma = NetworkConnectionSubtypeValues("td_scdma") 
  // IWLAN
  public static let Iwlan = NetworkConnectionSubtypeValues("iwlan") 
  // 5G NR (New Radio)
  public static let Nr = NetworkConnectionSubtypeValues("nr") 
  // 5G NRNSA (New Radio Non-Standalone)
  public static let Nrnsa = NetworkConnectionSubtypeValues("nrnsa") 
  // LTE CA
  public static let LteCa = NetworkConnectionSubtypeValues("lte_ca") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The internet connection type.
*/
/// - Tag: otelNetworkConnectionTypeValues
public struct NetworkConnectionTypeValues: CustomStringConvertible {
  public static let Wifi = NetworkConnectionTypeValues("wifi") 
  public static let Wired = NetworkConnectionTypeValues("wired") 
  public static let Cell = NetworkConnectionTypeValues("cell") 
  public static let Unavailable = NetworkConnectionTypeValues("unavailable") 
  public static let Unknown = NetworkConnectionTypeValues("unknown") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The network IO operation direction.
*/
/// - Tag: otelNetworkIoDirectionValues
public struct NetworkIoDirectionValues: CustomStringConvertible {
  public static let Transmit = NetworkIoDirectionValues("transmit") 
  public static let Receive = NetworkIoDirectionValues("receive") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  [OSI transport layer](https://wikipedia.org/wiki/Transport_layer) or [inter-process communication method](https://wikipedia.org/wiki/Inter-process_communication).
*/
/// - Tag: otelNetworkTransportValues
public struct NetworkTransportValues: CustomStringConvertible {
  // TCP
  public static let Tcp = NetworkTransportValues("tcp") 
  // UDP
  public static let Udp = NetworkTransportValues("udp") 
  // Named or anonymous pipe.
  public static let Pipe = NetworkTransportValues("pipe") 
  // Unix domain socket
  public static let Unix = NetworkTransportValues("unix") 
  // QUIC
  public static let Quic = NetworkTransportValues("quic") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  [OSI network layer](https://wikipedia.org/wiki/Network_layer) or non-OSI equivalent.
*/
/// - Tag: otelNetworkTypeValues
public struct NetworkTypeValues: CustomStringConvertible {
  // IPv4
  public static let Ipv4 = NetworkTypeValues("ipv4") 
  // IPv6
  public static let Ipv6 = NetworkTypeValues("ipv6") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The state of event loop time.
*/
/// - Tag: otelNodejsEventloopStateValues
public struct NodejsEventloopStateValues: CustomStringConvertible {
  // Active time.
  public static let Active = NodejsEventloopStateValues("active") 
  // Idle time.
  public static let Idle = NodejsEventloopStateValues("idle") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The service tier requested. May be a specific tier, default, or auto.
*/
/// - Tag: otelOpenaiRequestServiceTierValues
public struct OpenaiRequestServiceTierValues: CustomStringConvertible {
  // The system will utilize scale tier credits until they are exhausted.
  public static let Auto = OpenaiRequestServiceTierValues("auto") 
  // The system will utilize the default scale tier.
  public static let Default = OpenaiRequestServiceTierValues("default") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Parent-child Reference type
*/
/// - Tag: otelOpentracingRefTypeValues
public struct OpentracingRefTypeValues: CustomStringConvertible {
  // The parent Span depends on the child Span in some capacity
  public static let ChildOf = OpentracingRefTypeValues("child_of") 
  // The parent Span doesn't depend in any way on the result of the child Span
  public static let FollowsFrom = OpentracingRefTypeValues("follows_from") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The operating system type.
*/
/// - Tag: otelOsTypeValues
public struct OsTypeValues: CustomStringConvertible {
  // Microsoft Windows
  public static let Windows = OsTypeValues("windows") 
  // Linux
  public static let Linux = OsTypeValues("linux") 
  // Apple Darwin
  public static let Darwin = OsTypeValues("darwin") 
  // FreeBSD
  public static let Freebsd = OsTypeValues("freebsd") 
  // NetBSD
  public static let Netbsd = OsTypeValues("netbsd") 
  // OpenBSD
  public static let Openbsd = OsTypeValues("openbsd") 
  // DragonFly BSD
  public static let Dragonflybsd = OsTypeValues("dragonflybsd") 
  // HP-UX (Hewlett Packard Unix)
  public static let Hpux = OsTypeValues("hpux") 
  // AIX (Advanced Interactive eXecutive)
  public static let Aix = OsTypeValues("aix") 
  // SunOS, Oracle Solaris
  public static let Solaris = OsTypeValues("solaris") 
  // IBM z/OS
  public static let Zos = OsTypeValues("zos") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  A name identifying the type of the OpenTelemetry component.
*/
/// - Tag: otelOtelComponentTypeValues
public struct OtelComponentTypeValues: CustomStringConvertible {
  // The builtin SDK batching span processor
  public static let BatchingSpanProcessor = OtelComponentTypeValues("batching_span_processor") 
  // The builtin SDK simple span processor
  public static let SimpleSpanProcessor = OtelComponentTypeValues("simple_span_processor") 
  // The builtin SDK batching log record processor
  public static let BatchingLogProcessor = OtelComponentTypeValues("batching_log_processor") 
  // The builtin SDK simple log record processor
  public static let SimpleLogProcessor = OtelComponentTypeValues("simple_log_processor") 
  // OTLP span exporter over gRPC with protobuf serialization
  public static let OtlpGrpcSpanExporter = OtelComponentTypeValues("otlp_grpc_span_exporter") 
  // OTLP span exporter over HTTP with protobuf serialization
  public static let OtlpHttpSpanExporter = OtelComponentTypeValues("otlp_http_span_exporter") 
  // OTLP span exporter over HTTP with JSON serialization
  public static let OtlpHttpJsonSpanExporter = OtelComponentTypeValues("otlp_http_json_span_exporter") 
  // Zipkin span exporter over HTTP
  public static let ZipkinHttpSpanExporter = OtelComponentTypeValues("zipkin_http_span_exporter") 
  // OTLP log record exporter over gRPC with protobuf serialization
  public static let OtlpGrpcLogExporter = OtelComponentTypeValues("otlp_grpc_log_exporter") 
  // OTLP log record exporter over HTTP with protobuf serialization
  public static let OtlpHttpLogExporter = OtelComponentTypeValues("otlp_http_log_exporter") 
  // OTLP log record exporter over HTTP with JSON serialization
  public static let OtlpHttpJsonLogExporter = OtelComponentTypeValues("otlp_http_json_log_exporter") 
  // The builtin SDK periodically exporting metric reader
  public static let PeriodicMetricReader = OtelComponentTypeValues("periodic_metric_reader") 
  // OTLP metric exporter over gRPC with protobuf serialization
  public static let OtlpGrpcMetricExporter = OtelComponentTypeValues("otlp_grpc_metric_exporter") 
  // OTLP metric exporter over HTTP with protobuf serialization
  public static let OtlpHttpMetricExporter = OtelComponentTypeValues("otlp_http_metric_exporter") 
  // OTLP metric exporter over HTTP with JSON serialization
  public static let OtlpHttpJsonMetricExporter = OtelComponentTypeValues("otlp_http_json_metric_exporter") 
  // Prometheus metric exporter over HTTP with the default text-based format
  public static let PrometheusHttpTextMetricExporter = OtelComponentTypeValues("prometheus_http_text_metric_exporter") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Determines whether the span has a parent span, and if so, [whether it is a remote parent](https://opentelemetry.io/docs/specs/otel/trace/api/#isremote)
*/
/// - Tag: otelOtelSpanParentOriginValues
public struct OtelSpanParentOriginValues: CustomStringConvertible {
  // The span does not have a parent, it is a root span
  public static let None = OtelSpanParentOriginValues("none") 
  // The span has a parent and the parent's span context [isRemote()](https://opentelemetry.io/docs/specs/otel/trace/api/#isremote) is false
  public static let Local = OtelSpanParentOriginValues("local") 
  // The span has a parent and the parent's span context [isRemote()](https://opentelemetry.io/docs/specs/otel/trace/api/#isremote) is true
  public static let Remote = OtelSpanParentOriginValues("remote") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The result value of the sampler for this span
*/
/// - Tag: otelOtelSpanSamplingResultValues
public struct OtelSpanSamplingResultValues: CustomStringConvertible {
  // The span is not sampled and not recording
  public static let Drop = OtelSpanSamplingResultValues("DROP") 
  // The span is not sampled, but recording
  public static let RecordOnly = OtelSpanSamplingResultValues("RECORD_ONLY") 
  // The span is sampled and recording
  public static let RecordAndSample = OtelSpanSamplingResultValues("RECORD_AND_SAMPLE") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Name of the code, either "OK" or "ERROR". MUST NOT be set if the status code is UNSET.
*/
/// - Tag: otelOtelStatusCodeValues
public struct OtelStatusCodeValues: CustomStringConvertible {
  // The operation has been validated by an Application developer or Operator to have completed successfully.
  public static let Ok = OtelStatusCodeValues("OK") 
  // The operation contains an error.
  public static let Error = OtelStatusCodeValues("ERROR") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Specifies whether the context switches for this data point were voluntary or involuntary.
*/
/// - Tag: otelProcessContextSwitchTypeValues
public struct ProcessContextSwitchTypeValues: CustomStringConvertible {
  public static let Voluntary = ProcessContextSwitchTypeValues("voluntary") 
  public static let Involuntary = ProcessContextSwitchTypeValues("involuntary") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of page fault for this data point. Type `major` is for major/hard page faults, and `minor` is for minor/soft page faults.
*/
/// - Tag: otelProcessPagingFaultTypeValues
public struct ProcessPagingFaultTypeValues: CustomStringConvertible {
  public static let Major = ProcessPagingFaultTypeValues("major") 
  public static let Minor = ProcessPagingFaultTypeValues("minor") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Describes the interpreter or compiler of a single frame.
*/
/// - Tag: otelProfileFrameTypeValues
public struct ProfileFrameTypeValues: CustomStringConvertible {
  // [.NET](https://wikipedia.org/wiki/.NET)
  public static let Dotnet = ProfileFrameTypeValues("dotnet") 
  // [JVM](https://wikipedia.org/wiki/Java_virtual_machine)
  public static let Jvm = ProfileFrameTypeValues("jvm") 
  // [Kernel](https://wikipedia.org/wiki/Kernel_(operating_system))
  public static let Kernel = ProfileFrameTypeValues("kernel") 
  // Can be one of but not limited to [C](https://wikipedia.org/wiki/C_(programming_language)), [C++](https://wikipedia.org/wiki/C%2B%2B), [Go](https://wikipedia.org/wiki/Go_(programming_language)) or [Rust](https://wikipedia.org/wiki/Rust_(programming_language)). If possible, a more precise value MUST be used.
  public static let Native = ProfileFrameTypeValues("native") 
  // [Perl](https://wikipedia.org/wiki/Perl)
  public static let Perl = ProfileFrameTypeValues("perl") 
  // [PHP](https://wikipedia.org/wiki/PHP)
  public static let Php = ProfileFrameTypeValues("php") 
  // [Python](https://wikipedia.org/wiki/Python_(programming_language))
  public static let Cpython = ProfileFrameTypeValues("cpython") 
  // [Ruby](https://wikipedia.org/wiki/Ruby_(programming_language))
  public static let Ruby = ProfileFrameTypeValues("ruby") 
  // [V8JS](https://wikipedia.org/wiki/V8_(JavaScript_engine))
  public static let V8js = ProfileFrameTypeValues("v8js") 
  // [Erlang](https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine))
  public static let Beam = ProfileFrameTypeValues("beam") 
  // [Go](https://wikipedia.org/wiki/Go_(programming_language)),
  public static let Go = ProfileFrameTypeValues("go") 
  // [Rust](https://wikipedia.org/wiki/Rust_(programming_language))
  public static let Rust = ProfileFrameTypeValues("rust") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The filesystem state
*/
/// - Tag: otelSystemFilesystemStateValues
public struct SystemFilesystemStateValues: CustomStringConvertible {
  public static let Used = SystemFilesystemStateValues("used") 
  public static let Free = SystemFilesystemStateValues("free") 
  public static let Reserved = SystemFilesystemStateValues("reserved") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The filesystem type
*/
/// - Tag: otelSystemFilesystemTypeValues
public struct SystemFilesystemTypeValues: CustomStringConvertible {
  public static let Fat32 = SystemFilesystemTypeValues("fat32") 
  public static let Exfat = SystemFilesystemTypeValues("exfat") 
  public static let Ntfs = SystemFilesystemTypeValues("ntfs") 
  public static let Refs = SystemFilesystemTypeValues("refs") 
  public static let Hfsplus = SystemFilesystemTypeValues("hfsplus") 
  public static let Ext4 = SystemFilesystemTypeValues("ext4") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The memory state
*/
/// - Tag: otelSystemMemoryStateValues
public struct SystemMemoryStateValues: CustomStringConvertible {
  // Actual used virtual memory in bytes.
  public static let Used = SystemMemoryStateValues("used") 
  public static let Free = SystemMemoryStateValues("free") 
  public static let Buffers = SystemMemoryStateValues("buffers") 
  public static let Cached = SystemMemoryStateValues("cached") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The paging access direction
*/
/// - Tag: otelSystemPagingDirectionValues
public struct SystemPagingDirectionValues: CustomStringConvertible {
  public static let In = SystemPagingDirectionValues("in") 
  public static let Out = SystemPagingDirectionValues("out") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The memory paging state
*/
/// - Tag: otelSystemPagingStateValues
public struct SystemPagingStateValues: CustomStringConvertible {
  public static let Used = SystemPagingStateValues("used") 
  public static let Free = SystemPagingStateValues("free") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The memory paging type
*/
/// - Tag: otelSystemPagingTypeValues
public struct SystemPagingTypeValues: CustomStringConvertible {
  public static let Major = SystemPagingTypeValues("major") 
  public static let Minor = SystemPagingTypeValues("minor") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The process state, e.g., [Linux Process State Codes](https://man7.org/linux/man-pages/man1/ps.1.html#PROCESS_STATE_CODES)
*/
/// - Tag: otelSystemProcessStatusValues
public struct SystemProcessStatusValues: CustomStringConvertible {
  public static let Running = SystemProcessStatusValues("running") 
  public static let Sleeping = SystemProcessStatusValues("sleeping") 
  public static let Stopped = SystemProcessStatusValues("stopped") 
  public static let Defunct = SystemProcessStatusValues("defunct") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The language of the telemetry SDK.
*/
/// - Tag: otelTelemetrySdkLanguageValues
public struct TelemetrySdkLanguageValues: CustomStringConvertible {
  public static let Cpp = TelemetrySdkLanguageValues("cpp") 
  public static let Dotnet = TelemetrySdkLanguageValues("dotnet") 
  public static let Erlang = TelemetrySdkLanguageValues("erlang") 
  public static let Go = TelemetrySdkLanguageValues("go") 
  public static let Java = TelemetrySdkLanguageValues("java") 
  public static let Nodejs = TelemetrySdkLanguageValues("nodejs") 
  public static let Php = TelemetrySdkLanguageValues("php") 
  public static let Python = TelemetrySdkLanguageValues("python") 
  public static let Ruby = TelemetrySdkLanguageValues("ruby") 
  public static let Rust = TelemetrySdkLanguageValues("rust") 
  public static let Swift = TelemetrySdkLanguageValues("swift") 
  public static let Webjs = TelemetrySdkLanguageValues("webjs") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The status of the actual test case result from test execution.
*/
/// - Tag: otelTestCaseResultStatusValues
public struct TestCaseResultStatusValues: CustomStringConvertible {
  // pass
  public static let Pass = TestCaseResultStatusValues("pass") 
  // fail
  public static let Fail = TestCaseResultStatusValues("fail") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The status of the test suite run.
*/
/// - Tag: otelTestSuiteRunStatusValues
public struct TestSuiteRunStatusValues: CustomStringConvertible {
  // success
  public static let Success = TestSuiteRunStatusValues("success") 
  // failure
  public static let Failure = TestSuiteRunStatusValues("failure") 
  // skipped
  public static let Skipped = TestSuiteRunStatusValues("skipped") 
  // aborted
  public static let Aborted = TestSuiteRunStatusValues("aborted") 
  // timed_out
  public static let TimedOut = TestSuiteRunStatusValues("timed_out") 
  // in_progress
  public static let InProgress = TestSuiteRunStatusValues("in_progress") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Normalized lowercase protocol name parsed from original string of the negotiated [SSL/TLS protocol version](https://docs.openssl.org/1.1.1/man3/SSL_get_version/#return-values)
*/
/// - Tag: otelTlsProtocolNameValues
public struct TlsProtocolNameValues: CustomStringConvertible {
  public static let Ssl = TlsProtocolNameValues("ssl") 
  public static let Tls = TlsProtocolNameValues("tls") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  Specifies the category of synthetic traffic, such as tests or bots.
*/
/// - Tag: otelUserAgentSyntheticTypeValues
public struct UserAgentSyntheticTypeValues: CustomStringConvertible {
  // Bot source.
  public static let Bot = UserAgentSyntheticTypeValues("bot") 
  // Synthetic test source.
  public static let Test = UserAgentSyntheticTypeValues("test") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of garbage collection.
*/
/// - Tag: otelV8jsGcTypeValues
public struct V8jsGcTypeValues: CustomStringConvertible {
  // Major (Mark Sweep Compact).
  public static let Major = V8jsGcTypeValues("major") 
  // Minor (Scavenge).
  public static let Minor = V8jsGcTypeValues("minor") 
  // Incremental (Incremental Marking).
  public static let Incremental = V8jsGcTypeValues("incremental") 
  // Weak Callbacks (Process Weak Callbacks).
  public static let Weakcb = V8jsGcTypeValues("weakcb") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The name of the space type of heap memory.
*/
/// - Tag: otelV8jsHeapSpaceNameValues
public struct V8jsHeapSpaceNameValues: CustomStringConvertible {
  // New memory space.
  public static let NewSpace = V8jsHeapSpaceNameValues("new_space") 
  // Old memory space.
  public static let OldSpace = V8jsHeapSpaceNameValues("old_space") 
  // Code memory space.
  public static let CodeSpace = V8jsHeapSpaceNameValues("code_space") 
  // Map memory space.
  public static let MapSpace = V8jsHeapSpaceNameValues("map_space") 
  // Large object memory space.
  public static let LargeObjectSpace = V8jsHeapSpaceNameValues("large_object_space") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The state of the change (pull request/merge request/changelist).
*/
/// - Tag: otelVcsChangeStateValues
public struct VcsChangeStateValues: CustomStringConvertible {
  // Open means the change is currently active and under review. It hasn't been merged into the target branch yet, and it's still possible to make changes or add comments.
  public static let Open = VcsChangeStateValues("open") 
  // WIP (work-in-progress, draft) means the change is still in progress and not yet ready for a full review. It might still undergo significant changes.
  public static let Wip = VcsChangeStateValues("wip") 
  // Closed means the merge request has been closed without merging. This can happen for various reasons, such as the changes being deemed unnecessary, the issue being resolved in another way, or the author deciding to withdraw the request.
  public static let Closed = VcsChangeStateValues("closed") 
  // Merged indicates that the change has been successfully integrated into the target codebase.
  public static let Merged = VcsChangeStateValues("merged") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of line change being measured on a branch or change.
*/
/// - Tag: otelVcsLineChangeTypeValues
public struct VcsLineChangeTypeValues: CustomStringConvertible {
  // How many lines were added.
  public static let Added = VcsLineChangeTypeValues("added") 
  // How many lines were removed.
  public static let Removed = VcsLineChangeTypeValues("removed") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The name of the version control system provider.
*/
/// - Tag: otelVcsProviderNameValues
public struct VcsProviderNameValues: CustomStringConvertible {
  // [GitHub](https://github.com)
  public static let Github = VcsProviderNameValues("github") 
  // [GitLab](https://gitlab.com)
  public static let Gitlab = VcsProviderNameValues("gitlab") 
  // [Gitea](https://gitea.io)
  public static let Gitea = VcsProviderNameValues("gitea") 
  // [Bitbucket](https://bitbucket.org)
  public static let Bitbucket = VcsProviderNameValues("bitbucket") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository.
*/
/// - Tag: otelVcsRefBaseTypeValues
public struct VcsRefBaseTypeValues: CustomStringConvertible {
  // [branch](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbranchabranch)
  public static let Branch = VcsRefBaseTypeValues("branch") 
  // [tag](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddeftagatag)
  public static let Tag = VcsRefBaseTypeValues("tag") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository.
*/
/// - Tag: otelVcsRefHeadTypeValues
public struct VcsRefHeadTypeValues: CustomStringConvertible {
  // [branch](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbranchabranch)
  public static let Branch = VcsRefHeadTypeValues("branch") 
  // [tag](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddeftagatag)
  public static let Tag = VcsRefHeadTypeValues("tag") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of the [reference](https://git-scm.com/docs/gitglossary#def_ref) in the repository.
*/
/// - Tag: otelVcsRefTypeValues
public struct VcsRefTypeValues: CustomStringConvertible {
  // [branch](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbranchabranch)
  public static let Branch = VcsRefTypeValues("branch") 
  // [tag](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddeftagatag)
  public static let Tag = VcsRefTypeValues("tag") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}

/** 
  The type of revision comparison.
*/
/// - Tag: otelVcsRevisionDeltaDirectionValues
public struct VcsRevisionDeltaDirectionValues: CustomStringConvertible {
  // How many revisions the change is behind the target ref.
  public static let Behind = VcsRevisionDeltaDirectionValues("behind") 
  // How many revisions the change is ahead of the target ref.
  public static let Ahead = VcsRevisionDeltaDirectionValues("ahead") 

  internal let value: String

  public init(_ customValue: String) {
    self.value = customValue
  }

  public var description: String {
    return value
  }
}
