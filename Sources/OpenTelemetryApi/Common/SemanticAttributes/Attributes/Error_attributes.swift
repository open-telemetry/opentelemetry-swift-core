/*
 * Copyright The OpenTelemetry Authors 
 * SPDX-License-Identifier: Apache-2.0
 */

// DO **NOT** EDIT. This file is automatically generated.

import Foundation 

extension SemanticConventions {
  public enum Error: String {

    /**
     A message providing more detail about an error in human-readable form.

      - Examples:
      ```
      attributes[SemanticConventions.Error.message.rawValue] = "Unexpected input type: string"
      attributes[SemanticConventions.Error.message.rawValue] = "The user has exceeded their storage quota"
      ```

     - Note: `error.message` should provide additional context and detail about an error.
       It is NOT RECOMMENDED to duplicate the value of `error.type` in `error.message`.
       It is also NOT RECOMMENDED to duplicate the value of `exception.message` in `error.message`.

       `error.message` is NOT RECOMMENDED for metrics or spans due to its unbounded cardinality and overlap with span status.

     - Requires: Value type should be `String`
    */
    case message = "error.message"

    /**
     Describes a class of error the operation ended with.

      - Examples:
      ```
      attributes[SemanticConventions.Error.type.rawValue] = .timeout
      attributes[SemanticConventions.Error.type.rawValue] = .java.net.UnknownHostException
      attributes[SemanticConventions.Error.type.rawValue] = .server_certificate_invalid
      attributes[SemanticConventions.Error.type.rawValue] = .500
      ```

     - Note: The `error.type` SHOULD be predictable, and SHOULD have low cardinality.

       When `error.type` is set to a type (e.g., an exception type), its
       canonical class name identifying the type within the artifact SHOULD be used.

       Instrumentations SHOULD document the list of errors they report.

       The cardinality of `error.type` within one instrumentation library SHOULD be low.
       Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
       should be prepared for `error.type` to have high cardinality at query time when no
       additional filters are applied.

       If the operation has completed successfully, instrumentations SHOULD NOT set `error.type`.

       If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
       it's RECOMMENDED to:

       - Use a domain-specific attribute
       - Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.

     - Requires: Value should be one of ``TypeValues`` (of type `String`)
    */
    case type = "error.type"

    /** 
      Describes a class of error the operation ended with.
    */
    public struct TypeValues: CustomStringConvertible {
      
      /// A fallback error value to be used when the instrumentation doesn't define a custom value.
      public static let other = TypeValues("_OTHER") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }
  }
}