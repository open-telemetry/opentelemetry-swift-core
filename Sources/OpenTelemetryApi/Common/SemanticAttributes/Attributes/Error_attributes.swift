/*
 * Copyright The OpenTelemetry Authors 
 * SPDX-License-Identifier: Apache-2.0
 */

// DO **NOT** EDIT. This file is automatically generated.

import Foundation 

extension SemanticConventions {
  enum Error: String {
    /**
     A message providing more detail about an error in human-readable form.
      // Examples
      attributes[.errorMessage] = "Unexpected input type: string"
      attributes[.errorMessage] = "The user has exceeded their storage quota"
     - Note: `error.message` should provide additional context and detail about an error.
     It is NOT RECOMMENDED to duplicate the value of `error.type` in `error.message`.
     It is also NOT RECOMMENDED to duplicate the value of `exception.message` in `error.message`.

     `error.message` is NOT RECOMMENDED for metrics or spans due to its unbounded cardinality and overlap with span status.
     - Requires: Value type should be `String`
    */
    case errorMessage = "error.message"

    /**
     Describes a class of error the operation ended with.
      // Examples
      attributes[.errorType] = timeout
      attributes[.errorType] = java.net.UnknownHostException
      attributes[.errorType] = server_certificate_invalid
      attributes[.errorType] = 500
     - Note: The `error.type` SHOULD be predictable, and SHOULD have low cardinality.

     When `error.type` is set to a type (e.g., an exception type), its
     canonical class name identifying the type within the artifact SHOULD be used.

     Instrumentations SHOULD document the list of errors they report.

     The cardinality of `error.type` within one instrumentation library SHOULD be low.
     Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
     should be prepared for `error.type` to have high cardinality at query time when no
     additional filters are applied.

     If the operation has completed successfully, instrumentations SHOULD NOT set `error.type`.

     If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
     it's RECOMMENDED to:

     - Use a domain-specific attribute
     - Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.
     - Requires: Value should be one of [`/output/Attributes/Error_attributes.swift.ErrorTypeValues`](x-source-tag://otelErrorTypeValues) (of type `String`)
    */
    case errorType = "error.type"


    /** 
      Describes a class of error the operation ended with.
    */
    /// - Tag: otelErrorTypeValues
    public struct ErrorTypeValues: CustomStringConvertible {
      /**
      A fallback error value to be used when the instrumentation doesn't define a custom value.
      */
      public static let other = ErrorTypeValues("_OTHER") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }
  }
}