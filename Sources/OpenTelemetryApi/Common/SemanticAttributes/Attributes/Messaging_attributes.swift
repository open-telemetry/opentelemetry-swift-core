/*
 * Copyright The OpenTelemetry Authors 
 * SPDX-License-Identifier: Apache-2.0
 */

// DO **NOT** EDIT. This file is automatically generated.

import Foundation 

extension SemanticConventions {
  enum Messaging: String {
    /**
     The number of messages sent, received, or processed in the scope of the batching operation.
      // Examples
      attributes[.messagingBatchMessageCount] = 0
      attributes[.messagingBatchMessageCount] = 1
      attributes[.messagingBatchMessageCount] = 2
     - Note: Instrumentations SHOULD NOT set `messaging.batch.message_count` on spans that operate with a single message. When a messaging client library supports both batch and single-message API for the same operation, instrumentations SHOULD use `messaging.batch.message_count` for batching APIs and SHOULD NOT use it for single-message APIs.
     - Requires: Value type should be `Int`
    */
    case messagingBatchMessageCount = "messaging.batch.message_count"

    /**
     A unique identifier for the client that consumes or produces a message.
      // Examples
      attributes[.messagingClientId] = "client-5"
      attributes[.messagingClientId] = "myhost@8742@s8083jm"
     - Requires: Value type should be `String`
    */
    case messagingClientId = "messaging.client.id"

    /**
     The name of the consumer group with which a consumer is associated.
      // Examples
      attributes[.messagingConsumerGroupName] = "my-group"
      attributes[.messagingConsumerGroupName] = "indexer"
     - Note: Semantic conventions for individual messaging systems SHOULD document whether `messaging.consumer.group.name` is applicable and what it means in the context of that system.
     - Requires: Value type should be `String`
    */
    case messagingConsumerGroupName = "messaging.consumer.group.name"

    /**
     A boolean that is true if the message destination is anonymous (could be unnamed or have auto-generated name).
     - Requires: Value type should be `Bool`
    */
    case messagingDestinationAnonymous = "messaging.destination.anonymous"

    /**
     The message destination name
      // Examples
      attributes[.messagingDestinationName] = "MyQueue"
      attributes[.messagingDestinationName] = "MyTopic"
     - Note: Destination name SHOULD uniquely identify a specific queue, topic or other entity within the broker. If
     the broker doesn't have such notion, the destination name SHOULD uniquely identify the broker.
     - Requires: Value type should be `String`
    */
    case messagingDestinationName = "messaging.destination.name"

    /**
     The identifier of the partition messages are sent to or received from, unique within the `messaging.destination.name`.
      // Examples
  
   attributes[.messagingDestinationPartitionId] = "1"
     - Requires: Value type should be `String`
    */
    case messagingDestinationPartitionId = "messaging.destination.partition.id"

    /**
     The name of the destination subscription from which a message is consumed.
      // Examples
      attributes[.messagingDestinationSubscriptionName] = "subscription-a"
     - Note: Semantic conventions for individual messaging systems SHOULD document whether `messaging.destination.subscription.name` is applicable and what it means in the context of that system.
     - Requires: Value type should be `String`
    */
    case messagingDestinationSubscriptionName = "messaging.destination.subscription.name"

    /**
     Low cardinality representation of the messaging destination name
      // Examples
      attributes[.messagingDestinationTemplate] = "/customers/{customerId}"
     - Note: Destination names could be constructed from templates. An example would be a destination name involving a user name or product id. Although the destination name in this case is of high cardinality, the underlying template is of low cardinality and can be effectively used for grouping and aggregation.
     - Requires: Value type should be `String`
    */
    case messagingDestinationTemplate = "messaging.destination.template"

    /**
     A boolean that is true if the message destination is temporary and might not exist anymore after messages are processed.
     - Requires: Value type should be `Bool`
    */
    case messagingDestinationTemporary = "messaging.destination.temporary"

    /**
     The UTC epoch seconds at which the message has been accepted and stored in the entity.
      // Examples
  
   attributes[.messagingEventhubsMessageEnqueuedTime] = 1701393730
     - Requires: Value type should be `Int`
    */
    case messagingEventhubsMessageEnqueuedTime = "messaging.eventhubs.message.enqueued_time"

    /**
     The ack deadline in seconds set for the modify ack deadline request.
      // Examples
  
   attributes[.messagingGcpPubsubMessageAckDeadline] = 10
     - Requires: Value type should be `Int`
    */
    case messagingGcpPubsubMessageAckDeadline = "messaging.gcp_pubsub.message.ack_deadline"

    /**
     The ack id for a given message.
      // Examples
  
   attributes[.messagingGcpPubsubMessageAckId] = "ack_id"
     - Requires: Value type should be `String`
    */
    case messagingGcpPubsubMessageAckId = "messaging.gcp_pubsub.message.ack_id"

    /**
     The delivery attempt for a given message.
      // Examples
  
   attributes[.messagingGcpPubsubMessageDeliveryAttempt] = 2
     - Requires: Value type should be `Int`
    */
    case messagingGcpPubsubMessageDeliveryAttempt = "messaging.gcp_pubsub.message.delivery_attempt"

    /**
     The ordering key for a given message. If the attribute is not present, the message does not have an ordering key.
      // Examples
  
   attributes[.messagingGcpPubsubMessageOrderingKey] = "ordering_key"
     - Requires: Value type should be `String`
    */
    case messagingGcpPubsubMessageOrderingKey = "messaging.gcp_pubsub.message.ordering_key"

    /**
     Message keys in Kafka are used for grouping alike messages to ensure they're processed on the same partition. They differ from `messaging.message.id` in that they're not unique. If the key is `null`, the attribute MUST NOT be set.
      // Examples
  
   attributes[.messagingKafkaMessageKey] = "myKey"
     - Note: If the key type is not string, it's string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don't include its value.
     - Requires: Value type should be `String`
    */
    case messagingKafkaMessageKey = "messaging.kafka.message.key"

    /**
     A boolean that is true if the message is a tombstone.
     - Requires: Value type should be `Bool`
    */
    case messagingKafkaMessageTombstone = "messaging.kafka.message.tombstone"

    /**
     The offset of a record in the corresponding Kafka partition.
      // Examples
  
   attributes[.messagingKafkaOffset] = 42
     - Requires: Value type should be `Int`
    */
    case messagingKafkaOffset = "messaging.kafka.offset"

    /**
     The size of the message body in bytes.
      // Examples
  
   attributes[.messagingMessageBodySize] = 1439
     - Note: This can refer to both the compressed or uncompressed body size. If both sizes are known, the uncompressed
     body size should be used.
     - Requires: Value type should be `Int`
    */
    case messagingMessageBodySize = "messaging.message.body.size"

    /**
     The conversation ID identifying the conversation to which the message belongs, represented as a string. Sometimes called "Correlation ID".
      // Examples
  
   attributes[.messagingMessageConversationId] = "MyConversationId"
     - Requires: Value type should be `String`
    */
    case messagingMessageConversationId = "messaging.message.conversation_id"

    /**
     The size of the message body and metadata in bytes.
      // Examples
  
   attributes[.messagingMessageEnvelopeSize] = 2738
     - Note: This can refer to both the compressed or uncompressed size. If both sizes are known, the uncompressed
     size should be used.
     - Requires: Value type should be `Int`
    */
    case messagingMessageEnvelopeSize = "messaging.message.envelope.size"

    /**
     A value used by the messaging system as an identifier for the message, represented as a string.
      // Examples
  
   attributes[.messagingMessageId] = "452a7c7c7c7048c2f887f61572b18fc2"
     - Requires: Value type should be `String`
    */
    case messagingMessageId = "messaging.message.id"

    /**
     The system-specific name of the messaging operation.
      // Examples
      attributes[.messagingOperationName] = "ack"
      attributes[.messagingOperationName] = "nack"
      attributes[.messagingOperationName] = "send"
     - Requires: Value type should be `String`
    */
    case messagingOperationName = "messaging.operation.name"

    /**
     A string identifying the type of the messaging operation.
     - Note: If a custom value is used, it MUST be of low cardinality.
     - Requires: Value should be one of [`/output/Attributes/Messaging_attributes.swift.MessagingOperationTypeValues`](x-source-tag://otelMessagingOperationTypeValues) (of type `String`)
    */
    case messagingOperationType = "messaging.operation.type"

    /**
     RabbitMQ message routing key.
      // Examples
  
   attributes[.messagingRabbitmqDestinationRoutingKey] = "myKey"
     - Requires: Value type should be `String`
    */
    case messagingRabbitmqDestinationRoutingKey = "messaging.rabbitmq.destination.routing_key"

    /**
     RabbitMQ message delivery tag
      // Examples
  
   attributes[.messagingRabbitmqMessageDeliveryTag] = 123
     - Requires: Value type should be `Int`
    */
    case messagingRabbitmqMessageDeliveryTag = "messaging.rabbitmq.message.delivery_tag"

    /**
     Model of message consumption. This only applies to consumer spans.
     - Requires: Value should be one of [`/output/Attributes/Messaging_attributes.swift.MessagingRocketmqConsumptionModelValues`](x-source-tag://otelMessagingRocketmqConsumptionModelValues) (of type `String`)
    */
    case messagingRocketmqConsumptionModel = "messaging.rocketmq.consumption_model"

    /**
     The delay time level for delay message, which determines the message delay time.
      // Examples
  
   attributes[.messagingRocketmqMessageDelayTimeLevel] = 3
     - Requires: Value type should be `Int`
    */
    case messagingRocketmqMessageDelayTimeLevel = "messaging.rocketmq.message.delay_time_level"

    /**
     The timestamp in milliseconds that the delay message is expected to be delivered to consumer.
      // Examples
  
   attributes[.messagingRocketmqMessageDeliveryTimestamp] = 1665987217045
     - Requires: Value type should be `Int`
    */
    case messagingRocketmqMessageDeliveryTimestamp = "messaging.rocketmq.message.delivery_timestamp"

    /**
     It is essential for FIFO message. Messages that belong to the same message group are always processed one by one within the same consumer group.
      // Examples
  
   attributes[.messagingRocketmqMessageGroup] = "myMessageGroup"
     - Requires: Value type should be `String`
    */
    case messagingRocketmqMessageGroup = "messaging.rocketmq.message.group"

    /**
     Key(s) of message, another way to mark message besides message id.
      // Examples
      attributes[.messagingRocketmqMessageKeys] = ["keyA", "keyB"]
     - Requires: Value type should be `[String]`
    */
    case messagingRocketmqMessageKeys = "messaging.rocketmq.message.keys"

    /**
     The secondary classifier of message besides topic.
      // Examples
  
   attributes[.messagingRocketmqMessageTag] = "tagA"
     - Requires: Value type should be `String`
    */
    case messagingRocketmqMessageTag = "messaging.rocketmq.message.tag"

    /**
     Type of message.
     - Requires: Value should be one of [`/output/Attributes/Messaging_attributes.swift.MessagingRocketmqMessageTypeValues`](x-source-tag://otelMessagingRocketmqMessageTypeValues) (of type `String`)
    */
    case messagingRocketmqMessageType = "messaging.rocketmq.message.type"

    /**
     Namespace of RocketMQ resources, resources in different namespaces are individual.
      // Examples
  
   attributes[.messagingRocketmqNamespace] = "myNamespace"
     - Requires: Value type should be `String`
    */
    case messagingRocketmqNamespace = "messaging.rocketmq.namespace"

    /**
     Describes the [settlement type](https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock).
     - Requires: Value should be one of [`/output/Attributes/Messaging_attributes.swift.MessagingServicebusDispositionStatusValues`](x-source-tag://otelMessagingServicebusDispositionStatusValues) (of type `String`)
    */
    case messagingServicebusDispositionStatus = "messaging.servicebus.disposition_status"

    /**
     Number of deliveries that have been attempted for this message.
      // Examples
  
   attributes[.messagingServicebusMessageDeliveryCount] = 2
     - Requires: Value type should be `Int`
    */
    case messagingServicebusMessageDeliveryCount = "messaging.servicebus.message.delivery_count"

    /**
     The UTC epoch seconds at which the message has been accepted and stored in the entity.
      // Examples
  
   attributes[.messagingServicebusMessageEnqueuedTime] = 1701393730
     - Requires: Value type should be `Int`
    */
    case messagingServicebusMessageEnqueuedTime = "messaging.servicebus.message.enqueued_time"

    /**
     The messaging system as identified by the client instrumentation.
     - Note: The actual messaging system may differ from the one known by the client. For example, when using Kafka client libraries to communicate with Azure Event Hubs, the `messaging.system` is set to `kafka` based on the instrumentation's best knowledge.
     - Requires: Value should be one of [`/output/Attributes/Messaging_attributes.swift.MessagingSystemValues`](x-source-tag://otelMessagingSystemValues) (of type `String`)
    */
    case messagingSystem = "messaging.system"


    /** 
      A string identifying the type of the messaging operation.
    */
    /// - Tag: otelMessagingOperationTypeValues
    public struct MessagingOperationTypeValues: CustomStringConvertible {
      /**
      A message is created. "Create" spans always refer to a single message and are used to provide a unique creation context for messages in batch sending scenarios.
      */
      public static let create = MessagingOperationTypeValues("create") 
      /**
      One or more messages are provided for sending to an intermediary. If a single message is sent, the context of the "Send" span can be used as the creation context and no "Create" span needs to be created.
      */
      public static let send = MessagingOperationTypeValues("send") 
      /**
      One or more messages are requested by a consumer. This operation refers to pull-based scenarios, where consumers explicitly call methods of messaging SDKs to receive messages.
      */
      public static let receive = MessagingOperationTypeValues("receive") 
      /**
      One or more messages are processed by a consumer.
      */
      public static let process = MessagingOperationTypeValues("process") 
      /**
      One or more messages are settled.
      */
      public static let settle = MessagingOperationTypeValues("settle") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }

    /** 
      Model of message consumption. This only applies to consumer spans.
    */
    /// - Tag: otelMessagingRocketmqConsumptionModelValues
    public struct MessagingRocketmqConsumptionModelValues: CustomStringConvertible {
      /**
      Clustering consumption model
      */
      public static let clustering = MessagingRocketmqConsumptionModelValues("clustering") 
      /**
      Broadcasting consumption model
      */
      public static let broadcasting = MessagingRocketmqConsumptionModelValues("broadcasting") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }

    /** 
      Type of message.
    */
    /// - Tag: otelMessagingRocketmqMessageTypeValues
    public struct MessagingRocketmqMessageTypeValues: CustomStringConvertible {
      /**
      Normal message
      */
      public static let normal = MessagingRocketmqMessageTypeValues("normal") 
      /**
      FIFO message
      */
      public static let fifo = MessagingRocketmqMessageTypeValues("fifo") 
      /**
      Delay message
      */
      public static let delay = MessagingRocketmqMessageTypeValues("delay") 
      /**
      Transaction message
      */
      public static let transaction = MessagingRocketmqMessageTypeValues("transaction") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }

    /** 
      Describes the [settlement type](https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock).
    */
    /// - Tag: otelMessagingServicebusDispositionStatusValues
    public struct MessagingServicebusDispositionStatusValues: CustomStringConvertible {
      /**
      Message is completed
      */
      public static let complete = MessagingServicebusDispositionStatusValues("complete") 
      /**
      Message is abandoned
      */
      public static let abandon = MessagingServicebusDispositionStatusValues("abandon") 
      /**
      Message is sent to dead letter queue
      */
      public static let deadLetter = MessagingServicebusDispositionStatusValues("dead_letter") 
      /**
      Message is deferred
      */
      public static let _defer = MessagingServicebusDispositionStatusValues("defer") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }

    /** 
      The messaging system as identified by the client instrumentation.
    */
    /// - Tag: otelMessagingSystemValues
    public struct MessagingSystemValues: CustomStringConvertible {
      /**
      Apache ActiveMQ
      */
      public static let activemq = MessagingSystemValues("activemq") 
      /**
      Amazon Simple Notification Service (SNS)
      */
      public static let awsSns = MessagingSystemValues("aws.sns") 
      /**
      Amazon Simple Queue Service (SQS)
      */
      public static let awsSqs = MessagingSystemValues("aws_sqs") 
      /**
      Azure Event Grid
      */
      public static let eventgrid = MessagingSystemValues("eventgrid") 
      /**
      Azure Event Hubs
      */
      public static let eventhubs = MessagingSystemValues("eventhubs") 
      /**
      Azure Service Bus
      */
      public static let servicebus = MessagingSystemValues("servicebus") 
      /**
      Google Cloud Pub/Sub
      */
      public static let gcpPubsub = MessagingSystemValues("gcp_pubsub") 
      /**
      Java Message Service
      */
      public static let jms = MessagingSystemValues("jms") 
      /**
      Apache Kafka
      */
      public static let kafka = MessagingSystemValues("kafka") 
      /**
      RabbitMQ
      */
      public static let rabbitmq = MessagingSystemValues("rabbitmq") 
      /**
      Apache RocketMQ
      */
      public static let rocketmq = MessagingSystemValues("rocketmq") 
      /**
      Apache Pulsar
      */
      public static let pulsar = MessagingSystemValues("pulsar") 

      internal let value: String 

      public init(_ customValue: String) {
        self.value = customValue
      }

      public var description: String { 
        return value
      }
    }
  }
}